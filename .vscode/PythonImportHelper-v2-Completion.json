[
    {
        "label": "runpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "runpy",
        "description": "runpy",
        "detail": "runpy",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "site",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "site",
        "description": "site",
        "detail": "site",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ItemHelpers",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "MessageOutputItem",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "trace",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "trace",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "FunctionToolResult",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ModelSettings",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunContextWrapper",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ToolsToFinalOutputFunction",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ToolsToFinalOutputResult",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "function_tool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "GuardrailFunctionOutput",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "InputGuardrailTripwireTriggered",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunContextWrapper",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "TResponseInputItem",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "input_guardrail",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ItemHelpers",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "TResponseInputItem",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "trace",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "GuardrailFunctionOutput",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "OutputGuardrailTripwireTriggered",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunContextWrapper",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "output_guardrail",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ItemHelpers",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "trace",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RawResponsesStreamEvent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "TResponseInputItem",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "trace",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "AgentHooks",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunContextWrapper",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Tool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "function_tool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ToolCallItem",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunContextWrapper",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunContextWrapper",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunHooks",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Tool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Usage",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "function_tool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ToolCallItem",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ItemHelpers",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "function_tool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "function_tool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "HandoffOutputItem",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ItemHelpers",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "MessageOutputItem",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunContextWrapper",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ToolCallItem",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ToolCallOutputItem",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "TResponseInputItem",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "function_tool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "handoff",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "trace",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "HandoffInputData",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "function_tool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "handoff",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "trace",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "HandoffInputData",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "function_tool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "handoff",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "trace",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "OpenAIChatCompletionsModel",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "function_tool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "set_tracing_disabled",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "function_tool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "set_default_openai_api",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "set_default_openai_client",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "set_tracing_disabled",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Model",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ModelProvider",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "OpenAIChatCompletionsModel",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunConfig",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "function_tool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "set_tracing_disabled",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "WebSearchTool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "custom_span",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "gen_trace_id",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "trace",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "AsyncComputer",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Button",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ComputerTool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Environment",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ModelSettings",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "trace",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "FileSearchTool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "trace",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "WebSearchTool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "trace",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Handoff",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunContextWrapper",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "handoff",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "GuardrailFunctionOutput",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Handoff",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "HandoffInputData",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "InputGuardrail",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "InputGuardrailTripwireTriggered",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ModelBehaviorError",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "OutputGuardrail",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "OutputGuardrailTripwireTriggered",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunContextWrapper",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "UserError",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "handoff",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "GuardrailFunctionOutput",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Handoff",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "HandoffInputData",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "InputGuardrail",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "InputGuardrailTripwireTriggered",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "OutputGuardrail",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "OutputGuardrailTripwireTriggered",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunContextWrapper",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "UserError",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "handoff",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunConfig",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "trace",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "AgentHooks",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "AsyncComputer",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Computer",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ComputerTool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunConfig",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunContextWrapper",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunHooks",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "set_default_openai_api",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "set_default_openai_client",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "set_default_openai_key",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "HandoffInputData",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunContextWrapper",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "FunctionTool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ModelBehaviorError",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunContextWrapper",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "function_tool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "function_tool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunContextWrapper",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunHooks",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "TContext",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Tool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "GuardrailFunctionOutput",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "InputGuardrail",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "OutputGuardrail",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunContextWrapper",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "TResponseInputItem",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "UserError",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Handoff",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "HandoffInputData",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "MessageOutputItem",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ModelBehaviorError",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunContextWrapper",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "UserError",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "handoff",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ItemHelpers",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "MessageOutputItem",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ModelResponse",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ReasoningItem",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunItem",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "TResponseInputItem",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Usage",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "MaxTurnsExceeded",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ModelResponse",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ModelSettings",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ModelTracing",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "OpenAIChatCompletionsModel",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "OpenAIProvider",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "generation_span",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "AgentOutputSchema",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Computer",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ComputerTool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "FileSearchTool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Handoff",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Tool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "UserError",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "WebSearchTool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "function_tool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "handoff",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "AgentOutputSchema",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ModelBehaviorError",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "UserError",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "FunctionTool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Handoff",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "TResponseInputItem",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "default_tool_error_function",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "function_tool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ModelSettings",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ModelTracing",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "OpenAIResponsesModel",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "trace",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunResult",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunConfig",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "MessageOutputItem",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ModelResponse",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunConfig",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunContextWrapper",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunHooks",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunItem",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ToolCallItem",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ToolCallOutputItem",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "TResponseInputItem",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Usage",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Computer",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ComputerTool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Handoff",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ModelBehaviorError",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ModelResponse",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ReasoningItem",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunContextWrapper",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ToolCallItem",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Usage",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Handoff",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "function_tool",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "handoff",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "FunctionToolResult",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunConfig",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunContextWrapper",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ToolCallOutputItem",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ToolsToFinalOutputResult",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "UserError",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "GuardrailFunctionOutput",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "InputGuardrail",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "InputGuardrailTripwireTriggered",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "MaxTurnsExceeded",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ModelBehaviorError",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunContextWrapper",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "TResponseInputItem",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "AgentSpanData",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "FunctionSpanData",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "GenerationSpanData",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "GuardrailFunctionOutput",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "InputGuardrail",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "InputGuardrailTripwireTriggered",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "MaxTurnsExceeded",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "ModelBehaviorError",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "OutputGuardrail",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "OutputGuardrailTripwireTriggered",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "RunContextWrapper",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "TResponseInputItem",
        "importPath": "agents",
        "description": "agents",
        "isExtraImport": true,
        "detail": "agents",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "TypeAdapter",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ValidationError",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "TypeAdapter",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "create_model",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "TypeAdapter",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ValidationError",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ValidationError",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "overload",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "overload",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "get_args",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "get_origin",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "get_type_hints",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "overload",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "overload",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "overload",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "dataclasses",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "dataclasses",
        "description": "dataclasses",
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "uuid",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uuid",
        "description": "uuid",
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "ResponseContentPartDoneEvent",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseTextDeltaEvent",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseTextDeltaEvent",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "EasyInputMessageParam",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "Response",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseCompletedEvent",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseContentPartAddedEvent",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseContentPartDoneEvent",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseCreatedEvent",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseFileSearchToolCallParam",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseFunctionCallArgumentsDeltaEvent",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseFunctionToolCall",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseFunctionToolCallParam",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseInputContentParam",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseInputImageParam",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseInputTextParam",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseOutputItem",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseOutputItemAddedEvent",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseOutputItemDoneEvent",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseOutputMessage",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseOutputMessageParam",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseOutputRefusal",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseOutputText",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseRefusalDeltaEvent",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseTextDeltaEvent",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseUsage",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "Response",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseCompletedEvent",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseStreamEvent",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseTextConfigParam",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ToolParam",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "WebSearchToolParam",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "response_create_params",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseComputerToolCall",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseFileSearchToolCall",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseFunctionToolCall",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseFunctionWebSearch",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseOutputMessage",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "Response",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseComputerToolCall",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseFileSearchToolCall",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseFunctionToolCall",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseFunctionWebSearch",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseInputItemParam",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseOutputItem",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseOutputMessage",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseOutputRefusal",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseOutputText",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseStreamEvent",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseCompletedEvent",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "Response",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseCompletedEvent",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseOutputMessage",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseOutputText",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseOutputMessage",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseOutputText",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "Response",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseFunctionToolCall",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseOutputMessage",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseOutputRefusal",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseOutputText",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseFunctionToolCall",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseFunctionToolCallParam",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseInputTextParam",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseOutputMessage",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseOutputRefusal",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseOutputText",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "Response",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseFunctionToolCall",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseOutputMessage",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseOutputRefusal",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseOutputText",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseFunctionToolCall",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseOutputItem",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseOutputMessage",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseOutputText",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseCompletedEvent",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseComputerToolCall",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseFileSearchToolCall",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "ResponseFunctionWebSearch",
        "importPath": "openai.types.responses",
        "description": "openai.types.responses",
        "isExtraImport": true,
        "detail": "openai.types.responses",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "RECOMMENDED_PROMPT_PREFIX",
        "importPath": "agents.extensions.handoff_prompt",
        "description": "agents.extensions.handoff_prompt",
        "isExtraImport": true,
        "detail": "agents.extensions.handoff_prompt",
        "documentation": {}
    },
    {
        "label": "handoff_filters",
        "importPath": "agents.extensions",
        "description": "agents.extensions",
        "isExtraImport": true,
        "detail": "agents.extensions",
        "documentation": {}
    },
    {
        "label": "handoff_filters",
        "importPath": "agents.extensions",
        "description": "agents.extensions",
        "isExtraImport": true,
        "detail": "agents.extensions",
        "documentation": {}
    },
    {
        "label": "openai",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "openai",
        "description": "openai",
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "AsyncOpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "AsyncOpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "AsyncOpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "AsyncOpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "NOT_GIVEN",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "AsyncOpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "AsyncStream",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "NotGiven",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "AsyncOpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "DefaultAsyncHttpxClient",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "NOT_GIVEN",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "APIStatusError",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "AsyncOpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "AsyncStream",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "NotGiven",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "AsyncOpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "NOT_GIVEN",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "NOT_GIVEN",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "NOT_GIVEN",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "AsyncOpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "ModelSettings",
        "importPath": "agents.model_settings",
        "description": "agents.model_settings",
        "isExtraImport": true,
        "detail": "agents.model_settings",
        "documentation": {}
    },
    {
        "label": "ModelSettings",
        "importPath": "agents.model_settings",
        "description": "agents.model_settings",
        "isExtraImport": true,
        "detail": "agents.model_settings",
        "documentation": {}
    },
    {
        "label": "ModelSettings",
        "importPath": "agents.model_settings",
        "description": "agents.model_settings",
        "isExtraImport": true,
        "detail": "agents.model_settings",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Group",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Live",
        "importPath": "rich.live",
        "description": "rich.live",
        "isExtraImport": true,
        "detail": "rich.live",
        "documentation": {}
    },
    {
        "label": "Spinner",
        "importPath": "rich.spinner",
        "description": "rich.spinner",
        "isExtraImport": true,
        "detail": "rich.spinner",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "Browser",
        "importPath": "playwright.async_api",
        "description": "playwright.async_api",
        "isExtraImport": true,
        "detail": "playwright.async_api",
        "documentation": {}
    },
    {
        "label": "Page",
        "importPath": "playwright.async_api",
        "description": "playwright.async_api",
        "isExtraImport": true,
        "detail": "playwright.async_api",
        "documentation": {}
    },
    {
        "label": "Playwright",
        "importPath": "playwright.async_api",
        "description": "playwright.async_api",
        "isExtraImport": true,
        "detail": "playwright.async_api",
        "documentation": {}
    },
    {
        "label": "async_playwright",
        "importPath": "playwright.async_api",
        "description": "playwright.async_api",
        "isExtraImport": true,
        "detail": "playwright.async_api",
        "documentation": {}
    },
    {
        "label": "abc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "abc",
        "description": "abc",
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "enum",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "enum",
        "description": "enum",
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "AsyncIterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "AsyncIterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "AsyncIterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Awaitable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Awaitable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Awaitable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Awaitable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Awaitable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "AsyncIterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Awaitable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "AsyncIterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "AsyncIterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "AsyncIterator",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "ChatModel",
        "importPath": "openai.types",
        "description": "openai.types",
        "isExtraImport": true,
        "detail": "openai.types",
        "documentation": {}
    },
    {
        "label": "ChatModel",
        "importPath": "openai.types",
        "description": "openai.types",
        "isExtraImport": true,
        "detail": "openai.types",
        "documentation": {}
    },
    {
        "label": "ChatCompletion",
        "importPath": "openai.types.chat",
        "description": "openai.types.chat",
        "isExtraImport": true,
        "detail": "openai.types.chat",
        "documentation": {}
    },
    {
        "label": "ChatCompletionAssistantMessageParam",
        "importPath": "openai.types.chat",
        "description": "openai.types.chat",
        "isExtraImport": true,
        "detail": "openai.types.chat",
        "documentation": {}
    },
    {
        "label": "ChatCompletionChunk",
        "importPath": "openai.types.chat",
        "description": "openai.types.chat",
        "isExtraImport": true,
        "detail": "openai.types.chat",
        "documentation": {}
    },
    {
        "label": "ChatCompletionContentPartImageParam",
        "importPath": "openai.types.chat",
        "description": "openai.types.chat",
        "isExtraImport": true,
        "detail": "openai.types.chat",
        "documentation": {}
    },
    {
        "label": "ChatCompletionContentPartParam",
        "importPath": "openai.types.chat",
        "description": "openai.types.chat",
        "isExtraImport": true,
        "detail": "openai.types.chat",
        "documentation": {}
    },
    {
        "label": "ChatCompletionContentPartTextParam",
        "importPath": "openai.types.chat",
        "description": "openai.types.chat",
        "isExtraImport": true,
        "detail": "openai.types.chat",
        "documentation": {}
    },
    {
        "label": "ChatCompletionDeveloperMessageParam",
        "importPath": "openai.types.chat",
        "description": "openai.types.chat",
        "isExtraImport": true,
        "detail": "openai.types.chat",
        "documentation": {}
    },
    {
        "label": "ChatCompletionMessage",
        "importPath": "openai.types.chat",
        "description": "openai.types.chat",
        "isExtraImport": true,
        "detail": "openai.types.chat",
        "documentation": {}
    },
    {
        "label": "ChatCompletionMessageParam",
        "importPath": "openai.types.chat",
        "description": "openai.types.chat",
        "isExtraImport": true,
        "detail": "openai.types.chat",
        "documentation": {}
    },
    {
        "label": "ChatCompletionMessageToolCallParam",
        "importPath": "openai.types.chat",
        "description": "openai.types.chat",
        "isExtraImport": true,
        "detail": "openai.types.chat",
        "documentation": {}
    },
    {
        "label": "ChatCompletionSystemMessageParam",
        "importPath": "openai.types.chat",
        "description": "openai.types.chat",
        "isExtraImport": true,
        "detail": "openai.types.chat",
        "documentation": {}
    },
    {
        "label": "ChatCompletionToolChoiceOptionParam",
        "importPath": "openai.types.chat",
        "description": "openai.types.chat",
        "isExtraImport": true,
        "detail": "openai.types.chat",
        "documentation": {}
    },
    {
        "label": "ChatCompletionToolMessageParam",
        "importPath": "openai.types.chat",
        "description": "openai.types.chat",
        "isExtraImport": true,
        "detail": "openai.types.chat",
        "documentation": {}
    },
    {
        "label": "ChatCompletionUserMessageParam",
        "importPath": "openai.types.chat",
        "description": "openai.types.chat",
        "isExtraImport": true,
        "detail": "openai.types.chat",
        "documentation": {}
    },
    {
        "label": "ChatCompletionMessage",
        "importPath": "openai.types.chat",
        "description": "openai.types.chat",
        "isExtraImport": true,
        "detail": "openai.types.chat",
        "documentation": {}
    },
    {
        "label": "ChatCompletionMessageToolCall",
        "importPath": "openai.types.chat",
        "description": "openai.types.chat",
        "isExtraImport": true,
        "detail": "openai.types.chat",
        "documentation": {}
    },
    {
        "label": "ChatCompletionToolParam",
        "importPath": "openai.types.chat.chat_completion_tool_param",
        "description": "openai.types.chat.chat_completion_tool_param",
        "isExtraImport": true,
        "detail": "openai.types.chat.chat_completion_tool_param",
        "documentation": {}
    },
    {
        "label": "ResponseFormat",
        "importPath": "openai.types.chat.completion_create_params",
        "description": "openai.types.chat.completion_create_params",
        "isExtraImport": true,
        "detail": "openai.types.chat.completion_create_params",
        "documentation": {}
    },
    {
        "label": "CompletionUsage",
        "importPath": "openai.types.completion_usage",
        "description": "openai.types.completion_usage",
        "isExtraImport": true,
        "detail": "openai.types.completion_usage",
        "documentation": {}
    },
    {
        "label": "CompletionUsage",
        "importPath": "openai.types.completion_usage",
        "description": "openai.types.completion_usage",
        "isExtraImport": true,
        "detail": "openai.types.completion_usage",
        "documentation": {}
    },
    {
        "label": "CompletionUsage",
        "importPath": "openai.types.completion_usage",
        "description": "openai.types.completion_usage",
        "isExtraImport": true,
        "detail": "openai.types.completion_usage",
        "documentation": {}
    },
    {
        "label": "FunctionCallOutput",
        "importPath": "openai.types.responses.response_input_param",
        "description": "openai.types.responses.response_input_param",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_input_param",
        "documentation": {}
    },
    {
        "label": "ItemReference",
        "importPath": "openai.types.responses.response_input_param",
        "description": "openai.types.responses.response_input_param",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_input_param",
        "documentation": {}
    },
    {
        "label": "Message",
        "importPath": "openai.types.responses.response_input_param",
        "description": "openai.types.responses.response_input_param",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_input_param",
        "documentation": {}
    },
    {
        "label": "ComputerCallOutput",
        "importPath": "openai.types.responses.response_input_param",
        "description": "openai.types.responses.response_input_param",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_input_param",
        "documentation": {}
    },
    {
        "label": "InputTokensDetails",
        "importPath": "openai.types.responses.response_usage",
        "description": "openai.types.responses.response_usage",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_usage",
        "documentation": {}
    },
    {
        "label": "OutputTokensDetails",
        "importPath": "openai.types.responses.response_usage",
        "description": "openai.types.responses.response_usage",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_usage",
        "documentation": {}
    },
    {
        "label": "httpx",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "httpx",
        "description": "httpx",
        "detail": "httpx",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "queue",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "queue",
        "description": "queue",
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "contextvars",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "contextvars",
        "description": "contextvars",
        "detail": "contextvars",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypeAlias",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "get_args",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "get_origin",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypeAlias",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypeAlias",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypeAlias",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypeGuard",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "Concatenate",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "ParamSpec",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing_extensions",
        "description": "typing_extensions",
        "isExtraImport": true,
        "detail": "typing_extensions",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "ActionClick",
        "importPath": "openai.types.responses.response_computer_tool_call",
        "description": "openai.types.responses.response_computer_tool_call",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_computer_tool_call",
        "documentation": {}
    },
    {
        "label": "ActionDoubleClick",
        "importPath": "openai.types.responses.response_computer_tool_call",
        "description": "openai.types.responses.response_computer_tool_call",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_computer_tool_call",
        "documentation": {}
    },
    {
        "label": "ActionDrag",
        "importPath": "openai.types.responses.response_computer_tool_call",
        "description": "openai.types.responses.response_computer_tool_call",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_computer_tool_call",
        "documentation": {}
    },
    {
        "label": "ActionKeypress",
        "importPath": "openai.types.responses.response_computer_tool_call",
        "description": "openai.types.responses.response_computer_tool_call",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_computer_tool_call",
        "documentation": {}
    },
    {
        "label": "ActionMove",
        "importPath": "openai.types.responses.response_computer_tool_call",
        "description": "openai.types.responses.response_computer_tool_call",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_computer_tool_call",
        "documentation": {}
    },
    {
        "label": "ActionScreenshot",
        "importPath": "openai.types.responses.response_computer_tool_call",
        "description": "openai.types.responses.response_computer_tool_call",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_computer_tool_call",
        "documentation": {}
    },
    {
        "label": "ActionScroll",
        "importPath": "openai.types.responses.response_computer_tool_call",
        "description": "openai.types.responses.response_computer_tool_call",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_computer_tool_call",
        "documentation": {}
    },
    {
        "label": "ActionType",
        "importPath": "openai.types.responses.response_computer_tool_call",
        "description": "openai.types.responses.response_computer_tool_call",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_computer_tool_call",
        "documentation": {}
    },
    {
        "label": "ActionWait",
        "importPath": "openai.types.responses.response_computer_tool_call",
        "description": "openai.types.responses.response_computer_tool_call",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_computer_tool_call",
        "documentation": {}
    },
    {
        "label": "ActionClick",
        "importPath": "openai.types.responses.response_computer_tool_call",
        "description": "openai.types.responses.response_computer_tool_call",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_computer_tool_call",
        "documentation": {}
    },
    {
        "label": "ActionDoubleClick",
        "importPath": "openai.types.responses.response_computer_tool_call",
        "description": "openai.types.responses.response_computer_tool_call",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_computer_tool_call",
        "documentation": {}
    },
    {
        "label": "ActionDrag",
        "importPath": "openai.types.responses.response_computer_tool_call",
        "description": "openai.types.responses.response_computer_tool_call",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_computer_tool_call",
        "documentation": {}
    },
    {
        "label": "ActionDragPath",
        "importPath": "openai.types.responses.response_computer_tool_call",
        "description": "openai.types.responses.response_computer_tool_call",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_computer_tool_call",
        "documentation": {}
    },
    {
        "label": "ActionKeypress",
        "importPath": "openai.types.responses.response_computer_tool_call",
        "description": "openai.types.responses.response_computer_tool_call",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_computer_tool_call",
        "documentation": {}
    },
    {
        "label": "ActionMove",
        "importPath": "openai.types.responses.response_computer_tool_call",
        "description": "openai.types.responses.response_computer_tool_call",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_computer_tool_call",
        "documentation": {}
    },
    {
        "label": "ActionScreenshot",
        "importPath": "openai.types.responses.response_computer_tool_call",
        "description": "openai.types.responses.response_computer_tool_call",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_computer_tool_call",
        "documentation": {}
    },
    {
        "label": "ActionScroll",
        "importPath": "openai.types.responses.response_computer_tool_call",
        "description": "openai.types.responses.response_computer_tool_call",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_computer_tool_call",
        "documentation": {}
    },
    {
        "label": "ActionType",
        "importPath": "openai.types.responses.response_computer_tool_call",
        "description": "openai.types.responses.response_computer_tool_call",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_computer_tool_call",
        "documentation": {}
    },
    {
        "label": "ActionWait",
        "importPath": "openai.types.responses.response_computer_tool_call",
        "description": "openai.types.responses.response_computer_tool_call",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_computer_tool_call",
        "documentation": {}
    },
    {
        "label": "ResponseComputerToolCall",
        "importPath": "openai.types.responses.response_computer_tool_call",
        "description": "openai.types.responses.response_computer_tool_call",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_computer_tool_call",
        "documentation": {}
    },
    {
        "label": "ActionScreenshot",
        "importPath": "openai.types.responses.response_computer_tool_call",
        "description": "openai.types.responses.response_computer_tool_call",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_computer_tool_call",
        "documentation": {}
    },
    {
        "label": "ResponseComputerToolCall",
        "importPath": "openai.types.responses.response_computer_tool_call",
        "description": "openai.types.responses.response_computer_tool_call",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_computer_tool_call",
        "documentation": {}
    },
    {
        "label": "ActionClick",
        "importPath": "openai.types.responses.response_computer_tool_call",
        "description": "openai.types.responses.response_computer_tool_call",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_computer_tool_call",
        "documentation": {}
    },
    {
        "label": "ResponseReasoningItem",
        "importPath": "openai.types.responses.response_reasoning_item",
        "description": "openai.types.responses.response_reasoning_item",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_reasoning_item",
        "documentation": {}
    },
    {
        "label": "ResponseReasoningItem",
        "importPath": "openai.types.responses.response_reasoning_item",
        "description": "openai.types.responses.response_reasoning_item",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_reasoning_item",
        "documentation": {}
    },
    {
        "label": "ResponseReasoningItem",
        "importPath": "openai.types.responses.response_reasoning_item",
        "description": "openai.types.responses.response_reasoning_item",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_reasoning_item",
        "documentation": {}
    },
    {
        "label": "Summary",
        "importPath": "openai.types.responses.response_reasoning_item",
        "description": "openai.types.responses.response_reasoning_item",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_reasoning_item",
        "documentation": {}
    },
    {
        "label": "ResponseReasoningItem",
        "importPath": "openai.types.responses.response_reasoning_item",
        "description": "openai.types.responses.response_reasoning_item",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_reasoning_item",
        "documentation": {}
    },
    {
        "label": "Summary",
        "importPath": "openai.types.responses.response_reasoning_item",
        "description": "openai.types.responses.response_reasoning_item",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_reasoning_item",
        "documentation": {}
    },
    {
        "label": "contextlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "contextlib",
        "description": "contextlib",
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "Docstring",
        "importPath": "griffe",
        "description": "griffe",
        "isExtraImport": true,
        "detail": "griffe",
        "documentation": {}
    },
    {
        "label": "DocstringSectionKind",
        "importPath": "griffe",
        "description": "griffe",
        "isExtraImport": true,
        "detail": "griffe",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "ComputerCallOutput",
        "importPath": "openai.types.responses.response_input_item_param",
        "description": "openai.types.responses.response_input_item_param",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_input_item_param",
        "documentation": {}
    },
    {
        "label": "FunctionCallOutput",
        "importPath": "openai.types.responses.response_input_item_param",
        "description": "openai.types.responses.response_input_item_param",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_input_item_param",
        "documentation": {}
    },
    {
        "label": "FunctionCallOutput",
        "importPath": "openai.types.responses.response_input_item_param",
        "description": "openai.types.responses.response_input_item_param",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_input_item_param",
        "documentation": {}
    },
    {
        "label": "FunctionCallOutput",
        "importPath": "openai.types.responses.response_input_item_param",
        "description": "openai.types.responses.response_input_item_param",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_input_item_param",
        "documentation": {}
    },
    {
        "label": "Filters",
        "importPath": "openai.types.responses.file_search_tool_param",
        "description": "openai.types.responses.file_search_tool_param",
        "isExtraImport": true,
        "detail": "openai.types.responses.file_search_tool_param",
        "documentation": {}
    },
    {
        "label": "RankingOptions",
        "importPath": "openai.types.responses.file_search_tool_param",
        "description": "openai.types.responses.file_search_tool_param",
        "isExtraImport": true,
        "detail": "openai.types.responses.file_search_tool_param",
        "documentation": {}
    },
    {
        "label": "UserLocation",
        "importPath": "openai.types.responses.web_search_tool_param",
        "description": "openai.types.responses.web_search_tool_param",
        "isExtraImport": true,
        "detail": "openai.types.responses.web_search_tool_param",
        "documentation": {}
    },
    {
        "label": "importlib.metadata",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib.metadata",
        "description": "importlib.metadata",
        "detail": "importlib.metadata",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "_openai_shared",
        "importPath": "agents.models",
        "description": "agents.models",
        "isExtraImport": true,
        "detail": "agents.models",
        "documentation": {}
    },
    {
        "label": "OpenAIChatCompletionsModel",
        "importPath": "agents.models.openai_chatcompletions",
        "description": "agents.models.openai_chatcompletions",
        "isExtraImport": true,
        "detail": "agents.models.openai_chatcompletions",
        "documentation": {}
    },
    {
        "label": "OpenAIChatCompletionsModel",
        "importPath": "agents.models.openai_chatcompletions",
        "description": "agents.models.openai_chatcompletions",
        "isExtraImport": true,
        "detail": "agents.models.openai_chatcompletions",
        "documentation": {}
    },
    {
        "label": "_Converter",
        "importPath": "agents.models.openai_chatcompletions",
        "description": "agents.models.openai_chatcompletions",
        "isExtraImport": true,
        "detail": "agents.models.openai_chatcompletions",
        "documentation": {}
    },
    {
        "label": "OpenAIChatCompletionsModel",
        "importPath": "agents.models.openai_chatcompletions",
        "description": "agents.models.openai_chatcompletions",
        "isExtraImport": true,
        "detail": "agents.models.openai_chatcompletions",
        "documentation": {}
    },
    {
        "label": "ToolConverter",
        "importPath": "agents.models.openai_chatcompletions",
        "description": "agents.models.openai_chatcompletions",
        "isExtraImport": true,
        "detail": "agents.models.openai_chatcompletions",
        "documentation": {}
    },
    {
        "label": "OpenAIResponsesModel",
        "importPath": "agents.models.openai_responses",
        "description": "agents.models.openai_responses",
        "isExtraImport": true,
        "detail": "agents.models.openai_responses",
        "documentation": {}
    },
    {
        "label": "OpenAIResponsesModel",
        "importPath": "agents.models.openai_responses",
        "description": "agents.models.openai_responses",
        "isExtraImport": true,
        "detail": "agents.models.openai_responses",
        "documentation": {}
    },
    {
        "label": "Converter",
        "importPath": "agents.models.openai_responses",
        "description": "agents.models.openai_responses",
        "isExtraImport": true,
        "detail": "agents.models.openai_responses",
        "documentation": {}
    },
    {
        "label": "set_trace_processors",
        "importPath": "agents.tracing",
        "description": "agents.tracing",
        "isExtraImport": true,
        "detail": "agents.tracing",
        "documentation": {}
    },
    {
        "label": "SpanError",
        "importPath": "agents.tracing",
        "description": "agents.tracing",
        "isExtraImport": true,
        "detail": "agents.tracing",
        "documentation": {}
    },
    {
        "label": "generation_span",
        "importPath": "agents.tracing",
        "description": "agents.tracing",
        "isExtraImport": true,
        "detail": "agents.tracing",
        "documentation": {}
    },
    {
        "label": "Span",
        "importPath": "agents.tracing",
        "description": "agents.tracing",
        "isExtraImport": true,
        "detail": "agents.tracing",
        "documentation": {}
    },
    {
        "label": "Trace",
        "importPath": "agents.tracing",
        "description": "agents.tracing",
        "isExtraImport": true,
        "detail": "agents.tracing",
        "documentation": {}
    },
    {
        "label": "agent_span",
        "importPath": "agents.tracing",
        "description": "agents.tracing",
        "isExtraImport": true,
        "detail": "agents.tracing",
        "documentation": {}
    },
    {
        "label": "custom_span",
        "importPath": "agents.tracing",
        "description": "agents.tracing",
        "isExtraImport": true,
        "detail": "agents.tracing",
        "documentation": {}
    },
    {
        "label": "function_span",
        "importPath": "agents.tracing",
        "description": "agents.tracing",
        "isExtraImport": true,
        "detail": "agents.tracing",
        "documentation": {}
    },
    {
        "label": "generation_span",
        "importPath": "agents.tracing",
        "description": "agents.tracing",
        "isExtraImport": true,
        "detail": "agents.tracing",
        "documentation": {}
    },
    {
        "label": "handoff_span",
        "importPath": "agents.tracing",
        "description": "agents.tracing",
        "isExtraImport": true,
        "detail": "agents.tracing",
        "documentation": {}
    },
    {
        "label": "trace",
        "importPath": "agents.tracing",
        "description": "agents.tracing",
        "isExtraImport": true,
        "detail": "agents.tracing",
        "documentation": {}
    },
    {
        "label": "AgentSpanData",
        "importPath": "agents.tracing",
        "description": "agents.tracing",
        "isExtraImport": true,
        "detail": "agents.tracing",
        "documentation": {}
    },
    {
        "label": "FunctionSpanData",
        "importPath": "agents.tracing",
        "description": "agents.tracing",
        "isExtraImport": true,
        "detail": "agents.tracing",
        "documentation": {}
    },
    {
        "label": "GenerationSpanData",
        "importPath": "agents.tracing",
        "description": "agents.tracing",
        "isExtraImport": true,
        "detail": "agents.tracing",
        "documentation": {}
    },
    {
        "label": "Span",
        "importPath": "agents.tracing",
        "description": "agents.tracing",
        "isExtraImport": true,
        "detail": "agents.tracing",
        "documentation": {}
    },
    {
        "label": "Trace",
        "importPath": "agents.tracing",
        "description": "agents.tracing",
        "isExtraImport": true,
        "detail": "agents.tracing",
        "documentation": {}
    },
    {
        "label": "TracingProcessor",
        "importPath": "agents.tracing",
        "description": "agents.tracing",
        "isExtraImport": true,
        "detail": "agents.tracing",
        "documentation": {}
    },
    {
        "label": "GLOBAL_TRACE_PROVIDER",
        "importPath": "agents.tracing.setup",
        "description": "agents.tracing.setup",
        "isExtraImport": true,
        "detail": "agents.tracing.setup",
        "documentation": {}
    },
    {
        "label": "AgentOutputSchema",
        "importPath": "agents.agent_output",
        "description": "agents.agent_output",
        "isExtraImport": true,
        "detail": "agents.agent_output",
        "documentation": {}
    },
    {
        "label": "AgentOutputSchema",
        "importPath": "agents.agent_output",
        "description": "agents.agent_output",
        "isExtraImport": true,
        "detail": "agents.agent_output",
        "documentation": {}
    },
    {
        "label": "_WRAPPER_DICT_KEY",
        "importPath": "agents.agent_output",
        "description": "agents.agent_output",
        "isExtraImport": true,
        "detail": "agents.agent_output",
        "documentation": {}
    },
    {
        "label": "_WRAPPER_DICT_KEY",
        "importPath": "agents.agent_output",
        "description": "agents.agent_output",
        "isExtraImport": true,
        "detail": "agents.agent_output",
        "documentation": {}
    },
    {
        "label": "Handoff",
        "importPath": "agents.handoffs",
        "description": "agents.handoffs",
        "isExtraImport": true,
        "detail": "agents.handoffs",
        "documentation": {}
    },
    {
        "label": "ModelResponse",
        "importPath": "agents.items",
        "description": "agents.items",
        "isExtraImport": true,
        "detail": "agents.items",
        "documentation": {}
    },
    {
        "label": "TResponseInputItem",
        "importPath": "agents.items",
        "description": "agents.items",
        "isExtraImport": true,
        "detail": "agents.items",
        "documentation": {}
    },
    {
        "label": "TResponseOutputItem",
        "importPath": "agents.items",
        "description": "agents.items",
        "isExtraImport": true,
        "detail": "agents.items",
        "documentation": {}
    },
    {
        "label": "TResponseStreamEvent",
        "importPath": "agents.items",
        "description": "agents.items",
        "isExtraImport": true,
        "detail": "agents.items",
        "documentation": {}
    },
    {
        "label": "RunItem",
        "importPath": "agents.items",
        "description": "agents.items",
        "isExtraImport": true,
        "detail": "agents.items",
        "documentation": {}
    },
    {
        "label": "ToolCallOutputItem",
        "importPath": "agents.items",
        "description": "agents.items",
        "isExtraImport": true,
        "detail": "agents.items",
        "documentation": {}
    },
    {
        "label": "HandoffOutputItem",
        "importPath": "agents.items",
        "description": "agents.items",
        "isExtraImport": true,
        "detail": "agents.items",
        "documentation": {}
    },
    {
        "label": "MessageOutputItem",
        "importPath": "agents.items",
        "description": "agents.items",
        "isExtraImport": true,
        "detail": "agents.items",
        "documentation": {}
    },
    {
        "label": "ToolCallOutputItem",
        "importPath": "agents.items",
        "description": "agents.items",
        "isExtraImport": true,
        "detail": "agents.items",
        "documentation": {}
    },
    {
        "label": "TResponseInputItem",
        "importPath": "agents.items",
        "description": "agents.items",
        "isExtraImport": true,
        "detail": "agents.items",
        "documentation": {}
    },
    {
        "label": "TResponseInputItem",
        "importPath": "agents.items",
        "description": "agents.items",
        "isExtraImport": true,
        "detail": "agents.items",
        "documentation": {}
    },
    {
        "label": "Model",
        "importPath": "agents.models.interface",
        "description": "agents.models.interface",
        "isExtraImport": true,
        "detail": "agents.models.interface",
        "documentation": {}
    },
    {
        "label": "ModelTracing",
        "importPath": "agents.models.interface",
        "description": "agents.models.interface",
        "isExtraImport": true,
        "detail": "agents.models.interface",
        "documentation": {}
    },
    {
        "label": "ModelTracing",
        "importPath": "agents.models.interface",
        "description": "agents.models.interface",
        "isExtraImport": true,
        "detail": "agents.models.interface",
        "documentation": {}
    },
    {
        "label": "Model",
        "importPath": "agents.models.interface",
        "description": "agents.models.interface",
        "isExtraImport": true,
        "detail": "agents.models.interface",
        "documentation": {}
    },
    {
        "label": "ModelProvider",
        "importPath": "agents.models.interface",
        "description": "agents.models.interface",
        "isExtraImport": true,
        "detail": "agents.models.interface",
        "documentation": {}
    },
    {
        "label": "Tool",
        "importPath": "agents.tool",
        "description": "agents.tool",
        "isExtraImport": true,
        "detail": "agents.tool",
        "documentation": {}
    },
    {
        "label": "Tool",
        "importPath": "agents.tool",
        "description": "agents.tool",
        "isExtraImport": true,
        "detail": "agents.tool",
        "documentation": {}
    },
    {
        "label": "FunctionToolResult",
        "importPath": "agents.tool",
        "description": "agents.tool",
        "isExtraImport": true,
        "detail": "agents.tool",
        "documentation": {}
    },
    {
        "label": "function_tool",
        "importPath": "agents.tool",
        "description": "agents.tool",
        "isExtraImport": true,
        "detail": "agents.tool",
        "documentation": {}
    },
    {
        "label": "default_tool_error_function",
        "importPath": "agents.tool",
        "description": "agents.tool",
        "isExtraImport": true,
        "detail": "agents.tool",
        "documentation": {}
    },
    {
        "label": "FileSearchTool",
        "importPath": "agents.tool",
        "description": "agents.tool",
        "isExtraImport": true,
        "detail": "agents.tool",
        "documentation": {}
    },
    {
        "label": "WebSearchTool",
        "importPath": "agents.tool",
        "description": "agents.tool",
        "isExtraImport": true,
        "detail": "agents.tool",
        "documentation": {}
    },
    {
        "label": "Usage",
        "importPath": "agents.usage",
        "description": "agents.usage",
        "isExtraImport": true,
        "detail": "agents.usage",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Agent",
        "importPath": "agents.agent",
        "description": "agents.agent",
        "isExtraImport": true,
        "detail": "agents.agent",
        "documentation": {}
    },
    {
        "label": "ToolsToFinalOutputResult",
        "importPath": "agents.agent",
        "description": "agents.agent",
        "isExtraImport": true,
        "detail": "agents.agent",
        "documentation": {}
    },
    {
        "label": "AgentHooks",
        "importPath": "agents.lifecycle",
        "description": "agents.lifecycle",
        "isExtraImport": true,
        "detail": "agents.lifecycle",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "agents.run",
        "description": "agents.run",
        "isExtraImport": true,
        "detail": "agents.run",
        "documentation": {}
    },
    {
        "label": "RunConfig",
        "importPath": "agents.run",
        "description": "agents.run",
        "isExtraImport": true,
        "detail": "agents.run",
        "documentation": {}
    },
    {
        "label": "RunContextWrapper",
        "importPath": "agents.run_context",
        "description": "agents.run_context",
        "isExtraImport": true,
        "detail": "agents.run_context",
        "documentation": {}
    },
    {
        "label": "TContext",
        "importPath": "agents.run_context",
        "description": "agents.run_context",
        "isExtraImport": true,
        "detail": "agents.run_context",
        "documentation": {}
    },
    {
        "label": "RunContextWrapper",
        "importPath": "agents.run_context",
        "description": "agents.run_context",
        "isExtraImport": true,
        "detail": "agents.run_context",
        "documentation": {}
    },
    {
        "label": "ToolCallItem",
        "importPath": "src.agents.items",
        "description": "src.agents.items",
        "isExtraImport": true,
        "detail": "src.agents.items",
        "documentation": {}
    },
    {
        "label": "ToolCallItem",
        "importPath": "src.agents.items",
        "description": "src.agents.items",
        "isExtraImport": true,
        "detail": "src.agents.items",
        "documentation": {}
    },
    {
        "label": "AgentUpdatedStreamEvent",
        "importPath": "agents.stream_events",
        "description": "agents.stream_events",
        "isExtraImport": true,
        "detail": "agents.stream_events",
        "documentation": {}
    },
    {
        "label": "snapshot",
        "importPath": "inline_snapshot",
        "description": "inline_snapshot",
        "isExtraImport": true,
        "detail": "inline_snapshot",
        "documentation": {}
    },
    {
        "label": "snapshot",
        "importPath": "inline_snapshot",
        "description": "inline_snapshot",
        "isExtraImport": true,
        "detail": "inline_snapshot",
        "documentation": {}
    },
    {
        "label": "snapshot",
        "importPath": "inline_snapshot",
        "description": "inline_snapshot",
        "isExtraImport": true,
        "detail": "inline_snapshot",
        "documentation": {}
    },
    {
        "label": "snapshot",
        "importPath": "inline_snapshot",
        "description": "inline_snapshot",
        "isExtraImport": true,
        "detail": "inline_snapshot",
        "documentation": {}
    },
    {
        "label": "snapshot",
        "importPath": "inline_snapshot",
        "description": "inline_snapshot",
        "isExtraImport": true,
        "detail": "inline_snapshot",
        "documentation": {}
    },
    {
        "label": "ComputerAction",
        "importPath": "agents._run_impl",
        "description": "agents._run_impl",
        "isExtraImport": true,
        "detail": "agents._run_impl",
        "documentation": {}
    },
    {
        "label": "ToolRunComputerAction",
        "importPath": "agents._run_impl",
        "description": "agents._run_impl",
        "isExtraImport": true,
        "detail": "agents._run_impl",
        "documentation": {}
    },
    {
        "label": "NextStepFinalOutput",
        "importPath": "agents._run_impl",
        "description": "agents._run_impl",
        "isExtraImport": true,
        "detail": "agents._run_impl",
        "documentation": {}
    },
    {
        "label": "NextStepHandoff",
        "importPath": "agents._run_impl",
        "description": "agents._run_impl",
        "isExtraImport": true,
        "detail": "agents._run_impl",
        "documentation": {}
    },
    {
        "label": "NextStepRunAgain",
        "importPath": "agents._run_impl",
        "description": "agents._run_impl",
        "isExtraImport": true,
        "detail": "agents._run_impl",
        "documentation": {}
    },
    {
        "label": "RunImpl",
        "importPath": "agents._run_impl",
        "description": "agents._run_impl",
        "isExtraImport": true,
        "detail": "agents._run_impl",
        "documentation": {}
    },
    {
        "label": "SingleStepResult",
        "importPath": "agents._run_impl",
        "description": "agents._run_impl",
        "isExtraImport": true,
        "detail": "agents._run_impl",
        "documentation": {}
    },
    {
        "label": "RunImpl",
        "importPath": "agents._run_impl",
        "description": "agents._run_impl",
        "isExtraImport": true,
        "detail": "agents._run_impl",
        "documentation": {}
    },
    {
        "label": "RunImpl",
        "importPath": "agents._run_impl",
        "description": "agents._run_impl",
        "isExtraImport": true,
        "detail": "agents._run_impl",
        "documentation": {}
    },
    {
        "label": "OpenAIProvider",
        "importPath": "agents.models.openai_provider",
        "description": "agents.models.openai_provider",
        "isExtraImport": true,
        "detail": "agents.models.openai_provider",
        "documentation": {}
    },
    {
        "label": "OpenAIProvider",
        "importPath": "agents.models.openai_provider",
        "description": "agents.models.openai_provider",
        "isExtraImport": true,
        "detail": "agents.models.openai_provider",
        "documentation": {}
    },
    {
        "label": "generate_func_documentation",
        "importPath": "agents.function_schema",
        "description": "agents.function_schema",
        "isExtraImport": true,
        "detail": "agents.function_schema",
        "documentation": {}
    },
    {
        "label": "function_schema",
        "importPath": "agents.function_schema",
        "description": "agents.function_schema",
        "isExtraImport": true,
        "detail": "agents.function_schema",
        "documentation": {}
    },
    {
        "label": "remove_all_tools",
        "importPath": "agents.extensions.handoff_filters",
        "description": "agents.extensions.handoff_filters",
        "isExtraImport": true,
        "detail": "agents.extensions.handoff_filters",
        "documentation": {}
    },
    {
        "label": "UserError",
        "importPath": "agents.exceptions",
        "description": "agents.exceptions",
        "isExtraImport": true,
        "detail": "agents.exceptions",
        "documentation": {}
    },
    {
        "label": "UserError",
        "importPath": "agents.exceptions",
        "description": "agents.exceptions",
        "isExtraImport": true,
        "detail": "agents.exceptions",
        "documentation": {}
    },
    {
        "label": "UserError",
        "importPath": "agents.exceptions",
        "description": "agents.exceptions",
        "isExtraImport": true,
        "detail": "agents.exceptions",
        "documentation": {}
    },
    {
        "label": "UserError",
        "importPath": "agents.exceptions",
        "description": "agents.exceptions",
        "isExtraImport": true,
        "detail": "agents.exceptions",
        "documentation": {}
    },
    {
        "label": "input_guardrail",
        "importPath": "agents.guardrail",
        "description": "agents.guardrail",
        "isExtraImport": true,
        "detail": "agents.guardrail",
        "documentation": {}
    },
    {
        "label": "output_guardrail",
        "importPath": "agents.guardrail",
        "description": "agents.guardrail",
        "isExtraImport": true,
        "detail": "agents.guardrail",
        "documentation": {}
    },
    {
        "label": "ResponseComputerToolCallParam",
        "importPath": "openai.types.responses.response_computer_tool_call_param",
        "description": "openai.types.responses.response_computer_tool_call_param",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_computer_tool_call_param",
        "documentation": {}
    },
    {
        "label": "ResponseFileSearchToolCall",
        "importPath": "openai.types.responses.response_file_search_tool_call",
        "description": "openai.types.responses.response_file_search_tool_call",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_file_search_tool_call",
        "documentation": {}
    },
    {
        "label": "ResponseFileSearchToolCallParam",
        "importPath": "openai.types.responses.response_file_search_tool_call_param",
        "description": "openai.types.responses.response_file_search_tool_call_param",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_file_search_tool_call_param",
        "documentation": {}
    },
    {
        "label": "ResponseFunctionToolCall",
        "importPath": "openai.types.responses.response_function_tool_call",
        "description": "openai.types.responses.response_function_tool_call",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_function_tool_call",
        "documentation": {}
    },
    {
        "label": "ResponseFunctionToolCallParam",
        "importPath": "openai.types.responses.response_function_tool_call_param",
        "description": "openai.types.responses.response_function_tool_call_param",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_function_tool_call_param",
        "documentation": {}
    },
    {
        "label": "ResponseFunctionWebSearch",
        "importPath": "openai.types.responses.response_function_web_search",
        "description": "openai.types.responses.response_function_web_search",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_function_web_search",
        "documentation": {}
    },
    {
        "label": "ResponseFunctionWebSearchParam",
        "importPath": "openai.types.responses.response_function_web_search_param",
        "description": "openai.types.responses.response_function_web_search_param",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_function_web_search_param",
        "documentation": {}
    },
    {
        "label": "ResponseOutputMessage",
        "importPath": "openai.types.responses.response_output_message",
        "description": "openai.types.responses.response_output_message",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_output_message",
        "documentation": {}
    },
    {
        "label": "ResponseOutputMessageParam",
        "importPath": "openai.types.responses.response_output_message_param",
        "description": "openai.types.responses.response_output_message_param",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_output_message_param",
        "documentation": {}
    },
    {
        "label": "ResponseOutputRefusal",
        "importPath": "openai.types.responses.response_output_refusal",
        "description": "openai.types.responses.response_output_refusal",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_output_refusal",
        "documentation": {}
    },
    {
        "label": "ResponseOutputText",
        "importPath": "openai.types.responses.response_output_text",
        "description": "openai.types.responses.response_output_text",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_output_text",
        "documentation": {}
    },
    {
        "label": "ResponseReasoningItemParam",
        "importPath": "openai.types.responses.response_reasoning_item_param",
        "description": "openai.types.responses.response_reasoning_item_param",
        "isExtraImport": true,
        "detail": "openai.types.responses.response_reasoning_item_param",
        "documentation": {}
    },
    {
        "label": "ChatCompletion",
        "importPath": "openai.types.chat.chat_completion",
        "description": "openai.types.chat.chat_completion",
        "isExtraImport": true,
        "detail": "openai.types.chat.chat_completion",
        "documentation": {}
    },
    {
        "label": "Choice",
        "importPath": "openai.types.chat.chat_completion",
        "description": "openai.types.chat.chat_completion",
        "isExtraImport": true,
        "detail": "openai.types.chat.chat_completion",
        "documentation": {}
    },
    {
        "label": "ChatCompletionChunk",
        "importPath": "openai.types.chat.chat_completion_chunk",
        "description": "openai.types.chat.chat_completion_chunk",
        "isExtraImport": true,
        "detail": "openai.types.chat.chat_completion_chunk",
        "documentation": {}
    },
    {
        "label": "ChatCompletionChunk",
        "importPath": "openai.types.chat.chat_completion_chunk",
        "description": "openai.types.chat.chat_completion_chunk",
        "isExtraImport": true,
        "detail": "openai.types.chat.chat_completion_chunk",
        "documentation": {}
    },
    {
        "label": "Choice",
        "importPath": "openai.types.chat.chat_completion_chunk",
        "description": "openai.types.chat.chat_completion_chunk",
        "isExtraImport": true,
        "detail": "openai.types.chat.chat_completion_chunk",
        "documentation": {}
    },
    {
        "label": "ChoiceDelta",
        "importPath": "openai.types.chat.chat_completion_chunk",
        "description": "openai.types.chat.chat_completion_chunk",
        "isExtraImport": true,
        "detail": "openai.types.chat.chat_completion_chunk",
        "documentation": {}
    },
    {
        "label": "ChoiceDeltaToolCall",
        "importPath": "openai.types.chat.chat_completion_chunk",
        "description": "openai.types.chat.chat_completion_chunk",
        "isExtraImport": true,
        "detail": "openai.types.chat.chat_completion_chunk",
        "documentation": {}
    },
    {
        "label": "ChoiceDeltaToolCallFunction",
        "importPath": "openai.types.chat.chat_completion_chunk",
        "description": "openai.types.chat.chat_completion_chunk",
        "isExtraImport": true,
        "detail": "openai.types.chat.chat_completion_chunk",
        "documentation": {}
    },
    {
        "label": "ChatCompletionMessage",
        "importPath": "openai.types.chat.chat_completion_message",
        "description": "openai.types.chat.chat_completion_message",
        "isExtraImport": true,
        "detail": "openai.types.chat.chat_completion_message",
        "documentation": {}
    },
    {
        "label": "ChatCompletionMessageToolCall",
        "importPath": "openai.types.chat.chat_completion_message_tool_call",
        "description": "openai.types.chat.chat_completion_message_tool_call",
        "isExtraImport": true,
        "detail": "openai.types.chat.chat_completion_message_tool_call",
        "documentation": {}
    },
    {
        "label": "Function",
        "importPath": "openai.types.chat.chat_completion_message_tool_call",
        "description": "openai.types.chat.chat_completion_message_tool_call",
        "isExtraImport": true,
        "detail": "openai.types.chat.chat_completion_message_tool_call",
        "documentation": {}
    },
    {
        "label": "Function",
        "importPath": "openai.types.chat.chat_completion_message_tool_call",
        "description": "openai.types.chat.chat_completion_message_tool_call",
        "isExtraImport": true,
        "detail": "openai.types.chat.chat_completion_message_tool_call",
        "documentation": {}
    },
    {
        "label": "FAKE_RESPONSES_ID",
        "importPath": "agents.models.fake_id",
        "description": "agents.models.fake_id",
        "isExtraImport": true,
        "detail": "agents.models.fake_id",
        "documentation": {}
    },
    {
        "label": "FAKE_RESPONSES_ID",
        "importPath": "agents.models.fake_id",
        "description": "agents.models.fake_id",
        "isExtraImport": true,
        "detail": "agents.models.fake_id",
        "documentation": {}
    },
    {
        "label": "_json",
        "importPath": "agents.util",
        "description": "agents.util",
        "isExtraImport": true,
        "detail": "agents.util",
        "documentation": {}
    },
    {
        "label": "pretty_print_result",
        "importPath": "agents.util._pretty_print",
        "description": "agents.util._pretty_print",
        "isExtraImport": true,
        "detail": "agents.util._pretty_print",
        "documentation": {}
    },
    {
        "label": "pretty_print_run_result_streaming",
        "importPath": "agents.util._pretty_print",
        "description": "agents.util._pretty_print",
        "isExtraImport": true,
        "detail": "agents.util._pretty_print",
        "documentation": {}
    },
    {
        "label": "FakeModel",
        "importPath": "tests.fake_model",
        "description": "tests.fake_model",
        "isExtraImport": true,
        "detail": "tests.fake_model",
        "documentation": {}
    },
    {
        "label": "ResponseSpanData",
        "importPath": "agents.tracing.span_data",
        "description": "agents.tracing.span_data",
        "isExtraImport": true,
        "detail": "agents.tracing.span_data",
        "documentation": {}
    },
    {
        "label": "AgentSpanData",
        "importPath": "agents.tracing.span_data",
        "description": "agents.tracing.span_data",
        "isExtraImport": true,
        "detail": "agents.tracing.span_data",
        "documentation": {}
    },
    {
        "label": "fake_model",
        "importPath": "tests",
        "description": "tests",
        "isExtraImport": true,
        "detail": "tests",
        "documentation": {}
    },
    {
        "label": "ensure_strict_json_schema",
        "importPath": "agents.strict_schema",
        "description": "agents.strict_schema",
        "isExtraImport": true,
        "detail": "agents.strict_schema",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "TracingProcessor",
        "importPath": "agents.tracing.processor_interface",
        "description": "agents.tracing.processor_interface",
        "isExtraImport": true,
        "detail": "agents.tracing.processor_interface",
        "documentation": {}
    },
    {
        "label": "BackendSpanExporter",
        "importPath": "agents.tracing.processors",
        "description": "agents.tracing.processors",
        "isExtraImport": true,
        "detail": "agents.tracing.processors",
        "documentation": {}
    },
    {
        "label": "BatchTraceProcessor",
        "importPath": "agents.tracing.processors",
        "description": "agents.tracing.processors",
        "isExtraImport": true,
        "detail": "agents.tracing.processors",
        "documentation": {}
    },
    {
        "label": "SpanImpl",
        "importPath": "agents.tracing.spans",
        "description": "agents.tracing.spans",
        "isExtraImport": true,
        "detail": "agents.tracing.spans",
        "documentation": {}
    },
    {
        "label": "SpanError",
        "importPath": "agents.tracing.spans",
        "description": "agents.tracing.spans",
        "isExtraImport": true,
        "detail": "agents.tracing.spans",
        "documentation": {}
    },
    {
        "label": "TraceImpl",
        "importPath": "agents.tracing.traces",
        "description": "agents.tracing.traces",
        "isExtraImport": true,
        "detail": "agents.tracing.traces",
        "documentation": {}
    },
    {
        "label": "bin_dir",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "bin_dir = os.path.dirname(abs_file)\nbase = bin_dir[: -len(\"bin\") - 1]  # strip away the bin part from the __file__, plus the path separator\n# prepend bin to PATH (this file is inside the bin directory)\nos.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"openai-agents\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"../lib/python3.13/site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "base",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "base = bin_dir[: -len(\"bin\") - 1]  # strip away the bin part from the __file__, plus the path separator\n# prepend bin to PATH (this file is inside the bin directory)\nos.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"openai-agents\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"../lib/python3.13/site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"PATH\"]",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "os.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"openai-agents\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"../lib/python3.13/site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"VIRTUAL_ENV\"]",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "os.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"openai-agents\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"../lib/python3.13/site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"VIRTUAL_ENV_PROMPT\"]",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "os.environ[\"VIRTUAL_ENV_PROMPT\"] = \"openai-agents\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"../lib/python3.13/site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "prev_length",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "prev_length = len(sys.path)\nfor lib in \"../lib/python3.13/site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.path[:]",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "sys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.real_prefix",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "sys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.prefix",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "sys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "spanish_agent",
        "kind": 5,
        "importPath": "examples.agent_patterns.agents_as_tools",
        "description": "examples.agent_patterns.agents_as_tools",
        "peekOfCode": "spanish_agent = Agent(\n    name=\"spanish_agent\",\n    instructions=\"You translate the user's message to Spanish\",\n    handoff_description=\"An english to spanish translator\",\n)\nfrench_agent = Agent(\n    name=\"french_agent\",\n    instructions=\"You translate the user's message to French\",\n    handoff_description=\"An english to french translator\",\n)",
        "detail": "examples.agent_patterns.agents_as_tools",
        "documentation": {}
    },
    {
        "label": "french_agent",
        "kind": 5,
        "importPath": "examples.agent_patterns.agents_as_tools",
        "description": "examples.agent_patterns.agents_as_tools",
        "peekOfCode": "french_agent = Agent(\n    name=\"french_agent\",\n    instructions=\"You translate the user's message to French\",\n    handoff_description=\"An english to french translator\",\n)\nitalian_agent = Agent(\n    name=\"italian_agent\",\n    instructions=\"You translate the user's message to Italian\",\n    handoff_description=\"An english to italian translator\",\n)",
        "detail": "examples.agent_patterns.agents_as_tools",
        "documentation": {}
    },
    {
        "label": "italian_agent",
        "kind": 5,
        "importPath": "examples.agent_patterns.agents_as_tools",
        "description": "examples.agent_patterns.agents_as_tools",
        "peekOfCode": "italian_agent = Agent(\n    name=\"italian_agent\",\n    instructions=\"You translate the user's message to Italian\",\n    handoff_description=\"An english to italian translator\",\n)\norchestrator_agent = Agent(\n    name=\"orchestrator_agent\",\n    instructions=(\n        \"You are a translation agent. You use the tools given to you to translate.\"\n        \"If asked for multiple translations, you call the relevant tools in order.\"",
        "detail": "examples.agent_patterns.agents_as_tools",
        "documentation": {}
    },
    {
        "label": "orchestrator_agent",
        "kind": 5,
        "importPath": "examples.agent_patterns.agents_as_tools",
        "description": "examples.agent_patterns.agents_as_tools",
        "peekOfCode": "orchestrator_agent = Agent(\n    name=\"orchestrator_agent\",\n    instructions=(\n        \"You are a translation agent. You use the tools given to you to translate.\"\n        \"If asked for multiple translations, you call the relevant tools in order.\"\n        \"You never translate on your own, you always use the provided tools.\"\n    ),\n    tools=[\n        spanish_agent.as_tool(\n            tool_name=\"translate_to_spanish\",",
        "detail": "examples.agent_patterns.agents_as_tools",
        "documentation": {}
    },
    {
        "label": "synthesizer_agent",
        "kind": 5,
        "importPath": "examples.agent_patterns.agents_as_tools",
        "description": "examples.agent_patterns.agents_as_tools",
        "peekOfCode": "synthesizer_agent = Agent(\n    name=\"synthesizer_agent\",\n    instructions=\"You inspect translations, correct them if needed, and produce a final concatenated response.\",\n)\nasync def main():\n    msg = input(\"Hi! What would you like translated, and to which languages? \")\n    # Run the entire orchestration in a single trace\n    with trace(\"Orchestrator evaluator\"):\n        orchestrator_result = await Runner.run(orchestrator_agent, msg)\n        for item in orchestrator_result.new_items:",
        "detail": "examples.agent_patterns.agents_as_tools",
        "documentation": {}
    },
    {
        "label": "OutlineCheckerOutput",
        "kind": 6,
        "importPath": "examples.agent_patterns.deterministic",
        "description": "examples.agent_patterns.deterministic",
        "peekOfCode": "class OutlineCheckerOutput(BaseModel):\n    good_quality: bool\n    is_scifi: bool\noutline_checker_agent = Agent(\n    name=\"outline_checker_agent\",\n    instructions=\"Read the given story outline, and judge the quality. Also, determine if it is a scifi story.\",\n    output_type=OutlineCheckerOutput,\n)\nstory_agent = Agent(\n    name=\"story_agent\",",
        "detail": "examples.agent_patterns.deterministic",
        "documentation": {}
    },
    {
        "label": "story_outline_agent",
        "kind": 5,
        "importPath": "examples.agent_patterns.deterministic",
        "description": "examples.agent_patterns.deterministic",
        "peekOfCode": "story_outline_agent = Agent(\n    name=\"story_outline_agent\",\n    instructions=\"Generate a very short story outline based on the user's input.\",\n)\nclass OutlineCheckerOutput(BaseModel):\n    good_quality: bool\n    is_scifi: bool\noutline_checker_agent = Agent(\n    name=\"outline_checker_agent\",\n    instructions=\"Read the given story outline, and judge the quality. Also, determine if it is a scifi story.\",",
        "detail": "examples.agent_patterns.deterministic",
        "documentation": {}
    },
    {
        "label": "outline_checker_agent",
        "kind": 5,
        "importPath": "examples.agent_patterns.deterministic",
        "description": "examples.agent_patterns.deterministic",
        "peekOfCode": "outline_checker_agent = Agent(\n    name=\"outline_checker_agent\",\n    instructions=\"Read the given story outline, and judge the quality. Also, determine if it is a scifi story.\",\n    output_type=OutlineCheckerOutput,\n)\nstory_agent = Agent(\n    name=\"story_agent\",\n    instructions=\"Write a short story based on the given outline.\",\n    output_type=str,\n)",
        "detail": "examples.agent_patterns.deterministic",
        "documentation": {}
    },
    {
        "label": "story_agent",
        "kind": 5,
        "importPath": "examples.agent_patterns.deterministic",
        "description": "examples.agent_patterns.deterministic",
        "peekOfCode": "story_agent = Agent(\n    name=\"story_agent\",\n    instructions=\"Write a short story based on the given outline.\",\n    output_type=str,\n)\nasync def main():\n    input_prompt = input(\"What kind of story do you want? \")\n    # Ensure the entire workflow is a single trace\n    with trace(\"Deterministic story flow\"):\n        # 1. Generate an outline",
        "detail": "examples.agent_patterns.deterministic",
        "documentation": {}
    },
    {
        "label": "Weather",
        "kind": 6,
        "importPath": "examples.agent_patterns.forcing_tool_use",
        "description": "examples.agent_patterns.forcing_tool_use",
        "peekOfCode": "class Weather(BaseModel):\n    city: str\n    temperature_range: str\n    conditions: str\n@function_tool\ndef get_weather(city: str) -> Weather:\n    print(\"[debug] get_weather called\")\n    return Weather(city=city, temperature_range=\"14-20C\", conditions=\"Sunny with wind\")\nasync def custom_tool_use_behavior(\n    context: RunContextWrapper[Any], results: list[FunctionToolResult]",
        "detail": "examples.agent_patterns.forcing_tool_use",
        "documentation": {}
    },
    {
        "label": "get_weather",
        "kind": 2,
        "importPath": "examples.agent_patterns.forcing_tool_use",
        "description": "examples.agent_patterns.forcing_tool_use",
        "peekOfCode": "def get_weather(city: str) -> Weather:\n    print(\"[debug] get_weather called\")\n    return Weather(city=city, temperature_range=\"14-20C\", conditions=\"Sunny with wind\")\nasync def custom_tool_use_behavior(\n    context: RunContextWrapper[Any], results: list[FunctionToolResult]\n) -> ToolsToFinalOutputResult:\n    weather: Weather = results[0].output\n    return ToolsToFinalOutputResult(\n        is_final_output=True, final_output=f\"{weather.city} is {weather.conditions}.\"\n    )",
        "detail": "examples.agent_patterns.forcing_tool_use",
        "documentation": {}
    },
    {
        "label": "MathHomeworkOutput",
        "kind": 6,
        "importPath": "examples.agent_patterns.input_guardrails",
        "description": "examples.agent_patterns.input_guardrails",
        "peekOfCode": "class MathHomeworkOutput(BaseModel):\n    reasoning: str\n    is_math_homework: bool\nguardrail_agent = Agent(\n    name=\"Guardrail check\",\n    instructions=\"Check if the user is asking you to do their math homework.\",\n    output_type=MathHomeworkOutput,\n)\n@input_guardrail\nasync def math_guardrail(",
        "detail": "examples.agent_patterns.input_guardrails",
        "documentation": {}
    },
    {
        "label": "guardrail_agent",
        "kind": 5,
        "importPath": "examples.agent_patterns.input_guardrails",
        "description": "examples.agent_patterns.input_guardrails",
        "peekOfCode": "guardrail_agent = Agent(\n    name=\"Guardrail check\",\n    instructions=\"Check if the user is asking you to do their math homework.\",\n    output_type=MathHomeworkOutput,\n)\n@input_guardrail\nasync def math_guardrail(\n    context: RunContextWrapper[None], agent: Agent, input: str | list[TResponseInputItem]\n) -> GuardrailFunctionOutput:\n    \"\"\"This is an input guardrail function, which happens to call an agent to check if the input",
        "detail": "examples.agent_patterns.input_guardrails",
        "documentation": {}
    },
    {
        "label": "EvaluationFeedback",
        "kind": 6,
        "importPath": "examples.agent_patterns.llm_as_a_judge",
        "description": "examples.agent_patterns.llm_as_a_judge",
        "peekOfCode": "class EvaluationFeedback:\n    feedback: str\n    score: Literal[\"pass\", \"needs_improvement\", \"fail\"]\nevaluator = Agent[None](\n    name=\"evaluator\",\n    instructions=(\n        \"You evaluate a story outline and decide if it's good enough.\"\n        \"If it's not good enough, you provide feedback on what needs to be improved.\"\n        \"Never give it a pass on the first try.\"\n    ),",
        "detail": "examples.agent_patterns.llm_as_a_judge",
        "documentation": {}
    },
    {
        "label": "story_outline_generator",
        "kind": 5,
        "importPath": "examples.agent_patterns.llm_as_a_judge",
        "description": "examples.agent_patterns.llm_as_a_judge",
        "peekOfCode": "story_outline_generator = Agent(\n    name=\"story_outline_generator\",\n    instructions=(\n        \"You generate a very short story outline based on the user's input.\"\n        \"If there is any feedback provided, use it to improve the outline.\"\n    ),\n)\n@dataclass\nclass EvaluationFeedback:\n    feedback: str",
        "detail": "examples.agent_patterns.llm_as_a_judge",
        "documentation": {}
    },
    {
        "label": "evaluator",
        "kind": 5,
        "importPath": "examples.agent_patterns.llm_as_a_judge",
        "description": "examples.agent_patterns.llm_as_a_judge",
        "peekOfCode": "evaluator = Agent[None](\n    name=\"evaluator\",\n    instructions=(\n        \"You evaluate a story outline and decide if it's good enough.\"\n        \"If it's not good enough, you provide feedback on what needs to be improved.\"\n        \"Never give it a pass on the first try.\"\n    ),\n    output_type=EvaluationFeedback,\n)\nasync def main() -> None:",
        "detail": "examples.agent_patterns.llm_as_a_judge",
        "documentation": {}
    },
    {
        "label": "MessageOutput",
        "kind": 6,
        "importPath": "examples.agent_patterns.output_guardrails",
        "description": "examples.agent_patterns.output_guardrails",
        "peekOfCode": "class MessageOutput(BaseModel):\n    reasoning: str = Field(description=\"Thoughts on how to respond to the user's message\")\n    response: str = Field(description=\"The response to the user's message\")\n    user_name: str | None = Field(description=\"The name of the user who sent the message, if known\")\n@output_guardrail\nasync def sensitive_data_check(\n    context: RunContextWrapper, agent: Agent, output: MessageOutput\n) -> GuardrailFunctionOutput:\n    phone_number_in_response = \"650\" in output.response\n    phone_number_in_reasoning = \"650\" in output.reasoning",
        "detail": "examples.agent_patterns.output_guardrails",
        "documentation": {}
    },
    {
        "label": "agent",
        "kind": 5,
        "importPath": "examples.agent_patterns.output_guardrails",
        "description": "examples.agent_patterns.output_guardrails",
        "peekOfCode": "agent = Agent(\n    name=\"Assistant\",\n    instructions=\"You are a helpful assistant.\",\n    output_type=MessageOutput,\n    output_guardrails=[sensitive_data_check],\n)\nasync def main():\n    # This should be ok\n    await Runner.run(agent, \"What's the capital of California?\")\n    print(\"First message passed\")",
        "detail": "examples.agent_patterns.output_guardrails",
        "documentation": {}
    },
    {
        "label": "spanish_agent",
        "kind": 5,
        "importPath": "examples.agent_patterns.parallelization",
        "description": "examples.agent_patterns.parallelization",
        "peekOfCode": "spanish_agent = Agent(\n    name=\"spanish_agent\",\n    instructions=\"You translate the user's message to Spanish\",\n)\ntranslation_picker = Agent(\n    name=\"translation_picker\",\n    instructions=\"You pick the best Spanish translation from the given options.\",\n)\nasync def main():\n    msg = input(\"Hi! Enter a message, and we'll translate it to Spanish.\\n\\n\")",
        "detail": "examples.agent_patterns.parallelization",
        "documentation": {}
    },
    {
        "label": "translation_picker",
        "kind": 5,
        "importPath": "examples.agent_patterns.parallelization",
        "description": "examples.agent_patterns.parallelization",
        "peekOfCode": "translation_picker = Agent(\n    name=\"translation_picker\",\n    instructions=\"You pick the best Spanish translation from the given options.\",\n)\nasync def main():\n    msg = input(\"Hi! Enter a message, and we'll translate it to Spanish.\\n\\n\")\n    # Ensure the entire workflow is a single trace\n    with trace(\"Parallel translation\"):\n        res_1, res_2, res_3 = await asyncio.gather(\n            Runner.run(",
        "detail": "examples.agent_patterns.parallelization",
        "documentation": {}
    },
    {
        "label": "french_agent",
        "kind": 5,
        "importPath": "examples.agent_patterns.routing",
        "description": "examples.agent_patterns.routing",
        "peekOfCode": "french_agent = Agent(\n    name=\"french_agent\",\n    instructions=\"You only speak French\",\n)\nspanish_agent = Agent(\n    name=\"spanish_agent\",\n    instructions=\"You only speak Spanish\",\n)\nenglish_agent = Agent(\n    name=\"english_agent\",",
        "detail": "examples.agent_patterns.routing",
        "documentation": {}
    },
    {
        "label": "spanish_agent",
        "kind": 5,
        "importPath": "examples.agent_patterns.routing",
        "description": "examples.agent_patterns.routing",
        "peekOfCode": "spanish_agent = Agent(\n    name=\"spanish_agent\",\n    instructions=\"You only speak Spanish\",\n)\nenglish_agent = Agent(\n    name=\"english_agent\",\n    instructions=\"You only speak English\",\n)\ntriage_agent = Agent(\n    name=\"triage_agent\",",
        "detail": "examples.agent_patterns.routing",
        "documentation": {}
    },
    {
        "label": "english_agent",
        "kind": 5,
        "importPath": "examples.agent_patterns.routing",
        "description": "examples.agent_patterns.routing",
        "peekOfCode": "english_agent = Agent(\n    name=\"english_agent\",\n    instructions=\"You only speak English\",\n)\ntriage_agent = Agent(\n    name=\"triage_agent\",\n    instructions=\"Handoff to the appropriate agent based on the language of the request.\",\n    handoffs=[french_agent, spanish_agent, english_agent],\n)\nasync def main():",
        "detail": "examples.agent_patterns.routing",
        "documentation": {}
    },
    {
        "label": "triage_agent",
        "kind": 5,
        "importPath": "examples.agent_patterns.routing",
        "description": "examples.agent_patterns.routing",
        "peekOfCode": "triage_agent = Agent(\n    name=\"triage_agent\",\n    instructions=\"Handoff to the appropriate agent based on the language of the request.\",\n    handoffs=[french_agent, spanish_agent, english_agent],\n)\nasync def main():\n    # We'll create an ID for this conversation, so we can link each trace\n    conversation_id = str(uuid.uuid4().hex[:16])\n    msg = input(\"Hi! We speak French, Spanish and English. How can I help? \")\n    agent = triage_agent",
        "detail": "examples.agent_patterns.routing",
        "documentation": {}
    },
    {
        "label": "CustomAgentHooks",
        "kind": 6,
        "importPath": "examples.basic.agent_lifecycle_example",
        "description": "examples.basic.agent_lifecycle_example",
        "peekOfCode": "class CustomAgentHooks(AgentHooks):\n    def __init__(self, display_name: str):\n        self.event_counter = 0\n        self.display_name = display_name\n    async def on_start(self, context: RunContextWrapper, agent: Agent) -> None:\n        self.event_counter += 1\n        print(f\"### ({self.display_name}) {self.event_counter}: Agent {agent.name} started\")\n    async def on_end(self, context: RunContextWrapper, agent: Agent, output: Any) -> None:\n        self.event_counter += 1\n        print(",
        "detail": "examples.basic.agent_lifecycle_example",
        "documentation": {}
    },
    {
        "label": "FinalResult",
        "kind": 6,
        "importPath": "examples.basic.agent_lifecycle_example",
        "description": "examples.basic.agent_lifecycle_example",
        "peekOfCode": "class FinalResult(BaseModel):\n    number: int\nmultiply_agent = Agent(\n    name=\"Multiply Agent\",\n    instructions=\"Multiply the number by 2 and then return the final result.\",\n    tools=[multiply_by_two],\n    output_type=FinalResult,\n    hooks=CustomAgentHooks(display_name=\"Multiply Agent\"),\n)\nstart_agent = Agent(",
        "detail": "examples.basic.agent_lifecycle_example",
        "documentation": {}
    },
    {
        "label": "random_number",
        "kind": 2,
        "importPath": "examples.basic.agent_lifecycle_example",
        "description": "examples.basic.agent_lifecycle_example",
        "peekOfCode": "def random_number(max: int) -> int:\n    \"\"\"\n    Generate a random number up to the provided maximum.\n    \"\"\"\n    return random.randint(0, max)\n@function_tool\ndef multiply_by_two(x: int) -> int:\n    \"\"\"Simple multiplication by two.\"\"\"\n    return x * 2\nclass FinalResult(BaseModel):",
        "detail": "examples.basic.agent_lifecycle_example",
        "documentation": {}
    },
    {
        "label": "multiply_by_two",
        "kind": 2,
        "importPath": "examples.basic.agent_lifecycle_example",
        "description": "examples.basic.agent_lifecycle_example",
        "peekOfCode": "def multiply_by_two(x: int) -> int:\n    \"\"\"Simple multiplication by two.\"\"\"\n    return x * 2\nclass FinalResult(BaseModel):\n    number: int\nmultiply_agent = Agent(\n    name=\"Multiply Agent\",\n    instructions=\"Multiply the number by 2 and then return the final result.\",\n    tools=[multiply_by_two],\n    output_type=FinalResult,",
        "detail": "examples.basic.agent_lifecycle_example",
        "documentation": {}
    },
    {
        "label": "multiply_agent",
        "kind": 5,
        "importPath": "examples.basic.agent_lifecycle_example",
        "description": "examples.basic.agent_lifecycle_example",
        "peekOfCode": "multiply_agent = Agent(\n    name=\"Multiply Agent\",\n    instructions=\"Multiply the number by 2 and then return the final result.\",\n    tools=[multiply_by_two],\n    output_type=FinalResult,\n    hooks=CustomAgentHooks(display_name=\"Multiply Agent\"),\n)\nstart_agent = Agent(\n    name=\"Start Agent\",\n    instructions=\"Generate a random number. If it's even, stop. If it's odd, hand off to the multiply agent.\",",
        "detail": "examples.basic.agent_lifecycle_example",
        "documentation": {}
    },
    {
        "label": "start_agent",
        "kind": 5,
        "importPath": "examples.basic.agent_lifecycle_example",
        "description": "examples.basic.agent_lifecycle_example",
        "peekOfCode": "start_agent = Agent(\n    name=\"Start Agent\",\n    instructions=\"Generate a random number. If it's even, stop. If it's odd, hand off to the multiply agent.\",\n    tools=[random_number],\n    output_type=FinalResult,\n    handoffs=[multiply_agent],\n    hooks=CustomAgentHooks(display_name=\"Start Agent\"),\n)\nasync def main() -> None:\n    user_input = input(\"Enter a max number: \")",
        "detail": "examples.basic.agent_lifecycle_example",
        "documentation": {}
    },
    {
        "label": "CustomContext",
        "kind": 6,
        "importPath": "examples.basic.dynamic_system_prompt",
        "description": "examples.basic.dynamic_system_prompt",
        "peekOfCode": "class CustomContext:\n    def __init__(self, style: Literal[\"haiku\", \"pirate\", \"robot\"]):\n        self.style = style\ndef custom_instructions(\n    run_context: RunContextWrapper[CustomContext], agent: Agent[CustomContext]\n) -> str:\n    context = run_context.context\n    if context.style == \"haiku\":\n        return \"Only respond in haikus.\"\n    elif context.style == \"pirate\":",
        "detail": "examples.basic.dynamic_system_prompt",
        "documentation": {}
    },
    {
        "label": "custom_instructions",
        "kind": 2,
        "importPath": "examples.basic.dynamic_system_prompt",
        "description": "examples.basic.dynamic_system_prompt",
        "peekOfCode": "def custom_instructions(\n    run_context: RunContextWrapper[CustomContext], agent: Agent[CustomContext]\n) -> str:\n    context = run_context.context\n    if context.style == \"haiku\":\n        return \"Only respond in haikus.\"\n    elif context.style == \"pirate\":\n        return \"Respond as a pirate.\"\n    else:\n        return \"Respond as a robot and say 'beep boop' a lot.\"",
        "detail": "examples.basic.dynamic_system_prompt",
        "documentation": {}
    },
    {
        "label": "agent",
        "kind": 5,
        "importPath": "examples.basic.dynamic_system_prompt",
        "description": "examples.basic.dynamic_system_prompt",
        "peekOfCode": "agent = Agent(\n    name=\"Chat agent\",\n    instructions=custom_instructions,\n)\nasync def main():\n    choice: Literal[\"haiku\", \"pirate\", \"robot\"] = random.choice([\"haiku\", \"pirate\", \"robot\"])\n    context = CustomContext(style=choice)\n    print(f\"Using style: {choice}\\n\")\n    user_message = \"Tell me a joke.\"\n    print(f\"User: {user_message}\")",
        "detail": "examples.basic.dynamic_system_prompt",
        "documentation": {}
    },
    {
        "label": "agent",
        "kind": 5,
        "importPath": "examples.basic.hello_world_jupyter",
        "description": "examples.basic.hello_world_jupyter",
        "peekOfCode": "agent = Agent(name=\"Assistant\", instructions=\"You are a helpful assistant\")\n# Intended for Jupyter notebooks where there's an existing event loop\nresult = await Runner.run(agent, \"Write a haiku about recursion in programming.\")  # type: ignore[top-level-await]  # noqa: F704\nprint(result.final_output)\n# Code within code loops,\n# Infinite mirrors reflect\n# Logic folds on self.",
        "detail": "examples.basic.hello_world_jupyter",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "examples.basic.hello_world_jupyter",
        "description": "examples.basic.hello_world_jupyter",
        "peekOfCode": "result = await Runner.run(agent, \"Write a haiku about recursion in programming.\")  # type: ignore[top-level-await]  # noqa: F704\nprint(result.final_output)\n# Code within code loops,\n# Infinite mirrors reflect\n# Logic folds on self.",
        "detail": "examples.basic.hello_world_jupyter",
        "documentation": {}
    },
    {
        "label": "ExampleHooks",
        "kind": 6,
        "importPath": "examples.basic.lifecycle_example",
        "description": "examples.basic.lifecycle_example",
        "peekOfCode": "class ExampleHooks(RunHooks):\n    def __init__(self):\n        self.event_counter = 0\n    def _usage_to_str(self, usage: Usage) -> str:\n        return f\"{usage.requests} requests, {usage.input_tokens} input tokens, {usage.output_tokens} output tokens, {usage.total_tokens} total tokens\"\n    async def on_agent_start(self, context: RunContextWrapper, agent: Agent) -> None:\n        self.event_counter += 1\n        print(\n            f\"### {self.event_counter}: Agent {agent.name} started. Usage: {self._usage_to_str(context.usage)}\"\n        )",
        "detail": "examples.basic.lifecycle_example",
        "documentation": {}
    },
    {
        "label": "FinalResult",
        "kind": 6,
        "importPath": "examples.basic.lifecycle_example",
        "description": "examples.basic.lifecycle_example",
        "peekOfCode": "class FinalResult(BaseModel):\n    number: int\nmultiply_agent = Agent(\n    name=\"Multiply Agent\",\n    instructions=\"Multiply the number by 2 and then return the final result.\",\n    tools=[multiply_by_two],\n    output_type=FinalResult,\n)\nstart_agent = Agent(\n    name=\"Start Agent\",",
        "detail": "examples.basic.lifecycle_example",
        "documentation": {}
    },
    {
        "label": "random_number",
        "kind": 2,
        "importPath": "examples.basic.lifecycle_example",
        "description": "examples.basic.lifecycle_example",
        "peekOfCode": "def random_number(max: int) -> int:\n    \"\"\"Generate a random number up to the provided max.\"\"\"\n    return random.randint(0, max)\n@function_tool\ndef multiply_by_two(x: int) -> int:\n    \"\"\"Return x times two.\"\"\"\n    return x * 2\nclass FinalResult(BaseModel):\n    number: int\nmultiply_agent = Agent(",
        "detail": "examples.basic.lifecycle_example",
        "documentation": {}
    },
    {
        "label": "multiply_by_two",
        "kind": 2,
        "importPath": "examples.basic.lifecycle_example",
        "description": "examples.basic.lifecycle_example",
        "peekOfCode": "def multiply_by_two(x: int) -> int:\n    \"\"\"Return x times two.\"\"\"\n    return x * 2\nclass FinalResult(BaseModel):\n    number: int\nmultiply_agent = Agent(\n    name=\"Multiply Agent\",\n    instructions=\"Multiply the number by 2 and then return the final result.\",\n    tools=[multiply_by_two],\n    output_type=FinalResult,",
        "detail": "examples.basic.lifecycle_example",
        "documentation": {}
    },
    {
        "label": "hooks",
        "kind": 5,
        "importPath": "examples.basic.lifecycle_example",
        "description": "examples.basic.lifecycle_example",
        "peekOfCode": "hooks = ExampleHooks()\n###\n@function_tool\ndef random_number(max: int) -> int:\n    \"\"\"Generate a random number up to the provided max.\"\"\"\n    return random.randint(0, max)\n@function_tool\ndef multiply_by_two(x: int) -> int:\n    \"\"\"Return x times two.\"\"\"\n    return x * 2",
        "detail": "examples.basic.lifecycle_example",
        "documentation": {}
    },
    {
        "label": "multiply_agent",
        "kind": 5,
        "importPath": "examples.basic.lifecycle_example",
        "description": "examples.basic.lifecycle_example",
        "peekOfCode": "multiply_agent = Agent(\n    name=\"Multiply Agent\",\n    instructions=\"Multiply the number by 2 and then return the final result.\",\n    tools=[multiply_by_two],\n    output_type=FinalResult,\n)\nstart_agent = Agent(\n    name=\"Start Agent\",\n    instructions=\"Generate a random number. If it's even, stop. If it's odd, hand off to the multipler agent.\",\n    tools=[random_number],",
        "detail": "examples.basic.lifecycle_example",
        "documentation": {}
    },
    {
        "label": "start_agent",
        "kind": 5,
        "importPath": "examples.basic.lifecycle_example",
        "description": "examples.basic.lifecycle_example",
        "peekOfCode": "start_agent = Agent(\n    name=\"Start Agent\",\n    instructions=\"Generate a random number. If it's even, stop. If it's odd, hand off to the multipler agent.\",\n    tools=[random_number],\n    output_type=FinalResult,\n    handoffs=[multiply_agent],\n)\nasync def main() -> None:\n    user_input = input(\"Enter a max number: \")\n    await Runner.run(",
        "detail": "examples.basic.lifecycle_example",
        "documentation": {}
    },
    {
        "label": "how_many_jokes",
        "kind": 2,
        "importPath": "examples.basic.stream_items",
        "description": "examples.basic.stream_items",
        "peekOfCode": "def how_many_jokes() -> int:\n    return random.randint(1, 10)\nasync def main():\n    agent = Agent(\n        name=\"Joker\",\n        instructions=\"First call the `how_many_jokes` tool, then tell that many jokes.\",\n        tools=[how_many_jokes],\n    )\n    result = Runner.run_streamed(\n        agent,",
        "detail": "examples.basic.stream_items",
        "documentation": {}
    },
    {
        "label": "Weather",
        "kind": 6,
        "importPath": "examples.basic.tools",
        "description": "examples.basic.tools",
        "peekOfCode": "class Weather(BaseModel):\n    city: str\n    temperature_range: str\n    conditions: str\n@function_tool\ndef get_weather(city: str) -> Weather:\n    print(\"[debug] get_weather called\")\n    return Weather(city=city, temperature_range=\"14-20C\", conditions=\"Sunny with wind.\")\nagent = Agent(\n    name=\"Hello world\",",
        "detail": "examples.basic.tools",
        "documentation": {}
    },
    {
        "label": "get_weather",
        "kind": 2,
        "importPath": "examples.basic.tools",
        "description": "examples.basic.tools",
        "peekOfCode": "def get_weather(city: str) -> Weather:\n    print(\"[debug] get_weather called\")\n    return Weather(city=city, temperature_range=\"14-20C\", conditions=\"Sunny with wind.\")\nagent = Agent(\n    name=\"Hello world\",\n    instructions=\"You are a helpful agent.\",\n    tools=[get_weather],\n)\nasync def main():\n    result = await Runner.run(agent, input=\"What's the weather in Tokyo?\")",
        "detail": "examples.basic.tools",
        "documentation": {}
    },
    {
        "label": "agent",
        "kind": 5,
        "importPath": "examples.basic.tools",
        "description": "examples.basic.tools",
        "peekOfCode": "agent = Agent(\n    name=\"Hello world\",\n    instructions=\"You are a helpful agent.\",\n    tools=[get_weather],\n)\nasync def main():\n    result = await Runner.run(agent, input=\"What's the weather in Tokyo?\")\n    print(result.final_output)\n    # The weather in Tokyo is sunny.\nif __name__ == \"__main__\":",
        "detail": "examples.basic.tools",
        "documentation": {}
    },
    {
        "label": "AirlineAgentContext",
        "kind": 6,
        "importPath": "examples.customer_service.main",
        "description": "examples.customer_service.main",
        "peekOfCode": "class AirlineAgentContext(BaseModel):\n    passenger_name: str | None = None\n    confirmation_number: str | None = None\n    seat_number: str | None = None\n    flight_number: str | None = None\n### TOOLS\n@function_tool(\n    name_override=\"faq_lookup_tool\", description_override=\"Lookup frequently asked questions.\"\n)\nasync def faq_lookup_tool(question: str) -> str:",
        "detail": "examples.customer_service.main",
        "documentation": {}
    },
    {
        "label": "faq_agent",
        "kind": 5,
        "importPath": "examples.customer_service.main",
        "description": "examples.customer_service.main",
        "peekOfCode": "faq_agent = Agent[AirlineAgentContext](\n    name=\"FAQ Agent\",\n    handoff_description=\"A helpful agent that can answer questions about the airline.\",\n    instructions=f\"\"\"{RECOMMENDED_PROMPT_PREFIX}\n    You are an FAQ agent. If you are speaking to a customer, you probably were transferred to from the triage agent.\n    Use the following routine to support the customer.\n    # Routine\n    1. Identify the last question asked by the customer.\n    2. Use the faq lookup tool to answer the question. Do not rely on your own knowledge.\n    3. If you cannot answer the question, transfer back to the triage agent.\"\"\",",
        "detail": "examples.customer_service.main",
        "documentation": {}
    },
    {
        "label": "seat_booking_agent",
        "kind": 5,
        "importPath": "examples.customer_service.main",
        "description": "examples.customer_service.main",
        "peekOfCode": "seat_booking_agent = Agent[AirlineAgentContext](\n    name=\"Seat Booking Agent\",\n    handoff_description=\"A helpful agent that can update a seat on a flight.\",\n    instructions=f\"\"\"{RECOMMENDED_PROMPT_PREFIX}\n    You are a seat booking agent. If you are speaking to a customer, you probably were transferred to from the triage agent.\n    Use the following routine to support the customer.\n    # Routine\n    1. Ask for their confirmation number.\n    2. Ask the customer what their desired seat number is.\n    3. Use the update seat tool to update the seat on the flight.",
        "detail": "examples.customer_service.main",
        "documentation": {}
    },
    {
        "label": "triage_agent",
        "kind": 5,
        "importPath": "examples.customer_service.main",
        "description": "examples.customer_service.main",
        "peekOfCode": "triage_agent = Agent[AirlineAgentContext](\n    name=\"Triage Agent\",\n    handoff_description=\"A triage agent that can delegate a customer's request to the appropriate agent.\",\n    instructions=(\n        f\"{RECOMMENDED_PROMPT_PREFIX} \"\n        \"You are a helpful triaging agent. You can use your tools to delegate questions to other appropriate agents.\"\n    ),\n    handoffs=[\n        faq_agent,\n        handoff(agent=seat_booking_agent, on_handoff=on_seat_booking_handoff),",
        "detail": "examples.customer_service.main",
        "documentation": {}
    },
    {
        "label": "random_number_tool",
        "kind": 2,
        "importPath": "examples.handoffs.message_filter",
        "description": "examples.handoffs.message_filter",
        "peekOfCode": "def random_number_tool(max: int) -> int:\n    \"\"\"Return a random integer between 0 and the given maximum.\"\"\"\n    return random.randint(0, max)\ndef spanish_handoff_message_filter(handoff_message_data: HandoffInputData) -> HandoffInputData:\n    # First, we'll remove any tool-related messages from the message history\n    handoff_message_data = handoff_filters.remove_all_tools(handoff_message_data)\n    # Second, we'll also remove the first two items from the history, just for demonstration\n    history = (\n        tuple(handoff_message_data.input_history[2:])\n        if isinstance(handoff_message_data.input_history, tuple)",
        "detail": "examples.handoffs.message_filter",
        "documentation": {}
    },
    {
        "label": "spanish_handoff_message_filter",
        "kind": 2,
        "importPath": "examples.handoffs.message_filter",
        "description": "examples.handoffs.message_filter",
        "peekOfCode": "def spanish_handoff_message_filter(handoff_message_data: HandoffInputData) -> HandoffInputData:\n    # First, we'll remove any tool-related messages from the message history\n    handoff_message_data = handoff_filters.remove_all_tools(handoff_message_data)\n    # Second, we'll also remove the first two items from the history, just for demonstration\n    history = (\n        tuple(handoff_message_data.input_history[2:])\n        if isinstance(handoff_message_data.input_history, tuple)\n        else handoff_message_data.input_history\n    )\n    return HandoffInputData(",
        "detail": "examples.handoffs.message_filter",
        "documentation": {}
    },
    {
        "label": "first_agent",
        "kind": 5,
        "importPath": "examples.handoffs.message_filter",
        "description": "examples.handoffs.message_filter",
        "peekOfCode": "first_agent = Agent(\n    name=\"Assistant\",\n    instructions=\"Be extremely concise.\",\n    tools=[random_number_tool],\n)\nspanish_agent = Agent(\n    name=\"Spanish Assistant\",\n    instructions=\"You only speak Spanish and are extremely concise.\",\n    handoff_description=\"A Spanish-speaking assistant.\",\n)",
        "detail": "examples.handoffs.message_filter",
        "documentation": {}
    },
    {
        "label": "spanish_agent",
        "kind": 5,
        "importPath": "examples.handoffs.message_filter",
        "description": "examples.handoffs.message_filter",
        "peekOfCode": "spanish_agent = Agent(\n    name=\"Spanish Assistant\",\n    instructions=\"You only speak Spanish and are extremely concise.\",\n    handoff_description=\"A Spanish-speaking assistant.\",\n)\nsecond_agent = Agent(\n    name=\"Assistant\",\n    instructions=(\n        \"Be a helpful assistant. If the user speaks Spanish, handoff to the Spanish assistant.\"\n    ),",
        "detail": "examples.handoffs.message_filter",
        "documentation": {}
    },
    {
        "label": "second_agent",
        "kind": 5,
        "importPath": "examples.handoffs.message_filter",
        "description": "examples.handoffs.message_filter",
        "peekOfCode": "second_agent = Agent(\n    name=\"Assistant\",\n    instructions=(\n        \"Be a helpful assistant. If the user speaks Spanish, handoff to the Spanish assistant.\"\n    ),\n    handoffs=[handoff(spanish_agent, input_filter=spanish_handoff_message_filter)],\n)\nasync def main():\n    # Trace the entire run as a single workflow\n    with trace(workflow_name=\"Message filtering\"):",
        "detail": "examples.handoffs.message_filter",
        "documentation": {}
    },
    {
        "label": "random_number_tool",
        "kind": 2,
        "importPath": "examples.handoffs.message_filter_streaming",
        "description": "examples.handoffs.message_filter_streaming",
        "peekOfCode": "def random_number_tool(max: int) -> int:\n    \"\"\"Return a random integer between 0 and the given maximum.\"\"\"\n    return random.randint(0, max)\ndef spanish_handoff_message_filter(handoff_message_data: HandoffInputData) -> HandoffInputData:\n    # First, we'll remove any tool-related messages from the message history\n    handoff_message_data = handoff_filters.remove_all_tools(handoff_message_data)\n    # Second, we'll also remove the first two items from the history, just for demonstration\n    history = (\n        tuple(handoff_message_data.input_history[2:])\n        if isinstance(handoff_message_data.input_history, tuple)",
        "detail": "examples.handoffs.message_filter_streaming",
        "documentation": {}
    },
    {
        "label": "spanish_handoff_message_filter",
        "kind": 2,
        "importPath": "examples.handoffs.message_filter_streaming",
        "description": "examples.handoffs.message_filter_streaming",
        "peekOfCode": "def spanish_handoff_message_filter(handoff_message_data: HandoffInputData) -> HandoffInputData:\n    # First, we'll remove any tool-related messages from the message history\n    handoff_message_data = handoff_filters.remove_all_tools(handoff_message_data)\n    # Second, we'll also remove the first two items from the history, just for demonstration\n    history = (\n        tuple(handoff_message_data.input_history[2:])\n        if isinstance(handoff_message_data.input_history, tuple)\n        else handoff_message_data.input_history\n    )\n    return HandoffInputData(",
        "detail": "examples.handoffs.message_filter_streaming",
        "documentation": {}
    },
    {
        "label": "first_agent",
        "kind": 5,
        "importPath": "examples.handoffs.message_filter_streaming",
        "description": "examples.handoffs.message_filter_streaming",
        "peekOfCode": "first_agent = Agent(\n    name=\"Assistant\",\n    instructions=\"Be extremely concise.\",\n    tools=[random_number_tool],\n)\nspanish_agent = Agent(\n    name=\"Spanish Assistant\",\n    instructions=\"You only speak Spanish and are extremely concise.\",\n    handoff_description=\"A Spanish-speaking assistant.\",\n)",
        "detail": "examples.handoffs.message_filter_streaming",
        "documentation": {}
    },
    {
        "label": "spanish_agent",
        "kind": 5,
        "importPath": "examples.handoffs.message_filter_streaming",
        "description": "examples.handoffs.message_filter_streaming",
        "peekOfCode": "spanish_agent = Agent(\n    name=\"Spanish Assistant\",\n    instructions=\"You only speak Spanish and are extremely concise.\",\n    handoff_description=\"A Spanish-speaking assistant.\",\n)\nsecond_agent = Agent(\n    name=\"Assistant\",\n    instructions=(\n        \"Be a helpful assistant. If the user speaks Spanish, handoff to the Spanish assistant.\"\n    ),",
        "detail": "examples.handoffs.message_filter_streaming",
        "documentation": {}
    },
    {
        "label": "second_agent",
        "kind": 5,
        "importPath": "examples.handoffs.message_filter_streaming",
        "description": "examples.handoffs.message_filter_streaming",
        "peekOfCode": "second_agent = Agent(\n    name=\"Assistant\",\n    instructions=(\n        \"Be a helpful assistant. If the user speaks Spanish, handoff to the Spanish assistant.\"\n    ),\n    handoffs=[handoff(spanish_agent, input_filter=spanish_handoff_message_filter)],\n)\nasync def main():\n    # Trace the entire run as a single workflow\n    with trace(workflow_name=\"Streaming message filter\"):",
        "detail": "examples.handoffs.message_filter_streaming",
        "documentation": {}
    },
    {
        "label": "get_weather",
        "kind": 2,
        "importPath": "examples.model_providers.custom_example_agent",
        "description": "examples.model_providers.custom_example_agent",
        "peekOfCode": "def get_weather(city: str):\n    print(f\"[debug] getting weather for {city}\")\n    return f\"The weather in {city} is sunny.\"\nasync def main():\n    # This agent will use the custom LLM provider\n    agent = Agent(\n        name=\"Assistant\",\n        instructions=\"You only respond in haikus.\",\n        model=OpenAIChatCompletionsModel(model=MODEL_NAME, openai_client=client),\n        tools=[get_weather],",
        "detail": "examples.model_providers.custom_example_agent",
        "documentation": {}
    },
    {
        "label": "BASE_URL",
        "kind": 5,
        "importPath": "examples.model_providers.custom_example_agent",
        "description": "examples.model_providers.custom_example_agent",
        "peekOfCode": "BASE_URL = os.getenv(\"EXAMPLE_BASE_URL\") or \"\"\nAPI_KEY = os.getenv(\"EXAMPLE_API_KEY\") or \"\"\nMODEL_NAME = os.getenv(\"EXAMPLE_MODEL_NAME\") or \"\"\nif not BASE_URL or not API_KEY or not MODEL_NAME:\n    raise ValueError(\n        \"Please set EXAMPLE_BASE_URL, EXAMPLE_API_KEY, EXAMPLE_MODEL_NAME via env var or code.\"\n    )\n\"\"\"This example uses a custom provider for a specific agent. Steps:\n1. Create a custom OpenAI client.\n2. Create a `Model` that uses the custom client.",
        "detail": "examples.model_providers.custom_example_agent",
        "documentation": {}
    },
    {
        "label": "API_KEY",
        "kind": 5,
        "importPath": "examples.model_providers.custom_example_agent",
        "description": "examples.model_providers.custom_example_agent",
        "peekOfCode": "API_KEY = os.getenv(\"EXAMPLE_API_KEY\") or \"\"\nMODEL_NAME = os.getenv(\"EXAMPLE_MODEL_NAME\") or \"\"\nif not BASE_URL or not API_KEY or not MODEL_NAME:\n    raise ValueError(\n        \"Please set EXAMPLE_BASE_URL, EXAMPLE_API_KEY, EXAMPLE_MODEL_NAME via env var or code.\"\n    )\n\"\"\"This example uses a custom provider for a specific agent. Steps:\n1. Create a custom OpenAI client.\n2. Create a `Model` that uses the custom client.\n3. Set the `model` on the Agent.",
        "detail": "examples.model_providers.custom_example_agent",
        "documentation": {}
    },
    {
        "label": "MODEL_NAME",
        "kind": 5,
        "importPath": "examples.model_providers.custom_example_agent",
        "description": "examples.model_providers.custom_example_agent",
        "peekOfCode": "MODEL_NAME = os.getenv(\"EXAMPLE_MODEL_NAME\") or \"\"\nif not BASE_URL or not API_KEY or not MODEL_NAME:\n    raise ValueError(\n        \"Please set EXAMPLE_BASE_URL, EXAMPLE_API_KEY, EXAMPLE_MODEL_NAME via env var or code.\"\n    )\n\"\"\"This example uses a custom provider for a specific agent. Steps:\n1. Create a custom OpenAI client.\n2. Create a `Model` that uses the custom client.\n3. Set the `model` on the Agent.\nNote that in this example, we disable tracing under the assumption that you don't have an API key",
        "detail": "examples.model_providers.custom_example_agent",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "examples.model_providers.custom_example_agent",
        "description": "examples.model_providers.custom_example_agent",
        "peekOfCode": "client = AsyncOpenAI(base_url=BASE_URL, api_key=API_KEY)\nset_tracing_disabled(disabled=True)\n# An alternate approach that would also work:\n# PROVIDER = OpenAIProvider(openai_client=client)\n# agent = Agent(..., model=\"some-custom-model\")\n# Runner.run(agent, ..., run_config=RunConfig(model_provider=PROVIDER))\n@function_tool\ndef get_weather(city: str):\n    print(f\"[debug] getting weather for {city}\")\n    return f\"The weather in {city} is sunny.\"",
        "detail": "examples.model_providers.custom_example_agent",
        "documentation": {}
    },
    {
        "label": "get_weather",
        "kind": 2,
        "importPath": "examples.model_providers.custom_example_global",
        "description": "examples.model_providers.custom_example_global",
        "peekOfCode": "def get_weather(city: str):\n    print(f\"[debug] getting weather for {city}\")\n    return f\"The weather in {city} is sunny.\"\nasync def main():\n    agent = Agent(\n        name=\"Assistant\",\n        instructions=\"You only respond in haikus.\",\n        model=MODEL_NAME,\n        tools=[get_weather],\n    )",
        "detail": "examples.model_providers.custom_example_global",
        "documentation": {}
    },
    {
        "label": "BASE_URL",
        "kind": 5,
        "importPath": "examples.model_providers.custom_example_global",
        "description": "examples.model_providers.custom_example_global",
        "peekOfCode": "BASE_URL = os.getenv(\"EXAMPLE_BASE_URL\") or \"\"\nAPI_KEY = os.getenv(\"EXAMPLE_API_KEY\") or \"\"\nMODEL_NAME = os.getenv(\"EXAMPLE_MODEL_NAME\") or \"\"\nif not BASE_URL or not API_KEY or not MODEL_NAME:\n    raise ValueError(\n        \"Please set EXAMPLE_BASE_URL, EXAMPLE_API_KEY, EXAMPLE_MODEL_NAME via env var or code.\"\n    )\n\"\"\"This example uses a custom provider for all requests by default. We do three things:\n1. Create a custom client.\n2. Set it as the default OpenAI client, and don't use it for tracing.",
        "detail": "examples.model_providers.custom_example_global",
        "documentation": {}
    },
    {
        "label": "API_KEY",
        "kind": 5,
        "importPath": "examples.model_providers.custom_example_global",
        "description": "examples.model_providers.custom_example_global",
        "peekOfCode": "API_KEY = os.getenv(\"EXAMPLE_API_KEY\") or \"\"\nMODEL_NAME = os.getenv(\"EXAMPLE_MODEL_NAME\") or \"\"\nif not BASE_URL or not API_KEY or not MODEL_NAME:\n    raise ValueError(\n        \"Please set EXAMPLE_BASE_URL, EXAMPLE_API_KEY, EXAMPLE_MODEL_NAME via env var or code.\"\n    )\n\"\"\"This example uses a custom provider for all requests by default. We do three things:\n1. Create a custom client.\n2. Set it as the default OpenAI client, and don't use it for tracing.\n3. Set the default API as Chat Completions, as most LLM providers don't yet support Responses API.",
        "detail": "examples.model_providers.custom_example_global",
        "documentation": {}
    },
    {
        "label": "MODEL_NAME",
        "kind": 5,
        "importPath": "examples.model_providers.custom_example_global",
        "description": "examples.model_providers.custom_example_global",
        "peekOfCode": "MODEL_NAME = os.getenv(\"EXAMPLE_MODEL_NAME\") or \"\"\nif not BASE_URL or not API_KEY or not MODEL_NAME:\n    raise ValueError(\n        \"Please set EXAMPLE_BASE_URL, EXAMPLE_API_KEY, EXAMPLE_MODEL_NAME via env var or code.\"\n    )\n\"\"\"This example uses a custom provider for all requests by default. We do three things:\n1. Create a custom client.\n2. Set it as the default OpenAI client, and don't use it for tracing.\n3. Set the default API as Chat Completions, as most LLM providers don't yet support Responses API.\nNote that in this example, we disable tracing under the assumption that you don't have an API key",
        "detail": "examples.model_providers.custom_example_global",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "examples.model_providers.custom_example_global",
        "description": "examples.model_providers.custom_example_global",
        "peekOfCode": "client = AsyncOpenAI(\n    base_url=BASE_URL,\n    api_key=API_KEY,\n)\nset_default_openai_client(client=client, use_for_tracing=False)\nset_default_openai_api(\"chat_completions\")\nset_tracing_disabled(disabled=True)\n@function_tool\ndef get_weather(city: str):\n    print(f\"[debug] getting weather for {city}\")",
        "detail": "examples.model_providers.custom_example_global",
        "documentation": {}
    },
    {
        "label": "CustomModelProvider",
        "kind": 6,
        "importPath": "examples.model_providers.custom_example_provider",
        "description": "examples.model_providers.custom_example_provider",
        "peekOfCode": "class CustomModelProvider(ModelProvider):\n    def get_model(self, model_name: str | None) -> Model:\n        return OpenAIChatCompletionsModel(model=model_name or MODEL_NAME, openai_client=client)\nCUSTOM_MODEL_PROVIDER = CustomModelProvider()\n@function_tool\ndef get_weather(city: str):\n    print(f\"[debug] getting weather for {city}\")\n    return f\"The weather in {city} is sunny.\"\nasync def main():\n    agent = Agent(name=\"Assistant\", instructions=\"You only respond in haikus.\", tools=[get_weather])",
        "detail": "examples.model_providers.custom_example_provider",
        "documentation": {}
    },
    {
        "label": "get_weather",
        "kind": 2,
        "importPath": "examples.model_providers.custom_example_provider",
        "description": "examples.model_providers.custom_example_provider",
        "peekOfCode": "def get_weather(city: str):\n    print(f\"[debug] getting weather for {city}\")\n    return f\"The weather in {city} is sunny.\"\nasync def main():\n    agent = Agent(name=\"Assistant\", instructions=\"You only respond in haikus.\", tools=[get_weather])\n    # This will use the custom model provider\n    result = await Runner.run(\n        agent,\n        \"What's the weather in Tokyo?\",\n        run_config=RunConfig(model_provider=CUSTOM_MODEL_PROVIDER),",
        "detail": "examples.model_providers.custom_example_provider",
        "documentation": {}
    },
    {
        "label": "BASE_URL",
        "kind": 5,
        "importPath": "examples.model_providers.custom_example_provider",
        "description": "examples.model_providers.custom_example_provider",
        "peekOfCode": "BASE_URL = os.getenv(\"EXAMPLE_BASE_URL\") or \"\"\nAPI_KEY = os.getenv(\"EXAMPLE_API_KEY\") or \"\"\nMODEL_NAME = os.getenv(\"EXAMPLE_MODEL_NAME\") or \"\"\nif not BASE_URL or not API_KEY or not MODEL_NAME:\n    raise ValueError(\n        \"Please set EXAMPLE_BASE_URL, EXAMPLE_API_KEY, EXAMPLE_MODEL_NAME via env var or code.\"\n    )\n\"\"\"This example uses a custom provider for some calls to Runner.run(), and direct calls to OpenAI for\nothers. Steps:\n1. Create a custom OpenAI client.",
        "detail": "examples.model_providers.custom_example_provider",
        "documentation": {}
    },
    {
        "label": "API_KEY",
        "kind": 5,
        "importPath": "examples.model_providers.custom_example_provider",
        "description": "examples.model_providers.custom_example_provider",
        "peekOfCode": "API_KEY = os.getenv(\"EXAMPLE_API_KEY\") or \"\"\nMODEL_NAME = os.getenv(\"EXAMPLE_MODEL_NAME\") or \"\"\nif not BASE_URL or not API_KEY or not MODEL_NAME:\n    raise ValueError(\n        \"Please set EXAMPLE_BASE_URL, EXAMPLE_API_KEY, EXAMPLE_MODEL_NAME via env var or code.\"\n    )\n\"\"\"This example uses a custom provider for some calls to Runner.run(), and direct calls to OpenAI for\nothers. Steps:\n1. Create a custom OpenAI client.\n2. Create a ModelProvider that uses the custom client.",
        "detail": "examples.model_providers.custom_example_provider",
        "documentation": {}
    },
    {
        "label": "MODEL_NAME",
        "kind": 5,
        "importPath": "examples.model_providers.custom_example_provider",
        "description": "examples.model_providers.custom_example_provider",
        "peekOfCode": "MODEL_NAME = os.getenv(\"EXAMPLE_MODEL_NAME\") or \"\"\nif not BASE_URL or not API_KEY or not MODEL_NAME:\n    raise ValueError(\n        \"Please set EXAMPLE_BASE_URL, EXAMPLE_API_KEY, EXAMPLE_MODEL_NAME via env var or code.\"\n    )\n\"\"\"This example uses a custom provider for some calls to Runner.run(), and direct calls to OpenAI for\nothers. Steps:\n1. Create a custom OpenAI client.\n2. Create a ModelProvider that uses the custom client.\n3. Use the ModelProvider in calls to Runner.run(), only when we want to use the custom LLM provider.",
        "detail": "examples.model_providers.custom_example_provider",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "examples.model_providers.custom_example_provider",
        "description": "examples.model_providers.custom_example_provider",
        "peekOfCode": "client = AsyncOpenAI(base_url=BASE_URL, api_key=API_KEY)\nset_tracing_disabled(disabled=True)\nclass CustomModelProvider(ModelProvider):\n    def get_model(self, model_name: str | None) -> Model:\n        return OpenAIChatCompletionsModel(model=model_name or MODEL_NAME, openai_client=client)\nCUSTOM_MODEL_PROVIDER = CustomModelProvider()\n@function_tool\ndef get_weather(city: str):\n    print(f\"[debug] getting weather for {city}\")\n    return f\"The weather in {city} is sunny.\"",
        "detail": "examples.model_providers.custom_example_provider",
        "documentation": {}
    },
    {
        "label": "CUSTOM_MODEL_PROVIDER",
        "kind": 5,
        "importPath": "examples.model_providers.custom_example_provider",
        "description": "examples.model_providers.custom_example_provider",
        "peekOfCode": "CUSTOM_MODEL_PROVIDER = CustomModelProvider()\n@function_tool\ndef get_weather(city: str):\n    print(f\"[debug] getting weather for {city}\")\n    return f\"The weather in {city} is sunny.\"\nasync def main():\n    agent = Agent(name=\"Assistant\", instructions=\"You only respond in haikus.\", tools=[get_weather])\n    # This will use the custom model provider\n    result = await Runner.run(\n        agent,",
        "detail": "examples.model_providers.custom_example_provider",
        "documentation": {}
    },
    {
        "label": "WebSearchItem",
        "kind": 6,
        "importPath": "examples.research_bot.agents.planner_agent",
        "description": "examples.research_bot.agents.planner_agent",
        "peekOfCode": "class WebSearchItem(BaseModel):\n    reason: str\n    \"Your reasoning for why this search is important to the query.\"\n    query: str\n    \"The search term to use for the web search.\"\nclass WebSearchPlan(BaseModel):\n    searches: list[WebSearchItem]\n    \"\"\"A list of web searches to perform to best answer the query.\"\"\"\nplanner_agent = Agent(\n    name=\"PlannerAgent\",",
        "detail": "examples.research_bot.agents.planner_agent",
        "documentation": {}
    },
    {
        "label": "WebSearchPlan",
        "kind": 6,
        "importPath": "examples.research_bot.agents.planner_agent",
        "description": "examples.research_bot.agents.planner_agent",
        "peekOfCode": "class WebSearchPlan(BaseModel):\n    searches: list[WebSearchItem]\n    \"\"\"A list of web searches to perform to best answer the query.\"\"\"\nplanner_agent = Agent(\n    name=\"PlannerAgent\",\n    instructions=PROMPT,\n    model=\"gpt-4o\",\n    output_type=WebSearchPlan,\n)",
        "detail": "examples.research_bot.agents.planner_agent",
        "documentation": {}
    },
    {
        "label": "PROMPT",
        "kind": 5,
        "importPath": "examples.research_bot.agents.planner_agent",
        "description": "examples.research_bot.agents.planner_agent",
        "peekOfCode": "PROMPT = (\n    \"You are a helpful research assistant. Given a query, come up with a set of web searches \"\n    \"to perform to best answer the query. Output between 5 and 20 terms to query for.\"\n)\nclass WebSearchItem(BaseModel):\n    reason: str\n    \"Your reasoning for why this search is important to the query.\"\n    query: str\n    \"The search term to use for the web search.\"\nclass WebSearchPlan(BaseModel):",
        "detail": "examples.research_bot.agents.planner_agent",
        "documentation": {}
    },
    {
        "label": "planner_agent",
        "kind": 5,
        "importPath": "examples.research_bot.agents.planner_agent",
        "description": "examples.research_bot.agents.planner_agent",
        "peekOfCode": "planner_agent = Agent(\n    name=\"PlannerAgent\",\n    instructions=PROMPT,\n    model=\"gpt-4o\",\n    output_type=WebSearchPlan,\n)",
        "detail": "examples.research_bot.agents.planner_agent",
        "documentation": {}
    },
    {
        "label": "INSTRUCTIONS",
        "kind": 5,
        "importPath": "examples.research_bot.agents.search_agent",
        "description": "examples.research_bot.agents.search_agent",
        "peekOfCode": "INSTRUCTIONS = (\n    \"You are a research assistant. Given a search term, you search the web for that term and\"\n    \"produce a concise summary of the results. The summary must 2-3 paragraphs and less than 300\"\n    \"words. Capture the main points. Write succintly, no need to have complete sentences or good\"\n    \"grammar. This will be consumed by someone synthesizing a report, so its vital you capture the\"\n    \"essence and ignore any fluff. Do not include any additional commentary other than the summary\"\n    \"itself.\"\n)\nsearch_agent = Agent(\n    name=\"Search agent\",",
        "detail": "examples.research_bot.agents.search_agent",
        "documentation": {}
    },
    {
        "label": "search_agent",
        "kind": 5,
        "importPath": "examples.research_bot.agents.search_agent",
        "description": "examples.research_bot.agents.search_agent",
        "peekOfCode": "search_agent = Agent(\n    name=\"Search agent\",\n    instructions=INSTRUCTIONS,\n    tools=[WebSearchTool()],\n    model_settings=ModelSettings(tool_choice=\"required\"),\n)",
        "detail": "examples.research_bot.agents.search_agent",
        "documentation": {}
    },
    {
        "label": "ReportData",
        "kind": 6,
        "importPath": "examples.research_bot.agents.writer_agent",
        "description": "examples.research_bot.agents.writer_agent",
        "peekOfCode": "class ReportData(BaseModel):\n    short_summary: str\n    \"\"\"A short 2-3 sentence summary of the findings.\"\"\"\n    markdown_report: str\n    \"\"\"The final report\"\"\"\n    follow_up_questions: list[str]\n    \"\"\"Suggested topics to research further\"\"\"\nwriter_agent = Agent(\n    name=\"WriterAgent\",\n    instructions=PROMPT,",
        "detail": "examples.research_bot.agents.writer_agent",
        "documentation": {}
    },
    {
        "label": "PROMPT",
        "kind": 5,
        "importPath": "examples.research_bot.agents.writer_agent",
        "description": "examples.research_bot.agents.writer_agent",
        "peekOfCode": "PROMPT = (\n    \"You are a senior researcher tasked with writing a cohesive report for a research query. \"\n    \"You will be provided with the original query, and some initial research done by a research \"\n    \"assistant.\\n\"\n    \"You should first come up with an outline for the report that describes the structure and \"\n    \"flow of the report. Then, generate the report and return that as your final output.\\n\"\n    \"The final output should be in markdown format, and it should be lengthy and detailed. Aim \"\n    \"for 5-10 pages of content, at least 1000 words.\"\n)\nclass ReportData(BaseModel):",
        "detail": "examples.research_bot.agents.writer_agent",
        "documentation": {}
    },
    {
        "label": "writer_agent",
        "kind": 5,
        "importPath": "examples.research_bot.agents.writer_agent",
        "description": "examples.research_bot.agents.writer_agent",
        "peekOfCode": "writer_agent = Agent(\n    name=\"WriterAgent\",\n    instructions=PROMPT,\n    model=\"o3-mini\",\n    output_type=ReportData,\n)",
        "detail": "examples.research_bot.agents.writer_agent",
        "documentation": {}
    },
    {
        "label": "ResearchManager",
        "kind": 6,
        "importPath": "examples.research_bot.manager",
        "description": "examples.research_bot.manager",
        "peekOfCode": "class ResearchManager:\n    def __init__(self):\n        self.console = Console()\n        self.printer = Printer(self.console)\n    async def run(self, query: str) -> None:\n        trace_id = gen_trace_id()\n        with trace(\"Research trace\", trace_id=trace_id):\n            self.printer.update_item(\n                \"trace_id\",\n                f\"View trace: https://platform.openai.com/traces/{trace_id}\",",
        "detail": "examples.research_bot.manager",
        "documentation": {}
    },
    {
        "label": "Printer",
        "kind": 6,
        "importPath": "examples.research_bot.printer",
        "description": "examples.research_bot.printer",
        "peekOfCode": "class Printer:\n    def __init__(self, console: Console):\n        self.live = Live(console=console)\n        self.items: dict[str, tuple[str, bool]] = {}\n        self.hide_done_ids: set[str] = set()\n        self.live.start()\n    def end(self) -> None:\n        self.live.stop()\n    def hide_done_checkmark(self, item_id: str) -> None:\n        self.hide_done_ids.add(item_id)",
        "detail": "examples.research_bot.printer",
        "documentation": {}
    },
    {
        "label": "LocalPlaywrightComputer",
        "kind": 6,
        "importPath": "examples.tools.computer_use",
        "description": "examples.tools.computer_use",
        "peekOfCode": "class LocalPlaywrightComputer(AsyncComputer):\n    \"\"\"A computer, implemented using a local Playwright browser.\"\"\"\n    def __init__(self):\n        self._playwright: Union[Playwright, None] = None\n        self._browser: Union[Browser, None] = None\n        self._page: Union[Page, None] = None\n    async def _get_browser_and_page(self) -> tuple[Browser, Page]:\n        width, height = self.dimensions\n        launch_args = [f\"--window-size={width},{height}\"]\n        browser = await self.playwright.chromium.launch(headless=False, args=launch_args)",
        "detail": "examples.tools.computer_use",
        "documentation": {}
    },
    {
        "label": "CUA_KEY_TO_PLAYWRIGHT_KEY",
        "kind": 5,
        "importPath": "examples.tools.computer_use",
        "description": "examples.tools.computer_use",
        "peekOfCode": "CUA_KEY_TO_PLAYWRIGHT_KEY = {\n    \"/\": \"Divide\",\n    \"\\\\\": \"Backslash\",\n    \"alt\": \"Alt\",\n    \"arrowdown\": \"ArrowDown\",\n    \"arrowleft\": \"ArrowLeft\",\n    \"arrowright\": \"ArrowRight\",\n    \"arrowup\": \"ArrowUp\",\n    \"backspace\": \"Backspace\",\n    \"capslock\": \"CapsLock\",",
        "detail": "examples.tools.computer_use",
        "documentation": {}
    },
    {
        "label": "remove_all_tools",
        "kind": 2,
        "importPath": "src.agents.extensions.handoff_filters",
        "description": "src.agents.extensions.handoff_filters",
        "peekOfCode": "def remove_all_tools(handoff_input_data: HandoffInputData) -> HandoffInputData:\n    \"\"\"Filters out all tool items: file search, web search and function calls+output.\"\"\"\n    history = handoff_input_data.input_history\n    new_items = handoff_input_data.new_items\n    filtered_history = (\n        _remove_tool_types_from_input(history) if isinstance(history, tuple) else history\n    )\n    filtered_pre_handoff_items = _remove_tools_from_items(handoff_input_data.pre_handoff_items)\n    filtered_new_items = _remove_tools_from_items(new_items)\n    return HandoffInputData(",
        "detail": "src.agents.extensions.handoff_filters",
        "documentation": {}
    },
    {
        "label": "prompt_with_handoff_instructions",
        "kind": 2,
        "importPath": "src.agents.extensions.handoff_prompt",
        "description": "src.agents.extensions.handoff_prompt",
        "peekOfCode": "def prompt_with_handoff_instructions(prompt: str) -> str:\n    \"\"\"\n    Add recommended instructions to the prompt for agents that use handoffs.\n    \"\"\"\n    return f\"{RECOMMENDED_PROMPT_PREFIX}\\n\\n{prompt}\"",
        "detail": "src.agents.extensions.handoff_prompt",
        "documentation": {}
    },
    {
        "label": "RECOMMENDED_PROMPT_PREFIX",
        "kind": 5,
        "importPath": "src.agents.extensions.handoff_prompt",
        "description": "src.agents.extensions.handoff_prompt",
        "peekOfCode": "RECOMMENDED_PROMPT_PREFIX = (\n    \"# System context\\n\"\n    \"You are part of a multi-agent system called the Agents SDK, designed to make agent \"\n    \"coordination and execution easy. Agents uses two primary abstraction: **Agents** and \"\n    \"**Handoffs**. An agent encompasses instructions and tools and can hand off a \"\n    \"conversation to another agent when appropriate. \"\n    \"Handoffs are achieved by calling a handoff function, generally named \"\n    \"`transfer_to_<agent_name>`. Transfers between agents are handled seamlessly in the background;\"\n    \" do not mention or draw attention to these transfers in your conversation with the user.\\n\"\n)",
        "detail": "src.agents.extensions.handoff_prompt",
        "documentation": {}
    },
    {
        "label": "set_default_openai_key",
        "kind": 2,
        "importPath": "src.agents.models._openai_shared",
        "description": "src.agents.models._openai_shared",
        "peekOfCode": "def set_default_openai_key(key: str) -> None:\n    global _default_openai_key\n    _default_openai_key = key\ndef get_default_openai_key() -> str | None:\n    return _default_openai_key\ndef set_default_openai_client(client: AsyncOpenAI) -> None:\n    global _default_openai_client\n    _default_openai_client = client\ndef get_default_openai_client() -> AsyncOpenAI | None:\n    return _default_openai_client",
        "detail": "src.agents.models._openai_shared",
        "documentation": {}
    },
    {
        "label": "get_default_openai_key",
        "kind": 2,
        "importPath": "src.agents.models._openai_shared",
        "description": "src.agents.models._openai_shared",
        "peekOfCode": "def get_default_openai_key() -> str | None:\n    return _default_openai_key\ndef set_default_openai_client(client: AsyncOpenAI) -> None:\n    global _default_openai_client\n    _default_openai_client = client\ndef get_default_openai_client() -> AsyncOpenAI | None:\n    return _default_openai_client\ndef set_use_responses_by_default(use_responses: bool) -> None:\n    global _use_responses_by_default\n    _use_responses_by_default = use_responses",
        "detail": "src.agents.models._openai_shared",
        "documentation": {}
    },
    {
        "label": "set_default_openai_client",
        "kind": 2,
        "importPath": "src.agents.models._openai_shared",
        "description": "src.agents.models._openai_shared",
        "peekOfCode": "def set_default_openai_client(client: AsyncOpenAI) -> None:\n    global _default_openai_client\n    _default_openai_client = client\ndef get_default_openai_client() -> AsyncOpenAI | None:\n    return _default_openai_client\ndef set_use_responses_by_default(use_responses: bool) -> None:\n    global _use_responses_by_default\n    _use_responses_by_default = use_responses\ndef get_use_responses_by_default() -> bool:\n    return _use_responses_by_default",
        "detail": "src.agents.models._openai_shared",
        "documentation": {}
    },
    {
        "label": "get_default_openai_client",
        "kind": 2,
        "importPath": "src.agents.models._openai_shared",
        "description": "src.agents.models._openai_shared",
        "peekOfCode": "def get_default_openai_client() -> AsyncOpenAI | None:\n    return _default_openai_client\ndef set_use_responses_by_default(use_responses: bool) -> None:\n    global _use_responses_by_default\n    _use_responses_by_default = use_responses\ndef get_use_responses_by_default() -> bool:\n    return _use_responses_by_default",
        "detail": "src.agents.models._openai_shared",
        "documentation": {}
    },
    {
        "label": "set_use_responses_by_default",
        "kind": 2,
        "importPath": "src.agents.models._openai_shared",
        "description": "src.agents.models._openai_shared",
        "peekOfCode": "def set_use_responses_by_default(use_responses: bool) -> None:\n    global _use_responses_by_default\n    _use_responses_by_default = use_responses\ndef get_use_responses_by_default() -> bool:\n    return _use_responses_by_default",
        "detail": "src.agents.models._openai_shared",
        "documentation": {}
    },
    {
        "label": "get_use_responses_by_default",
        "kind": 2,
        "importPath": "src.agents.models._openai_shared",
        "description": "src.agents.models._openai_shared",
        "peekOfCode": "def get_use_responses_by_default() -> bool:\n    return _use_responses_by_default",
        "detail": "src.agents.models._openai_shared",
        "documentation": {}
    },
    {
        "label": "FAKE_RESPONSES_ID",
        "kind": 5,
        "importPath": "src.agents.models.fake_id",
        "description": "src.agents.models.fake_id",
        "peekOfCode": "FAKE_RESPONSES_ID = \"__fake_id__\"\n\"\"\"This is a placeholder ID used to fill in the `id` field in Responses API related objects. It's\nuseful when you're creating Responses objects from non-Responses APIs, e.g. the OpenAI Chat\nCompletions API or other LLM providers.\n\"\"\"",
        "detail": "src.agents.models.fake_id",
        "documentation": {}
    },
    {
        "label": "ModelTracing",
        "kind": 6,
        "importPath": "src.agents.models.interface",
        "description": "src.agents.models.interface",
        "peekOfCode": "class ModelTracing(enum.Enum):\n    DISABLED = 0\n    \"\"\"Tracing is disabled entirely.\"\"\"\n    ENABLED = 1\n    \"\"\"Tracing is enabled, and all data is included.\"\"\"\n    ENABLED_WITHOUT_DATA = 2\n    \"\"\"Tracing is enabled, but inputs/outputs are not included.\"\"\"\n    def is_disabled(self) -> bool:\n        return self == ModelTracing.DISABLED\n    def include_data(self) -> bool:",
        "detail": "src.agents.models.interface",
        "documentation": {}
    },
    {
        "label": "Model",
        "kind": 6,
        "importPath": "src.agents.models.interface",
        "description": "src.agents.models.interface",
        "peekOfCode": "class Model(abc.ABC):\n    \"\"\"The base interface for calling an LLM.\"\"\"\n    @abc.abstractmethod\n    async def get_response(\n        self,\n        system_instructions: str | None,\n        input: str | list[TResponseInputItem],\n        model_settings: ModelSettings,\n        tools: list[Tool],\n        output_schema: AgentOutputSchema | None,",
        "detail": "src.agents.models.interface",
        "documentation": {}
    },
    {
        "label": "ModelProvider",
        "kind": 6,
        "importPath": "src.agents.models.interface",
        "description": "src.agents.models.interface",
        "peekOfCode": "class ModelProvider(abc.ABC):\n    \"\"\"The base interface for a model provider.\n    Model provider is responsible for looking up Models by name.\n    \"\"\"\n    @abc.abstractmethod\n    def get_model(self, model_name: str | None) -> Model:\n        \"\"\"Get a model by name.\n        Args:\n            model_name: The name of the model to get.\n        Returns:",
        "detail": "src.agents.models.interface",
        "documentation": {}
    },
    {
        "label": "_StreamingState",
        "kind": 6,
        "importPath": "src.agents.models.openai_chatcompletions",
        "description": "src.agents.models.openai_chatcompletions",
        "peekOfCode": "class _StreamingState:\n    started: bool = False\n    text_content_index_and_output: tuple[int, ResponseOutputText] | None = None\n    refusal_content_index_and_output: tuple[int, ResponseOutputRefusal] | None = None\n    function_calls: dict[int, ResponseFunctionToolCall] = field(default_factory=dict)\nclass OpenAIChatCompletionsModel(Model):\n    def __init__(\n        self,\n        model: str | ChatModel,\n        openai_client: AsyncOpenAI,",
        "detail": "src.agents.models.openai_chatcompletions",
        "documentation": {}
    },
    {
        "label": "OpenAIChatCompletionsModel",
        "kind": 6,
        "importPath": "src.agents.models.openai_chatcompletions",
        "description": "src.agents.models.openai_chatcompletions",
        "peekOfCode": "class OpenAIChatCompletionsModel(Model):\n    def __init__(\n        self,\n        model: str | ChatModel,\n        openai_client: AsyncOpenAI,\n    ) -> None:\n        self.model = model\n        self._client = openai_client\n    def _non_null_or_not_given(self, value: Any) -> Any:\n        return value if value is not None else NOT_GIVEN",
        "detail": "src.agents.models.openai_chatcompletions",
        "documentation": {}
    },
    {
        "label": "_Converter",
        "kind": 6,
        "importPath": "src.agents.models.openai_chatcompletions",
        "description": "src.agents.models.openai_chatcompletions",
        "peekOfCode": "class _Converter:\n    @classmethod\n    def convert_tool_choice(\n        cls, tool_choice: Literal[\"auto\", \"required\", \"none\"] | str | None\n    ) -> ChatCompletionToolChoiceOptionParam | NotGiven:\n        if tool_choice is None:\n            return NOT_GIVEN\n        elif tool_choice == \"auto\":\n            return \"auto\"\n        elif tool_choice == \"required\":",
        "detail": "src.agents.models.openai_chatcompletions",
        "documentation": {}
    },
    {
        "label": "ToolConverter",
        "kind": 6,
        "importPath": "src.agents.models.openai_chatcompletions",
        "description": "src.agents.models.openai_chatcompletions",
        "peekOfCode": "class ToolConverter:\n    @classmethod\n    def to_openai(cls, tool: Tool) -> ChatCompletionToolParam:\n        if isinstance(tool, FunctionTool):\n            return {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": tool.name,\n                    \"description\": tool.description or \"\",\n                    \"parameters\": tool.params_json_schema,",
        "detail": "src.agents.models.openai_chatcompletions",
        "documentation": {}
    },
    {
        "label": "_USER_AGENT",
        "kind": 5,
        "importPath": "src.agents.models.openai_chatcompletions",
        "description": "src.agents.models.openai_chatcompletions",
        "peekOfCode": "_USER_AGENT = f\"Agents/Python {__version__}\"\n_HEADERS = {\"User-Agent\": _USER_AGENT}\n@dataclass\nclass _StreamingState:\n    started: bool = False\n    text_content_index_and_output: tuple[int, ResponseOutputText] | None = None\n    refusal_content_index_and_output: tuple[int, ResponseOutputRefusal] | None = None\n    function_calls: dict[int, ResponseFunctionToolCall] = field(default_factory=dict)\nclass OpenAIChatCompletionsModel(Model):\n    def __init__(",
        "detail": "src.agents.models.openai_chatcompletions",
        "documentation": {}
    },
    {
        "label": "_HEADERS",
        "kind": 5,
        "importPath": "src.agents.models.openai_chatcompletions",
        "description": "src.agents.models.openai_chatcompletions",
        "peekOfCode": "_HEADERS = {\"User-Agent\": _USER_AGENT}\n@dataclass\nclass _StreamingState:\n    started: bool = False\n    text_content_index_and_output: tuple[int, ResponseOutputText] | None = None\n    refusal_content_index_and_output: tuple[int, ResponseOutputRefusal] | None = None\n    function_calls: dict[int, ResponseFunctionToolCall] = field(default_factory=dict)\nclass OpenAIChatCompletionsModel(Model):\n    def __init__(\n        self,",
        "detail": "src.agents.models.openai_chatcompletions",
        "documentation": {}
    },
    {
        "label": "OpenAIProvider",
        "kind": 6,
        "importPath": "src.agents.models.openai_provider",
        "description": "src.agents.models.openai_provider",
        "peekOfCode": "class OpenAIProvider(ModelProvider):\n    def __init__(\n        self,\n        *,\n        api_key: str | None = None,\n        base_url: str | None = None,\n        openai_client: AsyncOpenAI | None = None,\n        organization: str | None = None,\n        project: str | None = None,\n        use_responses: bool | None = None,",
        "detail": "src.agents.models.openai_provider",
        "documentation": {}
    },
    {
        "label": "shared_http_client",
        "kind": 2,
        "importPath": "src.agents.models.openai_provider",
        "description": "src.agents.models.openai_provider",
        "peekOfCode": "def shared_http_client() -> httpx.AsyncClient:\n    global _http_client\n    if _http_client is None:\n        _http_client = DefaultAsyncHttpxClient()\n    return _http_client\nclass OpenAIProvider(ModelProvider):\n    def __init__(\n        self,\n        *,\n        api_key: str | None = None,",
        "detail": "src.agents.models.openai_provider",
        "documentation": {}
    },
    {
        "label": "OpenAIResponsesModel",
        "kind": 6,
        "importPath": "src.agents.models.openai_responses",
        "description": "src.agents.models.openai_responses",
        "peekOfCode": "class OpenAIResponsesModel(Model):\n    \"\"\"\n    Implementation of `Model` that uses the OpenAI Responses API.\n    \"\"\"\n    def __init__(\n        self,\n        model: str | ChatModel,\n        openai_client: AsyncOpenAI,\n    ) -> None:\n        self.model = model",
        "detail": "src.agents.models.openai_responses",
        "documentation": {}
    },
    {
        "label": "ConvertedTools",
        "kind": 6,
        "importPath": "src.agents.models.openai_responses",
        "description": "src.agents.models.openai_responses",
        "peekOfCode": "class ConvertedTools:\n    tools: list[ToolParam]\n    includes: list[IncludeLiteral]\nclass Converter:\n    @classmethod\n    def convert_tool_choice(\n        cls, tool_choice: Literal[\"auto\", \"required\", \"none\"] | str | None\n    ) -> response_create_params.ToolChoice | NotGiven:\n        if tool_choice is None:\n            return NOT_GIVEN",
        "detail": "src.agents.models.openai_responses",
        "documentation": {}
    },
    {
        "label": "Converter",
        "kind": 6,
        "importPath": "src.agents.models.openai_responses",
        "description": "src.agents.models.openai_responses",
        "peekOfCode": "class Converter:\n    @classmethod\n    def convert_tool_choice(\n        cls, tool_choice: Literal[\"auto\", \"required\", \"none\"] | str | None\n    ) -> response_create_params.ToolChoice | NotGiven:\n        if tool_choice is None:\n            return NOT_GIVEN\n        elif tool_choice == \"required\":\n            return \"required\"\n        elif tool_choice == \"auto\":",
        "detail": "src.agents.models.openai_responses",
        "documentation": {}
    },
    {
        "label": "_USER_AGENT",
        "kind": 5,
        "importPath": "src.agents.models.openai_responses",
        "description": "src.agents.models.openai_responses",
        "peekOfCode": "_USER_AGENT = f\"Agents/Python {__version__}\"\n_HEADERS = {\"User-Agent\": _USER_AGENT}\n# From the Responses API\nIncludeLiteral = Literal[\n    \"file_search_call.results\",\n    \"message.input_image.image_url\",\n    \"computer_call_output.output.image_url\",\n]\nclass OpenAIResponsesModel(Model):\n    \"\"\"",
        "detail": "src.agents.models.openai_responses",
        "documentation": {}
    },
    {
        "label": "_HEADERS",
        "kind": 5,
        "importPath": "src.agents.models.openai_responses",
        "description": "src.agents.models.openai_responses",
        "peekOfCode": "_HEADERS = {\"User-Agent\": _USER_AGENT}\n# From the Responses API\nIncludeLiteral = Literal[\n    \"file_search_call.results\",\n    \"message.input_image.image_url\",\n    \"computer_call_output.output.image_url\",\n]\nclass OpenAIResponsesModel(Model):\n    \"\"\"\n    Implementation of `Model` that uses the OpenAI Responses API.",
        "detail": "src.agents.models.openai_responses",
        "documentation": {}
    },
    {
        "label": "IncludeLiteral",
        "kind": 5,
        "importPath": "src.agents.models.openai_responses",
        "description": "src.agents.models.openai_responses",
        "peekOfCode": "IncludeLiteral = Literal[\n    \"file_search_call.results\",\n    \"message.input_image.image_url\",\n    \"computer_call_output.output.image_url\",\n]\nclass OpenAIResponsesModel(Model):\n    \"\"\"\n    Implementation of `Model` that uses the OpenAI Responses API.\n    \"\"\"\n    def __init__(",
        "detail": "src.agents.models.openai_responses",
        "documentation": {}
    },
    {
        "label": "trace",
        "kind": 2,
        "importPath": "src.agents.tracing.create",
        "description": "src.agents.tracing.create",
        "peekOfCode": "def trace(\n    workflow_name: str,\n    trace_id: str | None = None,\n    group_id: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    disabled: bool = False,\n) -> Trace:\n    \"\"\"\n    Create a new trace. The trace will not be started automatically; you should either use\n    it as a context manager (`with trace(...):`) or call `trace.start()` + `trace.finish()`",
        "detail": "src.agents.tracing.create",
        "documentation": {}
    },
    {
        "label": "get_current_trace",
        "kind": 2,
        "importPath": "src.agents.tracing.create",
        "description": "src.agents.tracing.create",
        "peekOfCode": "def get_current_trace() -> Trace | None:\n    \"\"\"Returns the currently active trace, if present.\"\"\"\n    return GLOBAL_TRACE_PROVIDER.get_current_trace()\ndef get_current_span() -> Span[Any] | None:\n    \"\"\"Returns the currently active span, if present.\"\"\"\n    return GLOBAL_TRACE_PROVIDER.get_current_span()\ndef agent_span(\n    name: str,\n    handoffs: list[str] | None = None,\n    tools: list[str] | None = None,",
        "detail": "src.agents.tracing.create",
        "documentation": {}
    },
    {
        "label": "get_current_span",
        "kind": 2,
        "importPath": "src.agents.tracing.create",
        "description": "src.agents.tracing.create",
        "peekOfCode": "def get_current_span() -> Span[Any] | None:\n    \"\"\"Returns the currently active span, if present.\"\"\"\n    return GLOBAL_TRACE_PROVIDER.get_current_span()\ndef agent_span(\n    name: str,\n    handoffs: list[str] | None = None,\n    tools: list[str] | None = None,\n    output_type: str | None = None,\n    span_id: str | None = None,\n    parent: Trace | Span[Any] | None = None,",
        "detail": "src.agents.tracing.create",
        "documentation": {}
    },
    {
        "label": "agent_span",
        "kind": 2,
        "importPath": "src.agents.tracing.create",
        "description": "src.agents.tracing.create",
        "peekOfCode": "def agent_span(\n    name: str,\n    handoffs: list[str] | None = None,\n    tools: list[str] | None = None,\n    output_type: str | None = None,\n    span_id: str | None = None,\n    parent: Trace | Span[Any] | None = None,\n    disabled: bool = False,\n) -> Span[AgentSpanData]:\n    \"\"\"Create a new agent span. The span will not be started automatically, you should either do",
        "detail": "src.agents.tracing.create",
        "documentation": {}
    },
    {
        "label": "function_span",
        "kind": 2,
        "importPath": "src.agents.tracing.create",
        "description": "src.agents.tracing.create",
        "peekOfCode": "def function_span(\n    name: str,\n    input: str | None = None,\n    output: str | None = None,\n    span_id: str | None = None,\n    parent: Trace | Span[Any] | None = None,\n    disabled: bool = False,\n) -> Span[FunctionSpanData]:\n    \"\"\"Create a new function span. The span will not be started automatically, you should either do\n    `with function_span() ...` or call `span.start()` + `span.finish()` manually.",
        "detail": "src.agents.tracing.create",
        "documentation": {}
    },
    {
        "label": "generation_span",
        "kind": 2,
        "importPath": "src.agents.tracing.create",
        "description": "src.agents.tracing.create",
        "peekOfCode": "def generation_span(\n    input: Sequence[Mapping[str, Any]] | None = None,\n    output: Sequence[Mapping[str, Any]] | None = None,\n    model: str | None = None,\n    model_config: Mapping[str, Any] | None = None,\n    usage: dict[str, Any] | None = None,\n    span_id: str | None = None,\n    parent: Trace | Span[Any] | None = None,\n    disabled: bool = False,\n) -> Span[GenerationSpanData]:",
        "detail": "src.agents.tracing.create",
        "documentation": {}
    },
    {
        "label": "response_span",
        "kind": 2,
        "importPath": "src.agents.tracing.create",
        "description": "src.agents.tracing.create",
        "peekOfCode": "def response_span(\n    response: Response | None = None,\n    span_id: str | None = None,\n    parent: Trace | Span[Any] | None = None,\n    disabled: bool = False,\n) -> Span[ResponseSpanData]:\n    \"\"\"Create a new response span. The span will not be started automatically, you should either do\n    `with response_span() ...` or call `span.start()` + `span.finish()` manually.\n    Args:\n        response: The OpenAI Response object.",
        "detail": "src.agents.tracing.create",
        "documentation": {}
    },
    {
        "label": "handoff_span",
        "kind": 2,
        "importPath": "src.agents.tracing.create",
        "description": "src.agents.tracing.create",
        "peekOfCode": "def handoff_span(\n    from_agent: str | None = None,\n    to_agent: str | None = None,\n    span_id: str | None = None,\n    parent: Trace | Span[Any] | None = None,\n    disabled: bool = False,\n) -> Span[HandoffSpanData]:\n    \"\"\"Create a new handoff span. The span will not be started automatically, you should either do\n    `with handoff_span() ...` or call `span.start()` + `span.finish()` manually.\n    Args:",
        "detail": "src.agents.tracing.create",
        "documentation": {}
    },
    {
        "label": "custom_span",
        "kind": 2,
        "importPath": "src.agents.tracing.create",
        "description": "src.agents.tracing.create",
        "peekOfCode": "def custom_span(\n    name: str,\n    data: dict[str, Any] | None = None,\n    span_id: str | None = None,\n    parent: Trace | Span[Any] | None = None,\n    disabled: bool = False,\n) -> Span[CustomSpanData]:\n    \"\"\"Create a new custom span, to which you can add your own metadata. The span will not be\n    started automatically, you should either do `with custom_span() ...` or call\n    `span.start()` + `span.finish()` manually.",
        "detail": "src.agents.tracing.create",
        "documentation": {}
    },
    {
        "label": "guardrail_span",
        "kind": 2,
        "importPath": "src.agents.tracing.create",
        "description": "src.agents.tracing.create",
        "peekOfCode": "def guardrail_span(\n    name: str,\n    triggered: bool = False,\n    span_id: str | None = None,\n    parent: Trace | Span[Any] | None = None,\n    disabled: bool = False,\n) -> Span[GuardrailSpanData]:\n    \"\"\"Create a new guardrail span. The span will not be started automatically, you should either\n    do `with guardrail_span() ...` or call `span.start()` + `span.finish()` manually.\n    Args:",
        "detail": "src.agents.tracing.create",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.agents.tracing.logger",
        "description": "src.agents.tracing.logger",
        "peekOfCode": "logger = logging.getLogger(\"openai.agents.tracing\")",
        "detail": "src.agents.tracing.logger",
        "documentation": {}
    },
    {
        "label": "TracingProcessor",
        "kind": 6,
        "importPath": "src.agents.tracing.processor_interface",
        "description": "src.agents.tracing.processor_interface",
        "peekOfCode": "class TracingProcessor(abc.ABC):\n    \"\"\"Interface for processing spans.\"\"\"\n    @abc.abstractmethod\n    def on_trace_start(self, trace: \"Trace\") -> None:\n        \"\"\"Called when a trace is started.\n        Args:\n            trace: The trace that started.\n        \"\"\"\n        pass\n    @abc.abstractmethod",
        "detail": "src.agents.tracing.processor_interface",
        "documentation": {}
    },
    {
        "label": "TracingExporter",
        "kind": 6,
        "importPath": "src.agents.tracing.processor_interface",
        "description": "src.agents.tracing.processor_interface",
        "peekOfCode": "class TracingExporter(abc.ABC):\n    \"\"\"Exports traces and spans. For example, could log them or send them to a backend.\"\"\"\n    @abc.abstractmethod\n    def export(self, items: list[\"Trace | Span[Any]\"]) -> None:\n        \"\"\"Exports a list of traces and spans.\n        Args:\n            items: The items to export.\n        \"\"\"\n        pass",
        "detail": "src.agents.tracing.processor_interface",
        "documentation": {}
    },
    {
        "label": "ConsoleSpanExporter",
        "kind": 6,
        "importPath": "src.agents.tracing.processors",
        "description": "src.agents.tracing.processors",
        "peekOfCode": "class ConsoleSpanExporter(TracingExporter):\n    \"\"\"Prints the traces and spans to the console.\"\"\"\n    def export(self, items: list[Trace | Span[Any]]) -> None:\n        for item in items:\n            if isinstance(item, Trace):\n                print(f\"[Exporter] Export trace_id={item.trace_id}, name={item.name}, \")\n            else:\n                print(f\"[Exporter] Export span: {item.export()}\")\nclass BackendSpanExporter(TracingExporter):\n    def __init__(",
        "detail": "src.agents.tracing.processors",
        "documentation": {}
    },
    {
        "label": "BackendSpanExporter",
        "kind": 6,
        "importPath": "src.agents.tracing.processors",
        "description": "src.agents.tracing.processors",
        "peekOfCode": "class BackendSpanExporter(TracingExporter):\n    def __init__(\n        self,\n        api_key: str | None = None,\n        organization: str | None = None,\n        project: str | None = None,\n        endpoint: str = \"https://api.openai.com/v1/traces/ingest\",\n        max_retries: int = 3,\n        base_delay: float = 1.0,\n        max_delay: float = 30.0,",
        "detail": "src.agents.tracing.processors",
        "documentation": {}
    },
    {
        "label": "BatchTraceProcessor",
        "kind": 6,
        "importPath": "src.agents.tracing.processors",
        "description": "src.agents.tracing.processors",
        "peekOfCode": "class BatchTraceProcessor(TracingProcessor):\n    \"\"\"Some implementation notes:\n    1. Using Queue, which is thread-safe.\n    2. Using a background thread to export spans, to minimize any performance issues.\n    3. Spans are stored in memory until they are exported.\n    \"\"\"\n    def __init__(\n        self,\n        exporter: TracingExporter,\n        max_queue_size: int = 8192,",
        "detail": "src.agents.tracing.processors",
        "documentation": {}
    },
    {
        "label": "default_exporter",
        "kind": 2,
        "importPath": "src.agents.tracing.processors",
        "description": "src.agents.tracing.processors",
        "peekOfCode": "def default_exporter() -> BackendSpanExporter:\n    \"\"\"The default exporter, which exports traces and spans to the backend in batches.\"\"\"\n    return _global_exporter\ndef default_processor() -> BatchTraceProcessor:\n    \"\"\"The default processor, which exports traces and spans to the backend in batches.\"\"\"\n    return _global_processor",
        "detail": "src.agents.tracing.processors",
        "documentation": {}
    },
    {
        "label": "default_processor",
        "kind": 2,
        "importPath": "src.agents.tracing.processors",
        "description": "src.agents.tracing.processors",
        "peekOfCode": "def default_processor() -> BatchTraceProcessor:\n    \"\"\"The default processor, which exports traces and spans to the backend in batches.\"\"\"\n    return _global_processor",
        "detail": "src.agents.tracing.processors",
        "documentation": {}
    },
    {
        "label": "_global_exporter",
        "kind": 5,
        "importPath": "src.agents.tracing.processors",
        "description": "src.agents.tracing.processors",
        "peekOfCode": "_global_exporter = BackendSpanExporter()\n_global_processor = BatchTraceProcessor(_global_exporter)\ndef default_exporter() -> BackendSpanExporter:\n    \"\"\"The default exporter, which exports traces and spans to the backend in batches.\"\"\"\n    return _global_exporter\ndef default_processor() -> BatchTraceProcessor:\n    \"\"\"The default processor, which exports traces and spans to the backend in batches.\"\"\"\n    return _global_processor",
        "detail": "src.agents.tracing.processors",
        "documentation": {}
    },
    {
        "label": "_global_processor",
        "kind": 5,
        "importPath": "src.agents.tracing.processors",
        "description": "src.agents.tracing.processors",
        "peekOfCode": "_global_processor = BatchTraceProcessor(_global_exporter)\ndef default_exporter() -> BackendSpanExporter:\n    \"\"\"The default exporter, which exports traces and spans to the backend in batches.\"\"\"\n    return _global_exporter\ndef default_processor() -> BatchTraceProcessor:\n    \"\"\"The default processor, which exports traces and spans to the backend in batches.\"\"\"\n    return _global_processor",
        "detail": "src.agents.tracing.processors",
        "documentation": {}
    },
    {
        "label": "Scope",
        "kind": 6,
        "importPath": "src.agents.tracing.scope",
        "description": "src.agents.tracing.scope",
        "peekOfCode": "class Scope:\n    @classmethod\n    def get_current_span(cls) -> \"Span[Any] | None\":\n        return _current_span.get()\n    @classmethod\n    def set_current_span(cls, span: \"Span[Any] | None\") -> \"contextvars.Token[Span[Any] | None]\":\n        return _current_span.set(span)\n    @classmethod\n    def reset_current_span(cls, token: \"contextvars.Token[Span[Any] | None]\") -> None:\n        _current_span.reset(token)",
        "detail": "src.agents.tracing.scope",
        "documentation": {}
    },
    {
        "label": "SynchronousMultiTracingProcessor",
        "kind": 6,
        "importPath": "src.agents.tracing.setup",
        "description": "src.agents.tracing.setup",
        "peekOfCode": "class SynchronousMultiTracingProcessor(TracingProcessor):\n    \"\"\"\n    Forwards all calls to a list of TracingProcessors, in order of registration.\n    \"\"\"\n    def __init__(self):\n        # Using a tuple to avoid race conditions when iterating over processors\n        self._processors: tuple[TracingProcessor, ...] = ()\n        self._lock = threading.Lock()\n    def add_tracing_processor(self, tracing_processor: TracingProcessor):\n        \"\"\"",
        "detail": "src.agents.tracing.setup",
        "documentation": {}
    },
    {
        "label": "TraceProvider",
        "kind": 6,
        "importPath": "src.agents.tracing.setup",
        "description": "src.agents.tracing.setup",
        "peekOfCode": "class TraceProvider:\n    def __init__(self):\n        self._multi_processor = SynchronousMultiTracingProcessor()\n        self._disabled = os.environ.get(\"OPENAI_AGENTS_DISABLE_TRACING\", \"false\").lower() in (\n            \"true\",\n            \"1\",\n        )\n    def register_processor(self, processor: TracingProcessor):\n        \"\"\"\n        Add a processor to the list of processors. Each processor will receive all traces/spans.",
        "detail": "src.agents.tracing.setup",
        "documentation": {}
    },
    {
        "label": "GLOBAL_TRACE_PROVIDER",
        "kind": 5,
        "importPath": "src.agents.tracing.setup",
        "description": "src.agents.tracing.setup",
        "peekOfCode": "GLOBAL_TRACE_PROVIDER = TraceProvider()",
        "detail": "src.agents.tracing.setup",
        "documentation": {}
    },
    {
        "label": "SpanData",
        "kind": 6,
        "importPath": "src.agents.tracing.span_data",
        "description": "src.agents.tracing.span_data",
        "peekOfCode": "class SpanData(abc.ABC):\n    @abc.abstractmethod\n    def export(self) -> dict[str, Any]:\n        pass\n    @property\n    @abc.abstractmethod\n    def type(self) -> str:\n        pass\nclass AgentSpanData(SpanData):\n    __slots__ = (\"name\", \"handoffs\", \"tools\", \"output_type\")",
        "detail": "src.agents.tracing.span_data",
        "documentation": {}
    },
    {
        "label": "AgentSpanData",
        "kind": 6,
        "importPath": "src.agents.tracing.span_data",
        "description": "src.agents.tracing.span_data",
        "peekOfCode": "class AgentSpanData(SpanData):\n    __slots__ = (\"name\", \"handoffs\", \"tools\", \"output_type\")\n    def __init__(\n        self,\n        name: str,\n        handoffs: list[str] | None = None,\n        tools: list[str] | None = None,\n        output_type: str | None = None,\n    ):\n        self.name = name",
        "detail": "src.agents.tracing.span_data",
        "documentation": {}
    },
    {
        "label": "FunctionSpanData",
        "kind": 6,
        "importPath": "src.agents.tracing.span_data",
        "description": "src.agents.tracing.span_data",
        "peekOfCode": "class FunctionSpanData(SpanData):\n    __slots__ = (\"name\", \"input\", \"output\")\n    def __init__(self, name: str, input: str | None, output: Any | None):\n        self.name = name\n        self.input = input\n        self.output = output\n    @property\n    def type(self) -> str:\n        return \"function\"\n    def export(self) -> dict[str, Any]:",
        "detail": "src.agents.tracing.span_data",
        "documentation": {}
    },
    {
        "label": "GenerationSpanData",
        "kind": 6,
        "importPath": "src.agents.tracing.span_data",
        "description": "src.agents.tracing.span_data",
        "peekOfCode": "class GenerationSpanData(SpanData):\n    __slots__ = (\n        \"input\",\n        \"output\",\n        \"model\",\n        \"model_config\",\n        \"usage\",\n    )\n    def __init__(\n        self,",
        "detail": "src.agents.tracing.span_data",
        "documentation": {}
    },
    {
        "label": "ResponseSpanData",
        "kind": 6,
        "importPath": "src.agents.tracing.span_data",
        "description": "src.agents.tracing.span_data",
        "peekOfCode": "class ResponseSpanData(SpanData):\n    __slots__ = (\"response\", \"input\")\n    def __init__(\n        self,\n        response: Response | None = None,\n        input: str | list[ResponseInputItemParam] | None = None,\n    ) -> None:\n        self.response = response\n        # This is not used by the OpenAI trace processors, but is useful for other tracing\n        # processor implementations",
        "detail": "src.agents.tracing.span_data",
        "documentation": {}
    },
    {
        "label": "HandoffSpanData",
        "kind": 6,
        "importPath": "src.agents.tracing.span_data",
        "description": "src.agents.tracing.span_data",
        "peekOfCode": "class HandoffSpanData(SpanData):\n    __slots__ = (\"from_agent\", \"to_agent\")\n    def __init__(self, from_agent: str | None, to_agent: str | None):\n        self.from_agent = from_agent\n        self.to_agent = to_agent\n    @property\n    def type(self) -> str:\n        return \"handoff\"\n    def export(self) -> dict[str, Any]:\n        return {",
        "detail": "src.agents.tracing.span_data",
        "documentation": {}
    },
    {
        "label": "CustomSpanData",
        "kind": 6,
        "importPath": "src.agents.tracing.span_data",
        "description": "src.agents.tracing.span_data",
        "peekOfCode": "class CustomSpanData(SpanData):\n    __slots__ = (\"name\", \"data\")\n    def __init__(self, name: str, data: dict[str, Any]):\n        self.name = name\n        self.data = data\n    @property\n    def type(self) -> str:\n        return \"custom\"\n    def export(self) -> dict[str, Any]:\n        return {",
        "detail": "src.agents.tracing.span_data",
        "documentation": {}
    },
    {
        "label": "GuardrailSpanData",
        "kind": 6,
        "importPath": "src.agents.tracing.span_data",
        "description": "src.agents.tracing.span_data",
        "peekOfCode": "class GuardrailSpanData(SpanData):\n    __slots__ = (\"name\", \"triggered\")\n    def __init__(self, name: str, triggered: bool = False):\n        self.name = name\n        self.triggered = triggered\n    @property\n    def type(self) -> str:\n        return \"guardrail\"\n    def export(self) -> dict[str, Any]:\n        return {",
        "detail": "src.agents.tracing.span_data",
        "documentation": {}
    },
    {
        "label": "SpanError",
        "kind": 6,
        "importPath": "src.agents.tracing.spans",
        "description": "src.agents.tracing.spans",
        "peekOfCode": "class SpanError(TypedDict):\n    message: str\n    data: dict[str, Any] | None\nclass Span(abc.ABC, Generic[TSpanData]):\n    @property\n    @abc.abstractmethod\n    def trace_id(self) -> str:\n        pass\n    @property\n    @abc.abstractmethod",
        "detail": "src.agents.tracing.spans",
        "documentation": {}
    },
    {
        "label": "Span",
        "kind": 6,
        "importPath": "src.agents.tracing.spans",
        "description": "src.agents.tracing.spans",
        "peekOfCode": "class Span(abc.ABC, Generic[TSpanData]):\n    @property\n    @abc.abstractmethod\n    def trace_id(self) -> str:\n        pass\n    @property\n    @abc.abstractmethod\n    def span_id(self) -> str:\n        pass\n    @property",
        "detail": "src.agents.tracing.spans",
        "documentation": {}
    },
    {
        "label": "NoOpSpan",
        "kind": 6,
        "importPath": "src.agents.tracing.spans",
        "description": "src.agents.tracing.spans",
        "peekOfCode": "class NoOpSpan(Span[TSpanData]):\n    __slots__ = (\"_span_data\", \"_prev_span_token\")\n    def __init__(self, span_data: TSpanData):\n        self._span_data = span_data\n        self._prev_span_token: contextvars.Token[Span[TSpanData] | None] | None = None\n    @property\n    def trace_id(self) -> str:\n        return \"no-op\"\n    @property\n    def span_id(self) -> str:",
        "detail": "src.agents.tracing.spans",
        "documentation": {}
    },
    {
        "label": "SpanImpl",
        "kind": 6,
        "importPath": "src.agents.tracing.spans",
        "description": "src.agents.tracing.spans",
        "peekOfCode": "class SpanImpl(Span[TSpanData]):\n    __slots__ = (\n        \"_trace_id\",\n        \"_span_id\",\n        \"_parent_id\",\n        \"_started_at\",\n        \"_ended_at\",\n        \"_error\",\n        \"_prev_span_token\",\n        \"_processor\",",
        "detail": "src.agents.tracing.spans",
        "documentation": {}
    },
    {
        "label": "TSpanData",
        "kind": 5,
        "importPath": "src.agents.tracing.spans",
        "description": "src.agents.tracing.spans",
        "peekOfCode": "TSpanData = TypeVar(\"TSpanData\", bound=SpanData)\nclass SpanError(TypedDict):\n    message: str\n    data: dict[str, Any] | None\nclass Span(abc.ABC, Generic[TSpanData]):\n    @property\n    @abc.abstractmethod\n    def trace_id(self) -> str:\n        pass\n    @property",
        "detail": "src.agents.tracing.spans",
        "documentation": {}
    },
    {
        "label": "Trace",
        "kind": 6,
        "importPath": "src.agents.tracing.traces",
        "description": "src.agents.tracing.traces",
        "peekOfCode": "class Trace:\n    \"\"\"\n    A trace is the root level object that tracing creates. It represents a logical \"workflow\".\n    \"\"\"\n    @abc.abstractmethod\n    def __enter__(self) -> Trace:\n        pass\n    @abc.abstractmethod\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        pass",
        "detail": "src.agents.tracing.traces",
        "documentation": {}
    },
    {
        "label": "NoOpTrace",
        "kind": 6,
        "importPath": "src.agents.tracing.traces",
        "description": "src.agents.tracing.traces",
        "peekOfCode": "class NoOpTrace(Trace):\n    \"\"\"\n    A no-op trace that will not be recorded.\n    \"\"\"\n    def __init__(self):\n        self._started = False\n        self._prev_context_token: contextvars.Token[Trace | None] | None = None\n    def __enter__(self) -> Trace:\n        if self._started:\n            if not self._prev_context_token:",
        "detail": "src.agents.tracing.traces",
        "documentation": {}
    },
    {
        "label": "TraceImpl",
        "kind": 6,
        "importPath": "src.agents.tracing.traces",
        "description": "src.agents.tracing.traces",
        "peekOfCode": "class TraceImpl(Trace):\n    \"\"\"\n    A trace that will be recorded by the tracing library.\n    \"\"\"\n    __slots__ = (\n        \"_name\",\n        \"_trace_id\",\n        \"group_id\",\n        \"metadata\",\n        \"_prev_context_token\",",
        "detail": "src.agents.tracing.traces",
        "documentation": {}
    },
    {
        "label": "NO_OP_TRACE",
        "kind": 5,
        "importPath": "src.agents.tracing.traces",
        "description": "src.agents.tracing.traces",
        "peekOfCode": "NO_OP_TRACE = NoOpTrace()\nclass TraceImpl(Trace):\n    \"\"\"\n    A trace that will be recorded by the tracing library.\n    \"\"\"\n    __slots__ = (\n        \"_name\",\n        \"_trace_id\",\n        \"group_id\",\n        \"metadata\",",
        "detail": "src.agents.tracing.traces",
        "documentation": {}
    },
    {
        "label": "time_iso",
        "kind": 2,
        "importPath": "src.agents.tracing.util",
        "description": "src.agents.tracing.util",
        "peekOfCode": "def time_iso() -> str:\n    \"\"\"Returns the current time in ISO 8601 format.\"\"\"\n    return datetime.now(timezone.utc).isoformat()\ndef gen_trace_id() -> str:\n    \"\"\"Generates a new trace ID.\"\"\"\n    return f\"trace_{uuid.uuid4().hex}\"\ndef gen_span_id() -> str:\n    \"\"\"Generates a new span ID.\"\"\"\n    return f\"span_{uuid.uuid4().hex[:24]}\"",
        "detail": "src.agents.tracing.util",
        "documentation": {}
    },
    {
        "label": "gen_trace_id",
        "kind": 2,
        "importPath": "src.agents.tracing.util",
        "description": "src.agents.tracing.util",
        "peekOfCode": "def gen_trace_id() -> str:\n    \"\"\"Generates a new trace ID.\"\"\"\n    return f\"trace_{uuid.uuid4().hex}\"\ndef gen_span_id() -> str:\n    \"\"\"Generates a new span ID.\"\"\"\n    return f\"span_{uuid.uuid4().hex[:24]}\"",
        "detail": "src.agents.tracing.util",
        "documentation": {}
    },
    {
        "label": "gen_span_id",
        "kind": 2,
        "importPath": "src.agents.tracing.util",
        "description": "src.agents.tracing.util",
        "peekOfCode": "def gen_span_id() -> str:\n    \"\"\"Generates a new span ID.\"\"\"\n    return f\"span_{uuid.uuid4().hex[:24]}\"",
        "detail": "src.agents.tracing.util",
        "documentation": {}
    },
    {
        "label": "attach_error_to_span",
        "kind": 2,
        "importPath": "src.agents.util._error_tracing",
        "description": "src.agents.util._error_tracing",
        "peekOfCode": "def attach_error_to_span(span: Span[Any], error: SpanError) -> None:\n    span.set_error(error)\ndef attach_error_to_current_span(error: SpanError) -> None:\n    span = get_current_span()\n    if span:\n        attach_error_to_span(span, error)\n    else:\n        logger.warning(f\"No span to add error {error} to\")",
        "detail": "src.agents.util._error_tracing",
        "documentation": {}
    },
    {
        "label": "attach_error_to_current_span",
        "kind": 2,
        "importPath": "src.agents.util._error_tracing",
        "description": "src.agents.util._error_tracing",
        "peekOfCode": "def attach_error_to_current_span(error: SpanError) -> None:\n    span = get_current_span()\n    if span:\n        attach_error_to_span(span, error)\n    else:\n        logger.warning(f\"No span to add error {error} to\")",
        "detail": "src.agents.util._error_tracing",
        "documentation": {}
    },
    {
        "label": "validate_json",
        "kind": 2,
        "importPath": "src.agents.util._json",
        "description": "src.agents.util._json",
        "peekOfCode": "def validate_json(json_str: str, type_adapter: TypeAdapter[T], partial: bool) -> T:\n    partial_setting: bool | Literal[\"off\", \"on\", \"trailing-strings\"] = (\n        \"trailing-strings\" if partial else False\n    )\n    try:\n        validated = type_adapter.validate_json(json_str, experimental_allow_partial=partial_setting)\n        return validated\n    except ValidationError as e:\n        attach_error_to_current_span(\n            SpanError(",
        "detail": "src.agents.util._json",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "src.agents.util._json",
        "description": "src.agents.util._json",
        "peekOfCode": "T = TypeVar(\"T\")\ndef validate_json(json_str: str, type_adapter: TypeAdapter[T], partial: bool) -> T:\n    partial_setting: bool | Literal[\"off\", \"on\", \"trailing-strings\"] = (\n        \"trailing-strings\" if partial else False\n    )\n    try:\n        validated = type_adapter.validate_json(json_str, experimental_allow_partial=partial_setting)\n        return validated\n    except ValidationError as e:\n        attach_error_to_current_span(",
        "detail": "src.agents.util._json",
        "documentation": {}
    },
    {
        "label": "pretty_print_result",
        "kind": 2,
        "importPath": "src.agents.util._pretty_print",
        "description": "src.agents.util._pretty_print",
        "peekOfCode": "def pretty_print_result(result: \"RunResult\") -> str:\n    output = \"RunResult:\"\n    output += f'\\n- Last agent: Agent(name=\"{result.last_agent.name}\", ...)'\n    output += (\n        f\"\\n- Final output ({type(result.final_output).__name__}):\\n\"\n        f\"{_indent(_final_output_str(result), 2)}\"\n    )\n    output += f\"\\n- {len(result.new_items)} new item(s)\"\n    output += f\"\\n- {len(result.raw_responses)} raw response(s)\"\n    output += f\"\\n- {len(result.input_guardrail_results)} input guardrail result(s)\"",
        "detail": "src.agents.util._pretty_print",
        "documentation": {}
    },
    {
        "label": "pretty_print_run_result_streaming",
        "kind": 2,
        "importPath": "src.agents.util._pretty_print",
        "description": "src.agents.util._pretty_print",
        "peekOfCode": "def pretty_print_run_result_streaming(result: \"RunResultStreaming\") -> str:\n    output = \"RunResultStreaming:\"\n    output += f'\\n- Current agent: Agent(name=\"{result.current_agent.name}\", ...)'\n    output += f\"\\n- Current turn: {result.current_turn}\"\n    output += f\"\\n- Max turns: {result.max_turns}\"\n    output += f\"\\n- Is complete: {result.is_complete}\"\n    output += (\n        f\"\\n- Final output ({type(result.final_output).__name__}):\\n\"\n        f\"{_indent(_final_output_str(result), 2)}\"\n    )",
        "detail": "src.agents.util._pretty_print",
        "documentation": {}
    },
    {
        "label": "transform_string_function_style",
        "kind": 2,
        "importPath": "src.agents.util._transforms",
        "description": "src.agents.util._transforms",
        "peekOfCode": "def transform_string_function_style(name: str) -> str:\n    # Replace spaces with underscores\n    name = name.replace(\" \", \"_\")\n    # Replace non-alphanumeric characters with underscores\n    name = re.sub(r\"[^a-zA-Z0-9]\", \"_\", name)\n    return name.lower()",
        "detail": "src.agents.util._transforms",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "src.agents.util._types",
        "description": "src.agents.util._types",
        "peekOfCode": "T = TypeVar(\"T\")\nMaybeAwaitable = Union[Awaitable[T], T]",
        "detail": "src.agents.util._types",
        "documentation": {}
    },
    {
        "label": "MaybeAwaitable",
        "kind": 5,
        "importPath": "src.agents.util._types",
        "description": "src.agents.util._types",
        "peekOfCode": "MaybeAwaitable = Union[Awaitable[T], T]",
        "detail": "src.agents.util._types",
        "documentation": {}
    },
    {
        "label": "set_default_openai_key",
        "kind": 2,
        "importPath": "src.agents._config",
        "description": "src.agents._config",
        "peekOfCode": "def set_default_openai_key(key: str, use_for_tracing: bool) -> None:\n    _openai_shared.set_default_openai_key(key)\n    if use_for_tracing:\n        set_tracing_export_api_key(key)\ndef set_default_openai_client(client: AsyncOpenAI, use_for_tracing: bool) -> None:\n    _openai_shared.set_default_openai_client(client)\n    if use_for_tracing:\n        set_tracing_export_api_key(client.api_key)\ndef set_default_openai_api(api: Literal[\"chat_completions\", \"responses\"]) -> None:\n    if api == \"chat_completions\":",
        "detail": "src.agents._config",
        "documentation": {}
    },
    {
        "label": "set_default_openai_client",
        "kind": 2,
        "importPath": "src.agents._config",
        "description": "src.agents._config",
        "peekOfCode": "def set_default_openai_client(client: AsyncOpenAI, use_for_tracing: bool) -> None:\n    _openai_shared.set_default_openai_client(client)\n    if use_for_tracing:\n        set_tracing_export_api_key(client.api_key)\ndef set_default_openai_api(api: Literal[\"chat_completions\", \"responses\"]) -> None:\n    if api == \"chat_completions\":\n        _openai_shared.set_use_responses_by_default(False)\n    else:\n        _openai_shared.set_use_responses_by_default(True)",
        "detail": "src.agents._config",
        "documentation": {}
    },
    {
        "label": "set_default_openai_api",
        "kind": 2,
        "importPath": "src.agents._config",
        "description": "src.agents._config",
        "peekOfCode": "def set_default_openai_api(api: Literal[\"chat_completions\", \"responses\"]) -> None:\n    if api == \"chat_completions\":\n        _openai_shared.set_use_responses_by_default(False)\n    else:\n        _openai_shared.set_use_responses_by_default(True)",
        "detail": "src.agents._config",
        "documentation": {}
    },
    {
        "label": "DONT_LOG_MODEL_DATA",
        "kind": 5,
        "importPath": "src.agents._debug",
        "description": "src.agents._debug",
        "peekOfCode": "DONT_LOG_MODEL_DATA = _debug_flag_enabled(\"OPENAI_AGENTS_DONT_LOG_MODEL_DATA\")\n\"\"\"By default we don't log LLM inputs/outputs, to prevent exposing sensitive information. Set this\nflag to enable logging them.\n\"\"\"\nDONT_LOG_TOOL_DATA = _debug_flag_enabled(\"OPENAI_AGENTS_DONT_LOG_TOOL_DATA\")\n\"\"\"By default we don't log tool call inputs/outputs, to prevent exposing sensitive information. Set\nthis flag to enable logging them.\n\"\"\"",
        "detail": "src.agents._debug",
        "documentation": {}
    },
    {
        "label": "DONT_LOG_TOOL_DATA",
        "kind": 5,
        "importPath": "src.agents._debug",
        "description": "src.agents._debug",
        "peekOfCode": "DONT_LOG_TOOL_DATA = _debug_flag_enabled(\"OPENAI_AGENTS_DONT_LOG_TOOL_DATA\")\n\"\"\"By default we don't log tool call inputs/outputs, to prevent exposing sensitive information. Set\nthis flag to enable logging them.\n\"\"\"",
        "detail": "src.agents._debug",
        "documentation": {}
    },
    {
        "label": "QueueCompleteSentinel",
        "kind": 6,
        "importPath": "src.agents._run_impl",
        "description": "src.agents._run_impl",
        "peekOfCode": "class QueueCompleteSentinel:\n    pass\nQUEUE_COMPLETE_SENTINEL = QueueCompleteSentinel()\n_NOT_FINAL_OUTPUT = ToolsToFinalOutputResult(is_final_output=False, final_output=None)\n@dataclass\nclass ToolRunHandoff:\n    handoff: Handoff\n    tool_call: ResponseFunctionToolCall\n@dataclass\nclass ToolRunFunction:",
        "detail": "src.agents._run_impl",
        "documentation": {}
    },
    {
        "label": "ToolRunHandoff",
        "kind": 6,
        "importPath": "src.agents._run_impl",
        "description": "src.agents._run_impl",
        "peekOfCode": "class ToolRunHandoff:\n    handoff: Handoff\n    tool_call: ResponseFunctionToolCall\n@dataclass\nclass ToolRunFunction:\n    tool_call: ResponseFunctionToolCall\n    function_tool: FunctionTool\n@dataclass\nclass ToolRunComputerAction:\n    tool_call: ResponseComputerToolCall",
        "detail": "src.agents._run_impl",
        "documentation": {}
    },
    {
        "label": "ToolRunFunction",
        "kind": 6,
        "importPath": "src.agents._run_impl",
        "description": "src.agents._run_impl",
        "peekOfCode": "class ToolRunFunction:\n    tool_call: ResponseFunctionToolCall\n    function_tool: FunctionTool\n@dataclass\nclass ToolRunComputerAction:\n    tool_call: ResponseComputerToolCall\n    computer_tool: ComputerTool\n@dataclass\nclass ProcessedResponse:\n    new_items: list[RunItem]",
        "detail": "src.agents._run_impl",
        "documentation": {}
    },
    {
        "label": "ToolRunComputerAction",
        "kind": 6,
        "importPath": "src.agents._run_impl",
        "description": "src.agents._run_impl",
        "peekOfCode": "class ToolRunComputerAction:\n    tool_call: ResponseComputerToolCall\n    computer_tool: ComputerTool\n@dataclass\nclass ProcessedResponse:\n    new_items: list[RunItem]\n    handoffs: list[ToolRunHandoff]\n    functions: list[ToolRunFunction]\n    computer_actions: list[ToolRunComputerAction]\n    def has_tools_to_run(self) -> bool:",
        "detail": "src.agents._run_impl",
        "documentation": {}
    },
    {
        "label": "ProcessedResponse",
        "kind": 6,
        "importPath": "src.agents._run_impl",
        "description": "src.agents._run_impl",
        "peekOfCode": "class ProcessedResponse:\n    new_items: list[RunItem]\n    handoffs: list[ToolRunHandoff]\n    functions: list[ToolRunFunction]\n    computer_actions: list[ToolRunComputerAction]\n    def has_tools_to_run(self) -> bool:\n        # Handoffs, functions and computer actions need local processing\n        # Hosted tools have already run, so there's nothing to do.\n        return any(\n            [",
        "detail": "src.agents._run_impl",
        "documentation": {}
    },
    {
        "label": "NextStepHandoff",
        "kind": 6,
        "importPath": "src.agents._run_impl",
        "description": "src.agents._run_impl",
        "peekOfCode": "class NextStepHandoff:\n    new_agent: Agent[Any]\n@dataclass\nclass NextStepFinalOutput:\n    output: Any\n@dataclass\nclass NextStepRunAgain:\n    pass\n@dataclass\nclass SingleStepResult:",
        "detail": "src.agents._run_impl",
        "documentation": {}
    },
    {
        "label": "NextStepFinalOutput",
        "kind": 6,
        "importPath": "src.agents._run_impl",
        "description": "src.agents._run_impl",
        "peekOfCode": "class NextStepFinalOutput:\n    output: Any\n@dataclass\nclass NextStepRunAgain:\n    pass\n@dataclass\nclass SingleStepResult:\n    original_input: str | list[TResponseInputItem]\n    \"\"\"The input items i.e. the items before run() was called. May be mutated by handoff input\n    filters.\"\"\"",
        "detail": "src.agents._run_impl",
        "documentation": {}
    },
    {
        "label": "NextStepRunAgain",
        "kind": 6,
        "importPath": "src.agents._run_impl",
        "description": "src.agents._run_impl",
        "peekOfCode": "class NextStepRunAgain:\n    pass\n@dataclass\nclass SingleStepResult:\n    original_input: str | list[TResponseInputItem]\n    \"\"\"The input items i.e. the items before run() was called. May be mutated by handoff input\n    filters.\"\"\"\n    model_response: ModelResponse\n    \"\"\"The model response for the current step.\"\"\"\n    pre_step_items: list[RunItem]",
        "detail": "src.agents._run_impl",
        "documentation": {}
    },
    {
        "label": "SingleStepResult",
        "kind": 6,
        "importPath": "src.agents._run_impl",
        "description": "src.agents._run_impl",
        "peekOfCode": "class SingleStepResult:\n    original_input: str | list[TResponseInputItem]\n    \"\"\"The input items i.e. the items before run() was called. May be mutated by handoff input\n    filters.\"\"\"\n    model_response: ModelResponse\n    \"\"\"The model response for the current step.\"\"\"\n    pre_step_items: list[RunItem]\n    \"\"\"Items generated before the current step.\"\"\"\n    new_step_items: list[RunItem]\n    \"\"\"Items generated during this current step.\"\"\"",
        "detail": "src.agents._run_impl",
        "documentation": {}
    },
    {
        "label": "RunImpl",
        "kind": 6,
        "importPath": "src.agents._run_impl",
        "description": "src.agents._run_impl",
        "peekOfCode": "class RunImpl:\n    @classmethod\n    async def execute_tools_and_side_effects(\n        cls,\n        *,\n        agent: Agent[TContext],\n        # The original input to the Runner\n        original_input: str | list[TResponseInputItem],\n        # Everything generated by Runner since the original input, but before the current step\n        pre_step_items: list[RunItem],",
        "detail": "src.agents._run_impl",
        "documentation": {}
    },
    {
        "label": "TraceCtxManager",
        "kind": 6,
        "importPath": "src.agents._run_impl",
        "description": "src.agents._run_impl",
        "peekOfCode": "class TraceCtxManager:\n    \"\"\"Creates a trace only if there is no current trace, and manages the trace lifecycle.\"\"\"\n    def __init__(\n        self,\n        workflow_name: str,\n        trace_id: str | None,\n        group_id: str | None,\n        metadata: dict[str, Any] | None,\n        disabled: bool,\n    ):",
        "detail": "src.agents._run_impl",
        "documentation": {}
    },
    {
        "label": "ComputerAction",
        "kind": 6,
        "importPath": "src.agents._run_impl",
        "description": "src.agents._run_impl",
        "peekOfCode": "class ComputerAction:\n    @classmethod\n    async def execute(\n        cls,\n        *,\n        agent: Agent[TContext],\n        action: ToolRunComputerAction,\n        hooks: RunHooks[TContext],\n        context_wrapper: RunContextWrapper[TContext],\n        config: RunConfig,",
        "detail": "src.agents._run_impl",
        "documentation": {}
    },
    {
        "label": "get_model_tracing_impl",
        "kind": 2,
        "importPath": "src.agents._run_impl",
        "description": "src.agents._run_impl",
        "peekOfCode": "def get_model_tracing_impl(\n    tracing_disabled: bool, trace_include_sensitive_data: bool\n) -> ModelTracing:\n    if tracing_disabled:\n        return ModelTracing.DISABLED\n    elif trace_include_sensitive_data:\n        return ModelTracing.ENABLED\n    else:\n        return ModelTracing.ENABLED_WITHOUT_DATA\nclass RunImpl:",
        "detail": "src.agents._run_impl",
        "documentation": {}
    },
    {
        "label": "QUEUE_COMPLETE_SENTINEL",
        "kind": 5,
        "importPath": "src.agents._run_impl",
        "description": "src.agents._run_impl",
        "peekOfCode": "QUEUE_COMPLETE_SENTINEL = QueueCompleteSentinel()\n_NOT_FINAL_OUTPUT = ToolsToFinalOutputResult(is_final_output=False, final_output=None)\n@dataclass\nclass ToolRunHandoff:\n    handoff: Handoff\n    tool_call: ResponseFunctionToolCall\n@dataclass\nclass ToolRunFunction:\n    tool_call: ResponseFunctionToolCall\n    function_tool: FunctionTool",
        "detail": "src.agents._run_impl",
        "documentation": {}
    },
    {
        "label": "_NOT_FINAL_OUTPUT",
        "kind": 5,
        "importPath": "src.agents._run_impl",
        "description": "src.agents._run_impl",
        "peekOfCode": "_NOT_FINAL_OUTPUT = ToolsToFinalOutputResult(is_final_output=False, final_output=None)\n@dataclass\nclass ToolRunHandoff:\n    handoff: Handoff\n    tool_call: ResponseFunctionToolCall\n@dataclass\nclass ToolRunFunction:\n    tool_call: ResponseFunctionToolCall\n    function_tool: FunctionTool\n@dataclass",
        "detail": "src.agents._run_impl",
        "documentation": {}
    },
    {
        "label": "ToolsToFinalOutputResult",
        "kind": 6,
        "importPath": "src.agents.agent",
        "description": "src.agents.agent",
        "peekOfCode": "class ToolsToFinalOutputResult:\n    is_final_output: bool\n    \"\"\"Whether this is the final output. If False, the LLM will run again and receive the tool call\n    output.\n    \"\"\"\n    final_output: Any | None = None\n    \"\"\"The final output. Can be None if `is_final_output` is False, otherwise must match the\n    `output_type` of the agent.\n    \"\"\"\nToolsToFinalOutputFunction: TypeAlias = Callable[",
        "detail": "src.agents.agent",
        "documentation": {}
    },
    {
        "label": "StopAtTools",
        "kind": 6,
        "importPath": "src.agents.agent",
        "description": "src.agents.agent",
        "peekOfCode": "class StopAtTools(TypedDict):\n    stop_at_tool_names: list[str]\n    \"\"\"A list of tool names, any of which will stop the agent from running further.\"\"\"\n@dataclass\nclass Agent(Generic[TContext]):\n    \"\"\"An agent is an AI model configured with instructions, tools, guardrails, handoffs and more.\n    We strongly recommend passing `instructions`, which is the \"system prompt\" for the agent. In\n    addition, you can pass `handoff_description`, which is a human-readable description of the\n    agent, used when the agent is used inside tools/handoffs.\n    Agents are generic on the context type. The context is a (mutable) object you create. It is",
        "detail": "src.agents.agent",
        "documentation": {}
    },
    {
        "label": "Agent",
        "kind": 6,
        "importPath": "src.agents.agent",
        "description": "src.agents.agent",
        "peekOfCode": "class Agent(Generic[TContext]):\n    \"\"\"An agent is an AI model configured with instructions, tools, guardrails, handoffs and more.\n    We strongly recommend passing `instructions`, which is the \"system prompt\" for the agent. In\n    addition, you can pass `handoff_description`, which is a human-readable description of the\n    agent, used when the agent is used inside tools/handoffs.\n    Agents are generic on the context type. The context is a (mutable) object you create. It is\n    passed to tool functions, handoffs, guardrails, etc.\n    \"\"\"\n    name: str\n    \"\"\"The name of the agent.\"\"\"",
        "detail": "src.agents.agent",
        "documentation": {}
    },
    {
        "label": "AgentOutputSchema",
        "kind": 6,
        "importPath": "src.agents.agent_output",
        "description": "src.agents.agent_output",
        "peekOfCode": "class AgentOutputSchema:\n    \"\"\"An object that captures the JSON schema of the output, as well as validating/parsing JSON\n    produced by the LLM into the output type.\n    \"\"\"\n    output_type: type[Any]\n    \"\"\"The type of the output.\"\"\"\n    _type_adapter: TypeAdapter[Any]\n    \"\"\"A type adapter that wraps the output type, so that we can validate JSON.\"\"\"\n    _is_wrapped: bool\n    \"\"\"Whether the output type is wrapped in a dictionary. This is generally done if the base",
        "detail": "src.agents.agent_output",
        "documentation": {}
    },
    {
        "label": "_WRAPPER_DICT_KEY",
        "kind": 5,
        "importPath": "src.agents.agent_output",
        "description": "src.agents.agent_output",
        "peekOfCode": "_WRAPPER_DICT_KEY = \"response\"\n@dataclass(init=False)\nclass AgentOutputSchema:\n    \"\"\"An object that captures the JSON schema of the output, as well as validating/parsing JSON\n    produced by the LLM into the output type.\n    \"\"\"\n    output_type: type[Any]\n    \"\"\"The type of the output.\"\"\"\n    _type_adapter: TypeAdapter[Any]\n    \"\"\"A type adapter that wraps the output type, so that we can validate JSON.\"\"\"",
        "detail": "src.agents.agent_output",
        "documentation": {}
    },
    {
        "label": "Computer",
        "kind": 6,
        "importPath": "src.agents.computer",
        "description": "src.agents.computer",
        "peekOfCode": "class Computer(abc.ABC):\n    \"\"\"A computer implemented with sync operations. The Computer interface abstracts the\n    operations needed to control a computer or browser.\"\"\"\n    @property\n    @abc.abstractmethod\n    def environment(self) -> Environment:\n        pass\n    @property\n    @abc.abstractmethod\n    def dimensions(self) -> tuple[int, int]:",
        "detail": "src.agents.computer",
        "documentation": {}
    },
    {
        "label": "AsyncComputer",
        "kind": 6,
        "importPath": "src.agents.computer",
        "description": "src.agents.computer",
        "peekOfCode": "class AsyncComputer(abc.ABC):\n    \"\"\"A computer implemented with async operations. The Computer interface abstracts the\n    operations needed to control a computer or browser.\"\"\"\n    @property\n    @abc.abstractmethod\n    def environment(self) -> Environment:\n        pass\n    @property\n    @abc.abstractmethod\n    def dimensions(self) -> tuple[int, int]:",
        "detail": "src.agents.computer",
        "documentation": {}
    },
    {
        "label": "Environment",
        "kind": 5,
        "importPath": "src.agents.computer",
        "description": "src.agents.computer",
        "peekOfCode": "Environment = Literal[\"mac\", \"windows\", \"ubuntu\", \"browser\"]\nButton = Literal[\"left\", \"right\", \"wheel\", \"back\", \"forward\"]\nclass Computer(abc.ABC):\n    \"\"\"A computer implemented with sync operations. The Computer interface abstracts the\n    operations needed to control a computer or browser.\"\"\"\n    @property\n    @abc.abstractmethod\n    def environment(self) -> Environment:\n        pass\n    @property",
        "detail": "src.agents.computer",
        "documentation": {}
    },
    {
        "label": "Button",
        "kind": 5,
        "importPath": "src.agents.computer",
        "description": "src.agents.computer",
        "peekOfCode": "Button = Literal[\"left\", \"right\", \"wheel\", \"back\", \"forward\"]\nclass Computer(abc.ABC):\n    \"\"\"A computer implemented with sync operations. The Computer interface abstracts the\n    operations needed to control a computer or browser.\"\"\"\n    @property\n    @abc.abstractmethod\n    def environment(self) -> Environment:\n        pass\n    @property\n    @abc.abstractmethod",
        "detail": "src.agents.computer",
        "documentation": {}
    },
    {
        "label": "AgentsException",
        "kind": 6,
        "importPath": "src.agents.exceptions",
        "description": "src.agents.exceptions",
        "peekOfCode": "class AgentsException(Exception):\n    \"\"\"Base class for all exceptions in the Agents SDK.\"\"\"\nclass MaxTurnsExceeded(AgentsException):\n    \"\"\"Exception raised when the maximum number of turns is exceeded.\"\"\"\n    message: str\n    def __init__(self, message: str):\n        self.message = message\nclass ModelBehaviorError(AgentsException):\n    \"\"\"Exception raised when the model does something unexpected, e.g. calling a tool that doesn't\n    exist, or providing malformed JSON.",
        "detail": "src.agents.exceptions",
        "documentation": {}
    },
    {
        "label": "MaxTurnsExceeded",
        "kind": 6,
        "importPath": "src.agents.exceptions",
        "description": "src.agents.exceptions",
        "peekOfCode": "class MaxTurnsExceeded(AgentsException):\n    \"\"\"Exception raised when the maximum number of turns is exceeded.\"\"\"\n    message: str\n    def __init__(self, message: str):\n        self.message = message\nclass ModelBehaviorError(AgentsException):\n    \"\"\"Exception raised when the model does something unexpected, e.g. calling a tool that doesn't\n    exist, or providing malformed JSON.\n    \"\"\"\n    message: str",
        "detail": "src.agents.exceptions",
        "documentation": {}
    },
    {
        "label": "ModelBehaviorError",
        "kind": 6,
        "importPath": "src.agents.exceptions",
        "description": "src.agents.exceptions",
        "peekOfCode": "class ModelBehaviorError(AgentsException):\n    \"\"\"Exception raised when the model does something unexpected, e.g. calling a tool that doesn't\n    exist, or providing malformed JSON.\n    \"\"\"\n    message: str\n    def __init__(self, message: str):\n        self.message = message\nclass UserError(AgentsException):\n    \"\"\"Exception raised when the user makes an error using the SDK.\"\"\"\n    message: str",
        "detail": "src.agents.exceptions",
        "documentation": {}
    },
    {
        "label": "UserError",
        "kind": 6,
        "importPath": "src.agents.exceptions",
        "description": "src.agents.exceptions",
        "peekOfCode": "class UserError(AgentsException):\n    \"\"\"Exception raised when the user makes an error using the SDK.\"\"\"\n    message: str\n    def __init__(self, message: str):\n        self.message = message\nclass InputGuardrailTripwireTriggered(AgentsException):\n    \"\"\"Exception raised when a guardrail tripwire is triggered.\"\"\"\n    guardrail_result: \"InputGuardrailResult\"\n    \"\"\"The result data of the guardrail that was triggered.\"\"\"\n    def __init__(self, guardrail_result: \"InputGuardrailResult\"):",
        "detail": "src.agents.exceptions",
        "documentation": {}
    },
    {
        "label": "InputGuardrailTripwireTriggered",
        "kind": 6,
        "importPath": "src.agents.exceptions",
        "description": "src.agents.exceptions",
        "peekOfCode": "class InputGuardrailTripwireTriggered(AgentsException):\n    \"\"\"Exception raised when a guardrail tripwire is triggered.\"\"\"\n    guardrail_result: \"InputGuardrailResult\"\n    \"\"\"The result data of the guardrail that was triggered.\"\"\"\n    def __init__(self, guardrail_result: \"InputGuardrailResult\"):\n        self.guardrail_result = guardrail_result\n        super().__init__(\n            f\"Guardrail {guardrail_result.guardrail.__class__.__name__} triggered tripwire\"\n        )\nclass OutputGuardrailTripwireTriggered(AgentsException):",
        "detail": "src.agents.exceptions",
        "documentation": {}
    },
    {
        "label": "OutputGuardrailTripwireTriggered",
        "kind": 6,
        "importPath": "src.agents.exceptions",
        "description": "src.agents.exceptions",
        "peekOfCode": "class OutputGuardrailTripwireTriggered(AgentsException):\n    \"\"\"Exception raised when a guardrail tripwire is triggered.\"\"\"\n    guardrail_result: \"OutputGuardrailResult\"\n    \"\"\"The result data of the guardrail that was triggered.\"\"\"\n    def __init__(self, guardrail_result: \"OutputGuardrailResult\"):\n        self.guardrail_result = guardrail_result\n        super().__init__(\n            f\"Guardrail {guardrail_result.guardrail.__class__.__name__} triggered tripwire\"\n        )",
        "detail": "src.agents.exceptions",
        "documentation": {}
    },
    {
        "label": "FuncSchema",
        "kind": 6,
        "importPath": "src.agents.function_schema",
        "description": "src.agents.function_schema",
        "peekOfCode": "class FuncSchema:\n    \"\"\"\n    Captures the schema for a python function, in preparation for sending it to an LLM as a tool.\n    \"\"\"\n    name: str\n    \"\"\"The name of the function.\"\"\"\n    description: str | None\n    \"\"\"The description of the function.\"\"\"\n    params_pydantic_model: type[BaseModel]\n    \"\"\"A Pydantic model that represents the function's parameters.\"\"\"",
        "detail": "src.agents.function_schema",
        "documentation": {}
    },
    {
        "label": "FuncDocumentation",
        "kind": 6,
        "importPath": "src.agents.function_schema",
        "description": "src.agents.function_schema",
        "peekOfCode": "class FuncDocumentation:\n    \"\"\"Contains metadata about a python function, extracted from its docstring.\"\"\"\n    name: str\n    \"\"\"The name of the function, via `__name__`.\"\"\"\n    description: str | None\n    \"\"\"The description of the function, derived from the docstring.\"\"\"\n    param_descriptions: dict[str, str] | None\n    \"\"\"The parameter descriptions of the function, derived from the docstring.\"\"\"\nDocstringStyle = Literal[\"google\", \"numpy\", \"sphinx\"]\n# As of Feb 2025, the automatic style detection in griffe is an Insiders feature. This",
        "detail": "src.agents.function_schema",
        "documentation": {}
    },
    {
        "label": "generate_func_documentation",
        "kind": 2,
        "importPath": "src.agents.function_schema",
        "description": "src.agents.function_schema",
        "peekOfCode": "def generate_func_documentation(\n    func: Callable[..., Any], style: DocstringStyle | None = None\n) -> FuncDocumentation:\n    \"\"\"\n    Extracts metadata from a function docstring, in preparation for sending it to an LLM as a tool.\n    Args:\n        func: The function to extract documentation from.\n        style: The style of the docstring to use for parsing. If not provided, we will attempt to\n            auto-detect the style.\n    Returns:",
        "detail": "src.agents.function_schema",
        "documentation": {}
    },
    {
        "label": "function_schema",
        "kind": 2,
        "importPath": "src.agents.function_schema",
        "description": "src.agents.function_schema",
        "peekOfCode": "def function_schema(\n    func: Callable[..., Any],\n    docstring_style: DocstringStyle | None = None,\n    name_override: str | None = None,\n    description_override: str | None = None,\n    use_docstring_info: bool = True,\n    strict_json_schema: bool = True,\n) -> FuncSchema:\n    \"\"\"\n    Given a python function, extracts a `FuncSchema` from it, capturing the name, description,",
        "detail": "src.agents.function_schema",
        "documentation": {}
    },
    {
        "label": "DocstringStyle",
        "kind": 5,
        "importPath": "src.agents.function_schema",
        "description": "src.agents.function_schema",
        "peekOfCode": "DocstringStyle = Literal[\"google\", \"numpy\", \"sphinx\"]\n# As of Feb 2025, the automatic style detection in griffe is an Insiders feature. This\n# code approximates it.\ndef _detect_docstring_style(doc: str) -> DocstringStyle:\n    scores: dict[DocstringStyle, int] = {\"sphinx\": 0, \"numpy\": 0, \"google\": 0}\n    # Sphinx style detection: look for :param, :type, :return:, and :rtype:\n    sphinx_patterns = [r\"^:param\\s\", r\"^:type\\s\", r\"^:return:\", r\"^:rtype:\"]\n    for pattern in sphinx_patterns:\n        if re.search(pattern, doc, re.MULTILINE):\n            scores[\"sphinx\"] += 1",
        "detail": "src.agents.function_schema",
        "documentation": {}
    },
    {
        "label": "GuardrailFunctionOutput",
        "kind": 6,
        "importPath": "src.agents.guardrail",
        "description": "src.agents.guardrail",
        "peekOfCode": "class GuardrailFunctionOutput:\n    \"\"\"The output of a guardrail function.\"\"\"\n    output_info: Any\n    \"\"\"\n    Optional information about the guardrail's output. For example, the guardrail could include\n    information about the checks it performed and granular results.\n    \"\"\"\n    tripwire_triggered: bool\n    \"\"\"\n    Whether the tripwire was triggered. If triggered, the agent's execution will be halted.",
        "detail": "src.agents.guardrail",
        "documentation": {}
    },
    {
        "label": "InputGuardrailResult",
        "kind": 6,
        "importPath": "src.agents.guardrail",
        "description": "src.agents.guardrail",
        "peekOfCode": "class InputGuardrailResult:\n    \"\"\"The result of a guardrail run.\"\"\"\n    guardrail: InputGuardrail[Any]\n    \"\"\"\n    The guardrail that was run.\n    \"\"\"\n    output: GuardrailFunctionOutput\n    \"\"\"The output of the guardrail function.\"\"\"\n@dataclass\nclass OutputGuardrailResult:",
        "detail": "src.agents.guardrail",
        "documentation": {}
    },
    {
        "label": "OutputGuardrailResult",
        "kind": 6,
        "importPath": "src.agents.guardrail",
        "description": "src.agents.guardrail",
        "peekOfCode": "class OutputGuardrailResult:\n    \"\"\"The result of a guardrail run.\"\"\"\n    guardrail: OutputGuardrail[Any]\n    \"\"\"\n    The guardrail that was run.\n    \"\"\"\n    agent_output: Any\n    \"\"\"\n    The output of the agent that was checked by the guardrail.\n    \"\"\"",
        "detail": "src.agents.guardrail",
        "documentation": {}
    },
    {
        "label": "InputGuardrail",
        "kind": 6,
        "importPath": "src.agents.guardrail",
        "description": "src.agents.guardrail",
        "peekOfCode": "class InputGuardrail(Generic[TContext]):\n    \"\"\"Input guardrails are checks that run in parallel to the agent's execution.\n    They can be used to do things like:\n    - Check if input messages are off-topic\n    - Take over control of the agent's execution if an unexpected input is detected\n    You can use the `@input_guardrail()` decorator to turn a function into an `InputGuardrail`, or\n    create an `InputGuardrail` manually.\n    Guardrails return a `GuardrailResult`. If `result.tripwire_triggered` is `True`, the agent\n    execution will immediately stop and a `InputGuardrailTripwireTriggered` exception will be raised\n    \"\"\"",
        "detail": "src.agents.guardrail",
        "documentation": {}
    },
    {
        "label": "OutputGuardrail",
        "kind": 6,
        "importPath": "src.agents.guardrail",
        "description": "src.agents.guardrail",
        "peekOfCode": "class OutputGuardrail(Generic[TContext]):\n    \"\"\"Output guardrails are checks that run on the final output of an agent.\n    They can be used to do check if the output passes certain validation criteria\n    You can use the `@output_guardrail()` decorator to turn a function into an `OutputGuardrail`,\n    or create an `OutputGuardrail` manually.\n    Guardrails return a `GuardrailResult`. If `result.tripwire_triggered` is `True`, a\n    `OutputGuardrailTripwireTriggered` exception will be raised.\n    \"\"\"\n    guardrail_function: Callable[\n        [RunContextWrapper[TContext], Agent[Any], Any],",
        "detail": "src.agents.guardrail",
        "documentation": {}
    },
    {
        "label": "input_guardrail",
        "kind": 2,
        "importPath": "src.agents.guardrail",
        "description": "src.agents.guardrail",
        "peekOfCode": "def input_guardrail(\n    func: _InputGuardrailFuncSync[TContext_co],\n) -> InputGuardrail[TContext_co]: ...\n@overload\ndef input_guardrail(\n    func: _InputGuardrailFuncAsync[TContext_co],\n) -> InputGuardrail[TContext_co]: ...\n@overload\ndef input_guardrail(\n    *,",
        "detail": "src.agents.guardrail",
        "documentation": {}
    },
    {
        "label": "input_guardrail",
        "kind": 2,
        "importPath": "src.agents.guardrail",
        "description": "src.agents.guardrail",
        "peekOfCode": "def input_guardrail(\n    func: _InputGuardrailFuncAsync[TContext_co],\n) -> InputGuardrail[TContext_co]: ...\n@overload\ndef input_guardrail(\n    *,\n    name: str | None = None,\n) -> Callable[\n    [_InputGuardrailFuncSync[TContext_co] | _InputGuardrailFuncAsync[TContext_co]],\n    InputGuardrail[TContext_co],",
        "detail": "src.agents.guardrail",
        "documentation": {}
    },
    {
        "label": "input_guardrail",
        "kind": 2,
        "importPath": "src.agents.guardrail",
        "description": "src.agents.guardrail",
        "peekOfCode": "def input_guardrail(\n    *,\n    name: str | None = None,\n) -> Callable[\n    [_InputGuardrailFuncSync[TContext_co] | _InputGuardrailFuncAsync[TContext_co]],\n    InputGuardrail[TContext_co],\n]: ...\ndef input_guardrail(\n    func: _InputGuardrailFuncSync[TContext_co]\n    | _InputGuardrailFuncAsync[TContext_co]",
        "detail": "src.agents.guardrail",
        "documentation": {}
    },
    {
        "label": "input_guardrail",
        "kind": 2,
        "importPath": "src.agents.guardrail",
        "description": "src.agents.guardrail",
        "peekOfCode": "def input_guardrail(\n    func: _InputGuardrailFuncSync[TContext_co]\n    | _InputGuardrailFuncAsync[TContext_co]\n    | None = None,\n    *,\n    name: str | None = None,\n) -> (\n    InputGuardrail[TContext_co]\n    | Callable[\n        [_InputGuardrailFuncSync[TContext_co] | _InputGuardrailFuncAsync[TContext_co]],",
        "detail": "src.agents.guardrail",
        "documentation": {}
    },
    {
        "label": "output_guardrail",
        "kind": 2,
        "importPath": "src.agents.guardrail",
        "description": "src.agents.guardrail",
        "peekOfCode": "def output_guardrail(\n    func: _OutputGuardrailFuncSync[TContext_co],\n) -> OutputGuardrail[TContext_co]: ...\n@overload\ndef output_guardrail(\n    func: _OutputGuardrailFuncAsync[TContext_co],\n) -> OutputGuardrail[TContext_co]: ...\n@overload\ndef output_guardrail(\n    *,",
        "detail": "src.agents.guardrail",
        "documentation": {}
    },
    {
        "label": "output_guardrail",
        "kind": 2,
        "importPath": "src.agents.guardrail",
        "description": "src.agents.guardrail",
        "peekOfCode": "def output_guardrail(\n    func: _OutputGuardrailFuncAsync[TContext_co],\n) -> OutputGuardrail[TContext_co]: ...\n@overload\ndef output_guardrail(\n    *,\n    name: str | None = None,\n) -> Callable[\n    [_OutputGuardrailFuncSync[TContext_co] | _OutputGuardrailFuncAsync[TContext_co]],\n    OutputGuardrail[TContext_co],",
        "detail": "src.agents.guardrail",
        "documentation": {}
    },
    {
        "label": "output_guardrail",
        "kind": 2,
        "importPath": "src.agents.guardrail",
        "description": "src.agents.guardrail",
        "peekOfCode": "def output_guardrail(\n    *,\n    name: str | None = None,\n) -> Callable[\n    [_OutputGuardrailFuncSync[TContext_co] | _OutputGuardrailFuncAsync[TContext_co]],\n    OutputGuardrail[TContext_co],\n]: ...\ndef output_guardrail(\n    func: _OutputGuardrailFuncSync[TContext_co]\n    | _OutputGuardrailFuncAsync[TContext_co]",
        "detail": "src.agents.guardrail",
        "documentation": {}
    },
    {
        "label": "output_guardrail",
        "kind": 2,
        "importPath": "src.agents.guardrail",
        "description": "src.agents.guardrail",
        "peekOfCode": "def output_guardrail(\n    func: _OutputGuardrailFuncSync[TContext_co]\n    | _OutputGuardrailFuncAsync[TContext_co]\n    | None = None,\n    *,\n    name: str | None = None,\n) -> (\n    OutputGuardrail[TContext_co]\n    | Callable[\n        [_OutputGuardrailFuncSync[TContext_co] | _OutputGuardrailFuncAsync[TContext_co]],",
        "detail": "src.agents.guardrail",
        "documentation": {}
    },
    {
        "label": "TContext_co",
        "kind": 5,
        "importPath": "src.agents.guardrail",
        "description": "src.agents.guardrail",
        "peekOfCode": "TContext_co = TypeVar(\"TContext_co\", bound=Any, covariant=True)\n# For InputGuardrail\n_InputGuardrailFuncSync = Callable[\n    [RunContextWrapper[TContext_co], \"Agent[Any]\", Union[str, list[TResponseInputItem]]],\n    GuardrailFunctionOutput,\n]\n_InputGuardrailFuncAsync = Callable[\n    [RunContextWrapper[TContext_co], \"Agent[Any]\", Union[str, list[TResponseInputItem]]],\n    Awaitable[GuardrailFunctionOutput],\n]",
        "detail": "src.agents.guardrail",
        "documentation": {}
    },
    {
        "label": "_InputGuardrailFuncSync",
        "kind": 5,
        "importPath": "src.agents.guardrail",
        "description": "src.agents.guardrail",
        "peekOfCode": "_InputGuardrailFuncSync = Callable[\n    [RunContextWrapper[TContext_co], \"Agent[Any]\", Union[str, list[TResponseInputItem]]],\n    GuardrailFunctionOutput,\n]\n_InputGuardrailFuncAsync = Callable[\n    [RunContextWrapper[TContext_co], \"Agent[Any]\", Union[str, list[TResponseInputItem]]],\n    Awaitable[GuardrailFunctionOutput],\n]\n@overload\ndef input_guardrail(",
        "detail": "src.agents.guardrail",
        "documentation": {}
    },
    {
        "label": "_InputGuardrailFuncAsync",
        "kind": 5,
        "importPath": "src.agents.guardrail",
        "description": "src.agents.guardrail",
        "peekOfCode": "_InputGuardrailFuncAsync = Callable[\n    [RunContextWrapper[TContext_co], \"Agent[Any]\", Union[str, list[TResponseInputItem]]],\n    Awaitable[GuardrailFunctionOutput],\n]\n@overload\ndef input_guardrail(\n    func: _InputGuardrailFuncSync[TContext_co],\n) -> InputGuardrail[TContext_co]: ...\n@overload\ndef input_guardrail(",
        "detail": "src.agents.guardrail",
        "documentation": {}
    },
    {
        "label": "_OutputGuardrailFuncSync",
        "kind": 5,
        "importPath": "src.agents.guardrail",
        "description": "src.agents.guardrail",
        "peekOfCode": "_OutputGuardrailFuncSync = Callable[\n    [RunContextWrapper[TContext_co], \"Agent[Any]\", Any],\n    GuardrailFunctionOutput,\n]\n_OutputGuardrailFuncAsync = Callable[\n    [RunContextWrapper[TContext_co], \"Agent[Any]\", Any],\n    Awaitable[GuardrailFunctionOutput],\n]\n@overload\ndef output_guardrail(",
        "detail": "src.agents.guardrail",
        "documentation": {}
    },
    {
        "label": "_OutputGuardrailFuncAsync",
        "kind": 5,
        "importPath": "src.agents.guardrail",
        "description": "src.agents.guardrail",
        "peekOfCode": "_OutputGuardrailFuncAsync = Callable[\n    [RunContextWrapper[TContext_co], \"Agent[Any]\", Any],\n    Awaitable[GuardrailFunctionOutput],\n]\n@overload\ndef output_guardrail(\n    func: _OutputGuardrailFuncSync[TContext_co],\n) -> OutputGuardrail[TContext_co]: ...\n@overload\ndef output_guardrail(",
        "detail": "src.agents.guardrail",
        "documentation": {}
    },
    {
        "label": "HandoffInputData",
        "kind": 6,
        "importPath": "src.agents.handoffs",
        "description": "src.agents.handoffs",
        "peekOfCode": "class HandoffInputData:\n    input_history: str | tuple[TResponseInputItem, ...]\n    \"\"\"\n    The input history before `Runner.run()` was called.\n    \"\"\"\n    pre_handoff_items: tuple[RunItem, ...]\n    \"\"\"\n    The items generated before the agent turn where the handoff was invoked.\n    \"\"\"\n    new_items: tuple[RunItem, ...]",
        "detail": "src.agents.handoffs",
        "documentation": {}
    },
    {
        "label": "Handoff",
        "kind": 6,
        "importPath": "src.agents.handoffs",
        "description": "src.agents.handoffs",
        "peekOfCode": "class Handoff(Generic[TContext]):\n    \"\"\"A handoff is when an agent delegates a task to another agent.\n    For example, in a customer support scenario you might have a \"triage agent\" that determines\n    which agent should handle the user's request, and sub-agents that specialize in different\n    areas like billing, account management, etc.\n    \"\"\"\n    tool_name: str\n    \"\"\"The name of the tool that represents the handoff.\"\"\"\n    tool_description: str\n    \"\"\"The description of the tool that represents the handoff.\"\"\"",
        "detail": "src.agents.handoffs",
        "documentation": {}
    },
    {
        "label": "handoff",
        "kind": 2,
        "importPath": "src.agents.handoffs",
        "description": "src.agents.handoffs",
        "peekOfCode": "def handoff(\n    agent: Agent[TContext],\n    *,\n    tool_name_override: str | None = None,\n    tool_description_override: str | None = None,\n    input_filter: Callable[[HandoffInputData], HandoffInputData] | None = None,\n) -> Handoff[TContext]: ...\n@overload\ndef handoff(\n    agent: Agent[TContext],",
        "detail": "src.agents.handoffs",
        "documentation": {}
    },
    {
        "label": "handoff",
        "kind": 2,
        "importPath": "src.agents.handoffs",
        "description": "src.agents.handoffs",
        "peekOfCode": "def handoff(\n    agent: Agent[TContext],\n    *,\n    on_handoff: OnHandoffWithInput[THandoffInput],\n    input_type: type[THandoffInput],\n    tool_description_override: str | None = None,\n    tool_name_override: str | None = None,\n    input_filter: Callable[[HandoffInputData], HandoffInputData] | None = None,\n) -> Handoff[TContext]: ...\n@overload",
        "detail": "src.agents.handoffs",
        "documentation": {}
    },
    {
        "label": "handoff",
        "kind": 2,
        "importPath": "src.agents.handoffs",
        "description": "src.agents.handoffs",
        "peekOfCode": "def handoff(\n    agent: Agent[TContext],\n    *,\n    on_handoff: OnHandoffWithoutInput,\n    tool_description_override: str | None = None,\n    tool_name_override: str | None = None,\n    input_filter: Callable[[HandoffInputData], HandoffInputData] | None = None,\n) -> Handoff[TContext]: ...\ndef handoff(\n    agent: Agent[TContext],",
        "detail": "src.agents.handoffs",
        "documentation": {}
    },
    {
        "label": "handoff",
        "kind": 2,
        "importPath": "src.agents.handoffs",
        "description": "src.agents.handoffs",
        "peekOfCode": "def handoff(\n    agent: Agent[TContext],\n    tool_name_override: str | None = None,\n    tool_description_override: str | None = None,\n    on_handoff: OnHandoffWithInput[THandoffInput] | OnHandoffWithoutInput | None = None,\n    input_type: type[THandoffInput] | None = None,\n    input_filter: Callable[[HandoffInputData], HandoffInputData] | None = None,\n) -> Handoff[TContext]:\n    \"\"\"Create a handoff from an agent.\n    Args:",
        "detail": "src.agents.handoffs",
        "documentation": {}
    },
    {
        "label": "THandoffInput",
        "kind": 5,
        "importPath": "src.agents.handoffs",
        "description": "src.agents.handoffs",
        "peekOfCode": "THandoffInput = TypeVar(\"THandoffInput\", default=Any)\nOnHandoffWithInput = Callable[[RunContextWrapper[Any], THandoffInput], Any]\nOnHandoffWithoutInput = Callable[[RunContextWrapper[Any]], Any]\n@dataclass(frozen=True)\nclass HandoffInputData:\n    input_history: str | tuple[TResponseInputItem, ...]\n    \"\"\"\n    The input history before `Runner.run()` was called.\n    \"\"\"\n    pre_handoff_items: tuple[RunItem, ...]",
        "detail": "src.agents.handoffs",
        "documentation": {}
    },
    {
        "label": "OnHandoffWithInput",
        "kind": 5,
        "importPath": "src.agents.handoffs",
        "description": "src.agents.handoffs",
        "peekOfCode": "OnHandoffWithInput = Callable[[RunContextWrapper[Any], THandoffInput], Any]\nOnHandoffWithoutInput = Callable[[RunContextWrapper[Any]], Any]\n@dataclass(frozen=True)\nclass HandoffInputData:\n    input_history: str | tuple[TResponseInputItem, ...]\n    \"\"\"\n    The input history before `Runner.run()` was called.\n    \"\"\"\n    pre_handoff_items: tuple[RunItem, ...]\n    \"\"\"",
        "detail": "src.agents.handoffs",
        "documentation": {}
    },
    {
        "label": "OnHandoffWithoutInput",
        "kind": 5,
        "importPath": "src.agents.handoffs",
        "description": "src.agents.handoffs",
        "peekOfCode": "OnHandoffWithoutInput = Callable[[RunContextWrapper[Any]], Any]\n@dataclass(frozen=True)\nclass HandoffInputData:\n    input_history: str | tuple[TResponseInputItem, ...]\n    \"\"\"\n    The input history before `Runner.run()` was called.\n    \"\"\"\n    pre_handoff_items: tuple[RunItem, ...]\n    \"\"\"\n    The items generated before the agent turn where the handoff was invoked.",
        "detail": "src.agents.handoffs",
        "documentation": {}
    },
    {
        "label": "RunItemBase",
        "kind": 6,
        "importPath": "src.agents.items",
        "description": "src.agents.items",
        "peekOfCode": "class RunItemBase(Generic[T], abc.ABC):\n    agent: Agent[Any]\n    \"\"\"The agent whose run caused this item to be generated.\"\"\"\n    raw_item: T\n    \"\"\"The raw Responses item from the run. This will always be a either an output item (i.e.\n    `openai.types.responses.ResponseOutputItem` or an input item\n    (i.e. `openai.types.responses.ResponseInputItemParam`).\n    \"\"\"\n    def to_input_item(self) -> TResponseInputItem:\n        \"\"\"Converts this item into an input item suitable for passing to the model.\"\"\"",
        "detail": "src.agents.items",
        "documentation": {}
    },
    {
        "label": "MessageOutputItem",
        "kind": 6,
        "importPath": "src.agents.items",
        "description": "src.agents.items",
        "peekOfCode": "class MessageOutputItem(RunItemBase[ResponseOutputMessage]):\n    \"\"\"Represents a message from the LLM.\"\"\"\n    raw_item: ResponseOutputMessage\n    \"\"\"The raw response output message.\"\"\"\n    type: Literal[\"message_output_item\"] = \"message_output_item\"\n@dataclass\nclass HandoffCallItem(RunItemBase[ResponseFunctionToolCall]):\n    \"\"\"Represents a tool call for a handoff from one agent to another.\"\"\"\n    raw_item: ResponseFunctionToolCall\n    \"\"\"The raw response function tool call that represents the handoff.\"\"\"",
        "detail": "src.agents.items",
        "documentation": {}
    },
    {
        "label": "HandoffCallItem",
        "kind": 6,
        "importPath": "src.agents.items",
        "description": "src.agents.items",
        "peekOfCode": "class HandoffCallItem(RunItemBase[ResponseFunctionToolCall]):\n    \"\"\"Represents a tool call for a handoff from one agent to another.\"\"\"\n    raw_item: ResponseFunctionToolCall\n    \"\"\"The raw response function tool call that represents the handoff.\"\"\"\n    type: Literal[\"handoff_call_item\"] = \"handoff_call_item\"\n@dataclass\nclass HandoffOutputItem(RunItemBase[TResponseInputItem]):\n    \"\"\"Represents the output of a handoff.\"\"\"\n    raw_item: TResponseInputItem\n    \"\"\"The raw input item that represents the handoff taking place.\"\"\"",
        "detail": "src.agents.items",
        "documentation": {}
    },
    {
        "label": "HandoffOutputItem",
        "kind": 6,
        "importPath": "src.agents.items",
        "description": "src.agents.items",
        "peekOfCode": "class HandoffOutputItem(RunItemBase[TResponseInputItem]):\n    \"\"\"Represents the output of a handoff.\"\"\"\n    raw_item: TResponseInputItem\n    \"\"\"The raw input item that represents the handoff taking place.\"\"\"\n    source_agent: Agent[Any]\n    \"\"\"The agent that made the handoff.\"\"\"\n    target_agent: Agent[Any]\n    \"\"\"The agent that is being handed off to.\"\"\"\n    type: Literal[\"handoff_output_item\"] = \"handoff_output_item\"\nToolCallItemTypes: TypeAlias = Union[",
        "detail": "src.agents.items",
        "documentation": {}
    },
    {
        "label": "ToolCallItem",
        "kind": 6,
        "importPath": "src.agents.items",
        "description": "src.agents.items",
        "peekOfCode": "class ToolCallItem(RunItemBase[ToolCallItemTypes]):\n    \"\"\"Represents a tool call e.g. a function call or computer action call.\"\"\"\n    raw_item: ToolCallItemTypes\n    \"\"\"The raw tool call item.\"\"\"\n    type: Literal[\"tool_call_item\"] = \"tool_call_item\"\n@dataclass\nclass ToolCallOutputItem(RunItemBase[Union[FunctionCallOutput, ComputerCallOutput]]):\n    \"\"\"Represents the output of a tool call.\"\"\"\n    raw_item: FunctionCallOutput | ComputerCallOutput\n    \"\"\"The raw item from the model.\"\"\"",
        "detail": "src.agents.items",
        "documentation": {}
    },
    {
        "label": "ToolCallOutputItem",
        "kind": 6,
        "importPath": "src.agents.items",
        "description": "src.agents.items",
        "peekOfCode": "class ToolCallOutputItem(RunItemBase[Union[FunctionCallOutput, ComputerCallOutput]]):\n    \"\"\"Represents the output of a tool call.\"\"\"\n    raw_item: FunctionCallOutput | ComputerCallOutput\n    \"\"\"The raw item from the model.\"\"\"\n    output: Any\n    \"\"\"The output of the tool call. This is whatever the tool call returned; the `raw_item`\n    contains a string representation of the output.\n    \"\"\"\n    type: Literal[\"tool_call_output_item\"] = \"tool_call_output_item\"\n@dataclass",
        "detail": "src.agents.items",
        "documentation": {}
    },
    {
        "label": "ReasoningItem",
        "kind": 6,
        "importPath": "src.agents.items",
        "description": "src.agents.items",
        "peekOfCode": "class ReasoningItem(RunItemBase[ResponseReasoningItem]):\n    \"\"\"Represents a reasoning item.\"\"\"\n    raw_item: ResponseReasoningItem\n    \"\"\"The raw reasoning item.\"\"\"\n    type: Literal[\"reasoning_item\"] = \"reasoning_item\"\nRunItem: TypeAlias = Union[\n    MessageOutputItem,\n    HandoffCallItem,\n    HandoffOutputItem,\n    ToolCallItem,",
        "detail": "src.agents.items",
        "documentation": {}
    },
    {
        "label": "ModelResponse",
        "kind": 6,
        "importPath": "src.agents.items",
        "description": "src.agents.items",
        "peekOfCode": "class ModelResponse:\n    output: list[TResponseOutputItem]\n    \"\"\"A list of outputs (messages, tool calls, etc) generated by the model\"\"\"\n    usage: Usage\n    \"\"\"The usage information for the response.\"\"\"\n    referenceable_id: str | None\n    \"\"\"An ID for the response which can be used to refer to the response in subsequent calls to the\n    model. Not supported by all model providers.\n    \"\"\"\n    def to_input_items(self) -> list[TResponseInputItem]:",
        "detail": "src.agents.items",
        "documentation": {}
    },
    {
        "label": "ItemHelpers",
        "kind": 6,
        "importPath": "src.agents.items",
        "description": "src.agents.items",
        "peekOfCode": "class ItemHelpers:\n    @classmethod\n    def extract_last_content(cls, message: TResponseOutputItem) -> str:\n        \"\"\"Extracts the last text content or refusal from a message.\"\"\"\n        if not isinstance(message, ResponseOutputMessage):\n            return \"\"\n        last_content = message.content[-1]\n        if isinstance(last_content, ResponseOutputText):\n            return last_content.text\n        elif isinstance(last_content, ResponseOutputRefusal):",
        "detail": "src.agents.items",
        "documentation": {}
    },
    {
        "label": "TResponse",
        "kind": 5,
        "importPath": "src.agents.items",
        "description": "src.agents.items",
        "peekOfCode": "TResponse = Response\n\"\"\"A type alias for the Response type from the OpenAI SDK.\"\"\"\nTResponseInputItem = ResponseInputItemParam\n\"\"\"A type alias for the ResponseInputItemParam type from the OpenAI SDK.\"\"\"\nTResponseOutputItem = ResponseOutputItem\n\"\"\"A type alias for the ResponseOutputItem type from the OpenAI SDK.\"\"\"\nTResponseStreamEvent = ResponseStreamEvent\n\"\"\"A type alias for the ResponseStreamEvent type from the OpenAI SDK.\"\"\"\nT = TypeVar(\"T\", bound=Union[TResponseOutputItem, TResponseInputItem])\n@dataclass",
        "detail": "src.agents.items",
        "documentation": {}
    },
    {
        "label": "TResponseInputItem",
        "kind": 5,
        "importPath": "src.agents.items",
        "description": "src.agents.items",
        "peekOfCode": "TResponseInputItem = ResponseInputItemParam\n\"\"\"A type alias for the ResponseInputItemParam type from the OpenAI SDK.\"\"\"\nTResponseOutputItem = ResponseOutputItem\n\"\"\"A type alias for the ResponseOutputItem type from the OpenAI SDK.\"\"\"\nTResponseStreamEvent = ResponseStreamEvent\n\"\"\"A type alias for the ResponseStreamEvent type from the OpenAI SDK.\"\"\"\nT = TypeVar(\"T\", bound=Union[TResponseOutputItem, TResponseInputItem])\n@dataclass\nclass RunItemBase(Generic[T], abc.ABC):\n    agent: Agent[Any]",
        "detail": "src.agents.items",
        "documentation": {}
    },
    {
        "label": "TResponseOutputItem",
        "kind": 5,
        "importPath": "src.agents.items",
        "description": "src.agents.items",
        "peekOfCode": "TResponseOutputItem = ResponseOutputItem\n\"\"\"A type alias for the ResponseOutputItem type from the OpenAI SDK.\"\"\"\nTResponseStreamEvent = ResponseStreamEvent\n\"\"\"A type alias for the ResponseStreamEvent type from the OpenAI SDK.\"\"\"\nT = TypeVar(\"T\", bound=Union[TResponseOutputItem, TResponseInputItem])\n@dataclass\nclass RunItemBase(Generic[T], abc.ABC):\n    agent: Agent[Any]\n    \"\"\"The agent whose run caused this item to be generated.\"\"\"\n    raw_item: T",
        "detail": "src.agents.items",
        "documentation": {}
    },
    {
        "label": "TResponseStreamEvent",
        "kind": 5,
        "importPath": "src.agents.items",
        "description": "src.agents.items",
        "peekOfCode": "TResponseStreamEvent = ResponseStreamEvent\n\"\"\"A type alias for the ResponseStreamEvent type from the OpenAI SDK.\"\"\"\nT = TypeVar(\"T\", bound=Union[TResponseOutputItem, TResponseInputItem])\n@dataclass\nclass RunItemBase(Generic[T], abc.ABC):\n    agent: Agent[Any]\n    \"\"\"The agent whose run caused this item to be generated.\"\"\"\n    raw_item: T\n    \"\"\"The raw Responses item from the run. This will always be a either an output item (i.e.\n    `openai.types.responses.ResponseOutputItem` or an input item",
        "detail": "src.agents.items",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "src.agents.items",
        "description": "src.agents.items",
        "peekOfCode": "T = TypeVar(\"T\", bound=Union[TResponseOutputItem, TResponseInputItem])\n@dataclass\nclass RunItemBase(Generic[T], abc.ABC):\n    agent: Agent[Any]\n    \"\"\"The agent whose run caused this item to be generated.\"\"\"\n    raw_item: T\n    \"\"\"The raw Responses item from the run. This will always be a either an output item (i.e.\n    `openai.types.responses.ResponseOutputItem` or an input item\n    (i.e. `openai.types.responses.ResponseInputItemParam`).\n    \"\"\"",
        "detail": "src.agents.items",
        "documentation": {}
    },
    {
        "label": "RunHooks",
        "kind": 6,
        "importPath": "src.agents.lifecycle",
        "description": "src.agents.lifecycle",
        "peekOfCode": "class RunHooks(Generic[TContext]):\n    \"\"\"A class that receives callbacks on various lifecycle events in an agent run. Subclass and\n    override the methods you need.\n    \"\"\"\n    async def on_agent_start(\n        self, context: RunContextWrapper[TContext], agent: Agent[TContext]\n    ) -> None:\n        \"\"\"Called before the agent is invoked. Called each time the current agent changes.\"\"\"\n        pass\n    async def on_agent_end(",
        "detail": "src.agents.lifecycle",
        "documentation": {}
    },
    {
        "label": "AgentHooks",
        "kind": 6,
        "importPath": "src.agents.lifecycle",
        "description": "src.agents.lifecycle",
        "peekOfCode": "class AgentHooks(Generic[TContext]):\n    \"\"\"A class that receives callbacks on various lifecycle events for a specific agent. You can\n    set this on `agent.hooks` to receive events for that specific agent.\n    Subclass and override the methods you need.\n    \"\"\"\n    async def on_start(\n        self, context: RunContextWrapper[TContext], agent: Agent[TContext]\n    ) -> None:\n        \"\"\"Called before the agent is invoked. Called each time the running agent is changed to this\n        agent.\"\"\"",
        "detail": "src.agents.lifecycle",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.agents.logger",
        "description": "src.agents.logger",
        "peekOfCode": "logger = logging.getLogger(\"openai.agents\")",
        "detail": "src.agents.logger",
        "documentation": {}
    },
    {
        "label": "ModelSettings",
        "kind": 6,
        "importPath": "src.agents.model_settings",
        "description": "src.agents.model_settings",
        "peekOfCode": "class ModelSettings:\n    \"\"\"Settings to use when calling an LLM.\n    This class holds optional model configuration parameters (e.g. temperature,\n    top_p, penalties, truncation, etc.).\n    Not all models/providers support all of these parameters, so please check the API documentation\n    for the specific model and provider you are using.\n    \"\"\"\n    temperature: float | None = None\n    \"\"\"The temperature to use when calling the model.\"\"\"\n    top_p: float | None = None",
        "detail": "src.agents.model_settings",
        "documentation": {}
    },
    {
        "label": "RunResultBase",
        "kind": 6,
        "importPath": "src.agents.result",
        "description": "src.agents.result",
        "peekOfCode": "class RunResultBase(abc.ABC):\n    input: str | list[TResponseInputItem]\n    \"\"\"The original input items i.e. the items before run() was called. This may be a mutated\n    version of the input, if there are handoff input filters that mutate the input.\n    \"\"\"\n    new_items: list[RunItem]\n    \"\"\"The new items generated during the agent run. These include things like new messages, tool\n    calls and their outputs, etc.\n    \"\"\"\n    raw_responses: list[ModelResponse]",
        "detail": "src.agents.result",
        "documentation": {}
    },
    {
        "label": "RunResult",
        "kind": 6,
        "importPath": "src.agents.result",
        "description": "src.agents.result",
        "peekOfCode": "class RunResult(RunResultBase):\n    _last_agent: Agent[Any]\n    @property\n    def last_agent(self) -> Agent[Any]:\n        \"\"\"The last agent that was run.\"\"\"\n        return self._last_agent\n    def __str__(self) -> str:\n        return pretty_print_result(self)\n@dataclass\nclass RunResultStreaming(RunResultBase):",
        "detail": "src.agents.result",
        "documentation": {}
    },
    {
        "label": "RunResultStreaming",
        "kind": 6,
        "importPath": "src.agents.result",
        "description": "src.agents.result",
        "peekOfCode": "class RunResultStreaming(RunResultBase):\n    \"\"\"The result of an agent run in streaming mode. You can use the `stream_events` method to\n    receive semantic events as they are generated.\n    The streaming method will raise:\n    - A MaxTurnsExceeded exception if the agent exceeds the max_turns limit.\n    - A GuardrailTripwireTriggered exception if a guardrail is tripped.\n    \"\"\"\n    current_agent: Agent[Any]\n    \"\"\"The current agent that is running.\"\"\"\n    current_turn: int",
        "detail": "src.agents.result",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "src.agents.result",
        "description": "src.agents.result",
        "peekOfCode": "T = TypeVar(\"T\")\n@dataclass\nclass RunResultBase(abc.ABC):\n    input: str | list[TResponseInputItem]\n    \"\"\"The original input items i.e. the items before run() was called. This may be a mutated\n    version of the input, if there are handoff input filters that mutate the input.\n    \"\"\"\n    new_items: list[RunItem]\n    \"\"\"The new items generated during the agent run. These include things like new messages, tool\n    calls and their outputs, etc.",
        "detail": "src.agents.result",
        "documentation": {}
    },
    {
        "label": "RunConfig",
        "kind": 6,
        "importPath": "src.agents.run",
        "description": "src.agents.run",
        "peekOfCode": "class RunConfig:\n    \"\"\"Configures settings for the entire agent run.\"\"\"\n    model: str | Model | None = None\n    \"\"\"The model to use for the entire agent run. If set, will override the model set on every\n    agent. The model_provider passed in below must be able to resolve this model name.\n    \"\"\"\n    model_provider: ModelProvider = field(default_factory=OpenAIProvider)\n    \"\"\"The model provider to use when looking up string model names. Defaults to OpenAI.\"\"\"\n    model_settings: ModelSettings | None = None\n    \"\"\"Configure global model settings. Any non-null values will override the agent-specific model",
        "detail": "src.agents.run",
        "documentation": {}
    },
    {
        "label": "Runner",
        "kind": 6,
        "importPath": "src.agents.run",
        "description": "src.agents.run",
        "peekOfCode": "class Runner:\n    @classmethod\n    async def run(\n        cls,\n        starting_agent: Agent[TContext],\n        input: str | list[TResponseInputItem],\n        *,\n        context: TContext | None = None,\n        max_turns: int = DEFAULT_MAX_TURNS,\n        hooks: RunHooks[TContext] | None = None,",
        "detail": "src.agents.run",
        "documentation": {}
    },
    {
        "label": "DEFAULT_MAX_TURNS",
        "kind": 5,
        "importPath": "src.agents.run",
        "description": "src.agents.run",
        "peekOfCode": "DEFAULT_MAX_TURNS = 10\n@dataclass\nclass RunConfig:\n    \"\"\"Configures settings for the entire agent run.\"\"\"\n    model: str | Model | None = None\n    \"\"\"The model to use for the entire agent run. If set, will override the model set on every\n    agent. The model_provider passed in below must be able to resolve this model name.\n    \"\"\"\n    model_provider: ModelProvider = field(default_factory=OpenAIProvider)\n    \"\"\"The model provider to use when looking up string model names. Defaults to OpenAI.\"\"\"",
        "detail": "src.agents.run",
        "documentation": {}
    },
    {
        "label": "RunContextWrapper",
        "kind": 6,
        "importPath": "src.agents.run_context",
        "description": "src.agents.run_context",
        "peekOfCode": "class RunContextWrapper(Generic[TContext]):\n    \"\"\"This wraps the context object that you passed to `Runner.run()`. It also contains\n    information about the usage of the agent run so far.\n    NOTE: Contexts are not passed to the LLM. They're a way to pass dependencies and data to code\n    you implement, like tool functions, callbacks, hooks, etc.\n    \"\"\"\n    context: TContext\n    \"\"\"The context object (or None), passed by you to `Runner.run()`\"\"\"\n    usage: Usage = field(default_factory=Usage)\n    \"\"\"The usage of the agent run so far. For streamed responses, the usage will be stale until the",
        "detail": "src.agents.run_context",
        "documentation": {}
    },
    {
        "label": "TContext",
        "kind": 5,
        "importPath": "src.agents.run_context",
        "description": "src.agents.run_context",
        "peekOfCode": "TContext = TypeVar(\"TContext\", default=Any)\n@dataclass\nclass RunContextWrapper(Generic[TContext]):\n    \"\"\"This wraps the context object that you passed to `Runner.run()`. It also contains\n    information about the usage of the agent run so far.\n    NOTE: Contexts are not passed to the LLM. They're a way to pass dependencies and data to code\n    you implement, like tool functions, callbacks, hooks, etc.\n    \"\"\"\n    context: TContext\n    \"\"\"The context object (or None), passed by you to `Runner.run()`\"\"\"",
        "detail": "src.agents.run_context",
        "documentation": {}
    },
    {
        "label": "RawResponsesStreamEvent",
        "kind": 6,
        "importPath": "src.agents.stream_events",
        "description": "src.agents.stream_events",
        "peekOfCode": "class RawResponsesStreamEvent:\n    \"\"\"Streaming event from the LLM. These are 'raw' events, i.e. they are directly passed through\n    from the LLM.\n    \"\"\"\n    data: TResponseStreamEvent\n    \"\"\"The raw responses streaming event from the LLM.\"\"\"\n    type: Literal[\"raw_response_event\"] = \"raw_response_event\"\n    \"\"\"The type of the event.\"\"\"\n@dataclass\nclass RunItemStreamEvent:",
        "detail": "src.agents.stream_events",
        "documentation": {}
    },
    {
        "label": "RunItemStreamEvent",
        "kind": 6,
        "importPath": "src.agents.stream_events",
        "description": "src.agents.stream_events",
        "peekOfCode": "class RunItemStreamEvent:\n    \"\"\"Streaming events that wrap a `RunItem`. As the agent processes the LLM response, it will\n    generate these events for new messages, tool calls, tool outputs, handoffs, etc.\n    \"\"\"\n    name: Literal[\n        \"message_output_created\",\n        \"handoff_requested\",\n        \"handoff_occured\",\n        \"tool_called\",\n        \"tool_output\",",
        "detail": "src.agents.stream_events",
        "documentation": {}
    },
    {
        "label": "AgentUpdatedStreamEvent",
        "kind": 6,
        "importPath": "src.agents.stream_events",
        "description": "src.agents.stream_events",
        "peekOfCode": "class AgentUpdatedStreamEvent:\n    \"\"\"Event that notifies that there is a new agent running.\"\"\"\n    new_agent: Agent[Any]\n    \"\"\"The new agent.\"\"\"\n    type: Literal[\"agent_updated_stream_event\"] = \"agent_updated_stream_event\"\nStreamEvent: TypeAlias = Union[RawResponsesStreamEvent, RunItemStreamEvent, AgentUpdatedStreamEvent]\n\"\"\"A streaming event from an agent.\"\"\"",
        "detail": "src.agents.stream_events",
        "documentation": {}
    },
    {
        "label": "ensure_strict_json_schema",
        "kind": 2,
        "importPath": "src.agents.strict_schema",
        "description": "src.agents.strict_schema",
        "peekOfCode": "def ensure_strict_json_schema(\n    schema: dict[str, Any],\n) -> dict[str, Any]:\n    \"\"\"Mutates the given JSON schema to ensure it conforms to the `strict` standard\n    that the OpenAI API expects.\n    \"\"\"\n    if schema == {}:\n        return _EMPTY_SCHEMA\n    return _ensure_strict_json_schema(schema, path=(), root=schema)\n# Adapted from https://github.com/openai/openai-python/blob/main/src/openai/lib/_pydantic.py",
        "detail": "src.agents.strict_schema",
        "documentation": {}
    },
    {
        "label": "resolve_ref",
        "kind": 2,
        "importPath": "src.agents.strict_schema",
        "description": "src.agents.strict_schema",
        "peekOfCode": "def resolve_ref(*, root: dict[str, object], ref: str) -> object:\n    if not ref.startswith(\"#/\"):\n        raise ValueError(f\"Unexpected $ref format {ref!r}; Does not start with #/\")\n    path = ref[2:].split(\"/\")\n    resolved = root\n    for key in path:\n        value = resolved[key]\n        assert is_dict(value), (\n            f\"encountered non-dictionary entry while resolving {ref} - {resolved}\"\n        )",
        "detail": "src.agents.strict_schema",
        "documentation": {}
    },
    {
        "label": "is_dict",
        "kind": 2,
        "importPath": "src.agents.strict_schema",
        "description": "src.agents.strict_schema",
        "peekOfCode": "def is_dict(obj: object) -> TypeGuard[dict[str, object]]:\n    # just pretend that we know there are only `str` keys\n    # as that check is not worth the performance cost\n    return isinstance(obj, dict)\ndef is_list(obj: object) -> TypeGuard[list[object]]:\n    return isinstance(obj, list)\ndef has_more_than_n_keys(obj: dict[str, object], n: int) -> bool:\n    i = 0\n    for _ in obj.keys():\n        i += 1",
        "detail": "src.agents.strict_schema",
        "documentation": {}
    },
    {
        "label": "is_list",
        "kind": 2,
        "importPath": "src.agents.strict_schema",
        "description": "src.agents.strict_schema",
        "peekOfCode": "def is_list(obj: object) -> TypeGuard[list[object]]:\n    return isinstance(obj, list)\ndef has_more_than_n_keys(obj: dict[str, object], n: int) -> bool:\n    i = 0\n    for _ in obj.keys():\n        i += 1\n        if i > n:\n            return True\n    return False",
        "detail": "src.agents.strict_schema",
        "documentation": {}
    },
    {
        "label": "has_more_than_n_keys",
        "kind": 2,
        "importPath": "src.agents.strict_schema",
        "description": "src.agents.strict_schema",
        "peekOfCode": "def has_more_than_n_keys(obj: dict[str, object], n: int) -> bool:\n    i = 0\n    for _ in obj.keys():\n        i += 1\n        if i > n:\n            return True\n    return False",
        "detail": "src.agents.strict_schema",
        "documentation": {}
    },
    {
        "label": "_EMPTY_SCHEMA",
        "kind": 5,
        "importPath": "src.agents.strict_schema",
        "description": "src.agents.strict_schema",
        "peekOfCode": "_EMPTY_SCHEMA = {\n    \"additionalProperties\": False,\n    \"type\": \"object\",\n    \"properties\": {},\n    \"required\": [],\n}\ndef ensure_strict_json_schema(\n    schema: dict[str, Any],\n) -> dict[str, Any]:\n    \"\"\"Mutates the given JSON schema to ensure it conforms to the `strict` standard",
        "detail": "src.agents.strict_schema",
        "documentation": {}
    },
    {
        "label": "FunctionToolResult",
        "kind": 6,
        "importPath": "src.agents.tool",
        "description": "src.agents.tool",
        "peekOfCode": "class FunctionToolResult:\n    tool: FunctionTool\n    \"\"\"The tool that was run.\"\"\"\n    output: Any\n    \"\"\"The output of the tool.\"\"\"\n    run_item: RunItem\n    \"\"\"The run item that was produced as a result of the tool call.\"\"\"\n@dataclass\nclass FunctionTool:\n    \"\"\"A tool that wraps a function. In most cases, you should use  the `function_tool` helpers to",
        "detail": "src.agents.tool",
        "documentation": {}
    },
    {
        "label": "FunctionTool",
        "kind": 6,
        "importPath": "src.agents.tool",
        "description": "src.agents.tool",
        "peekOfCode": "class FunctionTool:\n    \"\"\"A tool that wraps a function. In most cases, you should use  the `function_tool` helpers to\n    create a FunctionTool, as they let you easily wrap a Python function.\n    \"\"\"\n    name: str\n    \"\"\"The name of the tool, as shown to the LLM. Generally the name of the function.\"\"\"\n    description: str\n    \"\"\"A description of the tool, as shown to the LLM.\"\"\"\n    params_json_schema: dict[str, Any]\n    \"\"\"The JSON schema for the tool's parameters.\"\"\"",
        "detail": "src.agents.tool",
        "documentation": {}
    },
    {
        "label": "FileSearchTool",
        "kind": 6,
        "importPath": "src.agents.tool",
        "description": "src.agents.tool",
        "peekOfCode": "class FileSearchTool:\n    \"\"\"A hosted tool that lets the LLM search through a vector store. Currently only supported with\n    OpenAI models, using the Responses API.\n    \"\"\"\n    vector_store_ids: list[str]\n    \"\"\"The IDs of the vector stores to search.\"\"\"\n    max_num_results: int | None = None\n    \"\"\"The maximum number of results to return.\"\"\"\n    include_search_results: bool = False\n    \"\"\"Whether to include the search results in the output produced by the LLM.\"\"\"",
        "detail": "src.agents.tool",
        "documentation": {}
    },
    {
        "label": "WebSearchTool",
        "kind": 6,
        "importPath": "src.agents.tool",
        "description": "src.agents.tool",
        "peekOfCode": "class WebSearchTool:\n    \"\"\"A hosted tool that lets the LLM search the web. Currently only supported with OpenAI models,\n    using the Responses API.\n    \"\"\"\n    user_location: UserLocation | None = None\n    \"\"\"Optional location for the search. Lets you customize results to be relevant to a location.\"\"\"\n    search_context_size: Literal[\"low\", \"medium\", \"high\"] = \"medium\"\n    \"\"\"The amount of context to use for the search.\"\"\"\n    @property\n    def name(self):",
        "detail": "src.agents.tool",
        "documentation": {}
    },
    {
        "label": "ComputerTool",
        "kind": 6,
        "importPath": "src.agents.tool",
        "description": "src.agents.tool",
        "peekOfCode": "class ComputerTool:\n    \"\"\"A hosted tool that lets the LLM control a computer.\"\"\"\n    computer: Computer | AsyncComputer\n    \"\"\"The computer implementation, which describes the environment and dimensions of the computer,\n    as well as implements the computer actions like click, screenshot, etc.\n    \"\"\"\n    @property\n    def name(self):\n        return \"computer_use_preview\"\nTool = Union[FunctionTool, FileSearchTool, WebSearchTool, ComputerTool]",
        "detail": "src.agents.tool",
        "documentation": {}
    },
    {
        "label": "default_tool_error_function",
        "kind": 2,
        "importPath": "src.agents.tool",
        "description": "src.agents.tool",
        "peekOfCode": "def default_tool_error_function(ctx: RunContextWrapper[Any], error: Exception) -> str:\n    \"\"\"The default tool error function, which just returns a generic error message.\"\"\"\n    return f\"An error occurred while running the tool. Please try again. Error: {str(error)}\"\nToolErrorFunction = Callable[[RunContextWrapper[Any], Exception], MaybeAwaitable[str]]\n@overload\ndef function_tool(\n    func: ToolFunction[...],\n    *,\n    name_override: str | None = None,\n    description_override: str | None = None,",
        "detail": "src.agents.tool",
        "documentation": {}
    },
    {
        "label": "function_tool",
        "kind": 2,
        "importPath": "src.agents.tool",
        "description": "src.agents.tool",
        "peekOfCode": "def function_tool(\n    func: ToolFunction[...],\n    *,\n    name_override: str | None = None,\n    description_override: str | None = None,\n    docstring_style: DocstringStyle | None = None,\n    use_docstring_info: bool = True,\n    failure_error_function: ToolErrorFunction | None = None,\n    strict_mode: bool = True,\n) -> FunctionTool:",
        "detail": "src.agents.tool",
        "documentation": {}
    },
    {
        "label": "function_tool",
        "kind": 2,
        "importPath": "src.agents.tool",
        "description": "src.agents.tool",
        "peekOfCode": "def function_tool(\n    *,\n    name_override: str | None = None,\n    description_override: str | None = None,\n    docstring_style: DocstringStyle | None = None,\n    use_docstring_info: bool = True,\n    failure_error_function: ToolErrorFunction | None = None,\n    strict_mode: bool = True,\n) -> Callable[[ToolFunction[...]], FunctionTool]:\n    \"\"\"Overload for usage as @function_tool(...).\"\"\"",
        "detail": "src.agents.tool",
        "documentation": {}
    },
    {
        "label": "function_tool",
        "kind": 2,
        "importPath": "src.agents.tool",
        "description": "src.agents.tool",
        "peekOfCode": "def function_tool(\n    func: ToolFunction[...] | None = None,\n    *,\n    name_override: str | None = None,\n    description_override: str | None = None,\n    docstring_style: DocstringStyle | None = None,\n    use_docstring_info: bool = True,\n    failure_error_function: ToolErrorFunction | None = default_tool_error_function,\n    strict_mode: bool = True,\n) -> FunctionTool | Callable[[ToolFunction[...]], FunctionTool]:",
        "detail": "src.agents.tool",
        "documentation": {}
    },
    {
        "label": "ToolParams",
        "kind": 5,
        "importPath": "src.agents.tool",
        "description": "src.agents.tool",
        "peekOfCode": "ToolParams = ParamSpec(\"ToolParams\")\nToolFunctionWithoutContext = Callable[ToolParams, Any]\nToolFunctionWithContext = Callable[Concatenate[RunContextWrapper[Any], ToolParams], Any]\nToolFunction = Union[\n    ToolFunctionWithoutContext[ToolParams], ToolFunctionWithContext[ToolParams]\n]\n@dataclass\nclass FunctionToolResult:\n    tool: FunctionTool\n    \"\"\"The tool that was run.\"\"\"",
        "detail": "src.agents.tool",
        "documentation": {}
    },
    {
        "label": "ToolFunctionWithoutContext",
        "kind": 5,
        "importPath": "src.agents.tool",
        "description": "src.agents.tool",
        "peekOfCode": "ToolFunctionWithoutContext = Callable[ToolParams, Any]\nToolFunctionWithContext = Callable[Concatenate[RunContextWrapper[Any], ToolParams], Any]\nToolFunction = Union[\n    ToolFunctionWithoutContext[ToolParams], ToolFunctionWithContext[ToolParams]\n]\n@dataclass\nclass FunctionToolResult:\n    tool: FunctionTool\n    \"\"\"The tool that was run.\"\"\"\n    output: Any",
        "detail": "src.agents.tool",
        "documentation": {}
    },
    {
        "label": "ToolFunctionWithContext",
        "kind": 5,
        "importPath": "src.agents.tool",
        "description": "src.agents.tool",
        "peekOfCode": "ToolFunctionWithContext = Callable[Concatenate[RunContextWrapper[Any], ToolParams], Any]\nToolFunction = Union[\n    ToolFunctionWithoutContext[ToolParams], ToolFunctionWithContext[ToolParams]\n]\n@dataclass\nclass FunctionToolResult:\n    tool: FunctionTool\n    \"\"\"The tool that was run.\"\"\"\n    output: Any\n    \"\"\"The output of the tool.\"\"\"",
        "detail": "src.agents.tool",
        "documentation": {}
    },
    {
        "label": "ToolFunction",
        "kind": 5,
        "importPath": "src.agents.tool",
        "description": "src.agents.tool",
        "peekOfCode": "ToolFunction = Union[\n    ToolFunctionWithoutContext[ToolParams], ToolFunctionWithContext[ToolParams]\n]\n@dataclass\nclass FunctionToolResult:\n    tool: FunctionTool\n    \"\"\"The tool that was run.\"\"\"\n    output: Any\n    \"\"\"The output of the tool.\"\"\"\n    run_item: RunItem",
        "detail": "src.agents.tool",
        "documentation": {}
    },
    {
        "label": "Tool",
        "kind": 5,
        "importPath": "src.agents.tool",
        "description": "src.agents.tool",
        "peekOfCode": "Tool = Union[FunctionTool, FileSearchTool, WebSearchTool, ComputerTool]\n\"\"\"A tool that can be used in an agent.\"\"\"\ndef default_tool_error_function(ctx: RunContextWrapper[Any], error: Exception) -> str:\n    \"\"\"The default tool error function, which just returns a generic error message.\"\"\"\n    return f\"An error occurred while running the tool. Please try again. Error: {str(error)}\"\nToolErrorFunction = Callable[[RunContextWrapper[Any], Exception], MaybeAwaitable[str]]\n@overload\ndef function_tool(\n    func: ToolFunction[...],\n    *,",
        "detail": "src.agents.tool",
        "documentation": {}
    },
    {
        "label": "ToolErrorFunction",
        "kind": 5,
        "importPath": "src.agents.tool",
        "description": "src.agents.tool",
        "peekOfCode": "ToolErrorFunction = Callable[[RunContextWrapper[Any], Exception], MaybeAwaitable[str]]\n@overload\ndef function_tool(\n    func: ToolFunction[...],\n    *,\n    name_override: str | None = None,\n    description_override: str | None = None,\n    docstring_style: DocstringStyle | None = None,\n    use_docstring_info: bool = True,\n    failure_error_function: ToolErrorFunction | None = None,",
        "detail": "src.agents.tool",
        "documentation": {}
    },
    {
        "label": "Usage",
        "kind": 6,
        "importPath": "src.agents.usage",
        "description": "src.agents.usage",
        "peekOfCode": "class Usage:\n    requests: int = 0\n    \"\"\"Total requests made to the LLM API.\"\"\"\n    input_tokens: int = 0\n    \"\"\"Total input tokens sent, across all requests.\"\"\"\n    output_tokens: int = 0\n    \"\"\"Total output tokens received, across all requests.\"\"\"\n    total_tokens: int = 0\n    \"\"\"Total tokens sent and received, across all requests.\"\"\"\n    def add(self, other: \"Usage\") -> None:",
        "detail": "src.agents.usage",
        "documentation": {}
    },
    {
        "label": "setup_span_processor",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def setup_span_processor():\n    set_trace_processors([SPAN_PROCESSOR_TESTING])\n# This fixture will run before each test\n@pytest.fixture(autouse=True)\ndef clear_span_processor():\n    SPAN_PROCESSOR_TESTING.force_flush()\n    SPAN_PROCESSOR_TESTING.shutdown()\n    SPAN_PROCESSOR_TESTING.clear()\n# This fixture will run before each test\n@pytest.fixture(autouse=True)",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "clear_span_processor",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def clear_span_processor():\n    SPAN_PROCESSOR_TESTING.force_flush()\n    SPAN_PROCESSOR_TESTING.shutdown()\n    SPAN_PROCESSOR_TESTING.clear()\n# This fixture will run before each test\n@pytest.fixture(autouse=True)\ndef clear_openai_settings():\n    _openai_shared._default_openai_key = None\n    _openai_shared._default_openai_client = None\n    _openai_shared._use_responses_by_default = True",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "clear_openai_settings",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def clear_openai_settings():\n    _openai_shared._default_openai_key = None\n    _openai_shared._default_openai_client = None\n    _openai_shared._use_responses_by_default = True\n# This fixture will run after all tests end\n@pytest.fixture(autouse=True, scope=\"session\")\ndef shutdown_trace_provider():\n    yield\n    GLOBAL_TRACE_PROVIDER.shutdown()\n@pytest.fixture(autouse=True)",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "shutdown_trace_provider",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def shutdown_trace_provider():\n    yield\n    GLOBAL_TRACE_PROVIDER.shutdown()\n@pytest.fixture(autouse=True)\ndef disable_real_model_clients(monkeypatch, request):\n    # If the test is marked to allow the method call, don't override it.\n    if request.node.get_closest_marker(\"allow_call_model_methods\"):\n        return\n    def failing_version(*args, **kwargs):\n        pytest.fail(\"Real models should not be used in tests!\")",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "disable_real_model_clients",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def disable_real_model_clients(monkeypatch, request):\n    # If the test is marked to allow the method call, don't override it.\n    if request.node.get_closest_marker(\"allow_call_model_methods\"):\n        return\n    def failing_version(*args, **kwargs):\n        pytest.fail(\"Real models should not be used in tests!\")\n    monkeypatch.setattr(OpenAIResponsesModel, \"get_response\", failing_version)\n    monkeypatch.setattr(OpenAIResponsesModel, \"stream_response\", failing_version)\n    monkeypatch.setattr(OpenAIChatCompletionsModel, \"get_response\", failing_version)\n    monkeypatch.setattr(OpenAIChatCompletionsModel, \"stream_response\", failing_version)",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "FakeModel",
        "kind": 6,
        "importPath": "tests.fake_model",
        "description": "tests.fake_model",
        "peekOfCode": "class FakeModel(Model):\n    def __init__(\n        self,\n        tracing_enabled: bool = False,\n        initial_output: list[TResponseOutputItem] | Exception | None = None,\n    ):\n        if initial_output is None:\n            initial_output = []\n        self.turn_outputs: list[list[TResponseOutputItem] | Exception] = (\n            [initial_output] if initial_output else []",
        "detail": "tests.fake_model",
        "documentation": {}
    },
    {
        "label": "get_response_obj",
        "kind": 2,
        "importPath": "tests.fake_model",
        "description": "tests.fake_model",
        "peekOfCode": "def get_response_obj(output: list[TResponseOutputItem], response_id: str | None = None) -> Response:\n    return Response(\n        id=response_id or \"123\",\n        created_at=123,\n        model=\"test_model\",\n        object=\"response\",\n        output=output,\n        tool_choice=\"none\",\n        tools=[],\n        top_p=None,",
        "detail": "tests.fake_model",
        "documentation": {}
    },
    {
        "label": "Foo",
        "kind": 6,
        "importPath": "tests.test_agent_config",
        "description": "tests.test_agent_config",
        "peekOfCode": "class Foo(BaseModel):\n    bar: str\n@pytest.mark.asyncio\nasync def test_agent_final_output():\n    agent = Agent(\n        name=\"test\",\n        output_type=Foo,\n    )\n    schema = Runner._get_output_schema(agent)\n    assert schema is not None",
        "detail": "tests.test_agent_config",
        "documentation": {}
    },
    {
        "label": "AgentHooksForTests",
        "kind": 6,
        "importPath": "tests.test_agent_hooks",
        "description": "tests.test_agent_hooks",
        "peekOfCode": "class AgentHooksForTests(AgentHooks):\n    def __init__(self):\n        self.events: dict[str, int] = defaultdict(int)\n    def reset(self):\n        self.events.clear()\n    async def on_start(self, context: RunContextWrapper[TContext], agent: Agent[TContext]) -> None:\n        self.events[\"on_start\"] += 1\n    async def on_end(\n        self,\n        context: RunContextWrapper[TContext],",
        "detail": "tests.test_agent_hooks",
        "documentation": {}
    },
    {
        "label": "Foo",
        "kind": 6,
        "importPath": "tests.test_agent_hooks",
        "description": "tests.test_agent_hooks",
        "peekOfCode": "class Foo(TypedDict):\n    a: str\n@pytest.mark.asyncio\nasync def test_structed_output_non_streamed_agent_hooks():\n    hooks = AgentHooksForTests()\n    model = FakeModel()\n    agent_1 = Agent(name=\"test_1\", model=model)\n    agent_2 = Agent(name=\"test_2\", model=model)\n    agent_3 = Agent(\n        name=\"test_3\",",
        "detail": "tests.test_agent_hooks",
        "documentation": {}
    },
    {
        "label": "EmptyAgentHooks",
        "kind": 6,
        "importPath": "tests.test_agent_hooks",
        "description": "tests.test_agent_hooks",
        "peekOfCode": "class EmptyAgentHooks(AgentHooks):\n    pass\n@pytest.mark.asyncio\nasync def test_base_agent_hooks_dont_crash():\n    hooks = EmptyAgentHooks()\n    model = FakeModel()\n    agent_1 = Agent(name=\"test_1\", model=model)\n    agent_2 = Agent(name=\"test_2\", model=model)\n    agent_3 = Agent(\n        name=\"test_3\",",
        "detail": "tests.test_agent_hooks",
        "documentation": {}
    },
    {
        "label": "Foo",
        "kind": 6,
        "importPath": "tests.test_agent_runner",
        "description": "tests.test_agent_runner",
        "peekOfCode": "class Foo(TypedDict):\n    bar: str\n@pytest.mark.asyncio\nasync def test_structured_output():\n    model = FakeModel()\n    agent_1 = Agent(\n        name=\"test\",\n        model=model,\n        tools=[get_function_tool(\"bar\", \"bar_result\")],\n        output_type=Foo,",
        "detail": "tests.test_agent_runner",
        "documentation": {}
    },
    {
        "label": "remove_new_items",
        "kind": 2,
        "importPath": "tests.test_agent_runner",
        "description": "tests.test_agent_runner",
        "peekOfCode": "def remove_new_items(handoff_input_data: HandoffInputData) -> HandoffInputData:\n    return HandoffInputData(\n        input_history=handoff_input_data.input_history,\n        pre_handoff_items=(),\n        new_items=(),\n    )\n@pytest.mark.asyncio\nasync def test_handoff_filters():\n    model = FakeModel()\n    agent_1 = Agent(",
        "detail": "tests.test_agent_runner",
        "documentation": {}
    },
    {
        "label": "test_tool_one",
        "kind": 2,
        "importPath": "tests.test_agent_runner",
        "description": "tests.test_agent_runner",
        "peekOfCode": "def test_tool_one():\n    return Foo(bar=\"tool_one_result\")\n@function_tool\ndef test_tool_two():\n    return \"tool_two_result\"\n@pytest.mark.asyncio\nasync def test_tool_use_behavior_first_output():\n    model = FakeModel()\n    agent = Agent(\n        name=\"test\",",
        "detail": "tests.test_agent_runner",
        "documentation": {}
    },
    {
        "label": "test_tool_two",
        "kind": 2,
        "importPath": "tests.test_agent_runner",
        "description": "tests.test_agent_runner",
        "peekOfCode": "def test_tool_two():\n    return \"tool_two_result\"\n@pytest.mark.asyncio\nasync def test_tool_use_behavior_first_output():\n    model = FakeModel()\n    agent = Agent(\n        name=\"test\",\n        model=model,\n        tools=[get_function_tool(\"foo\", \"tool_result\"), test_tool_one, test_tool_two],\n        tool_use_behavior=\"stop_on_first_tool\",",
        "detail": "tests.test_agent_runner",
        "documentation": {}
    },
    {
        "label": "custom_tool_use_behavior",
        "kind": 2,
        "importPath": "tests.test_agent_runner",
        "description": "tests.test_agent_runner",
        "peekOfCode": "def custom_tool_use_behavior(\n    context: RunContextWrapper[Any], results: list[FunctionToolResult]\n) -> ToolsToFinalOutputResult:\n    if \"test_tool_one\" in [result.tool.name for result in results]:\n        return ToolsToFinalOutputResult(is_final_output=True, final_output=\"the_final_output\")\n    else:\n        return ToolsToFinalOutputResult(is_final_output=False, final_output=None)\n@pytest.mark.asyncio\nasync def test_tool_use_behavior_custom_function():\n    model = FakeModel()",
        "detail": "tests.test_agent_runner",
        "documentation": {}
    },
    {
        "label": "Foo",
        "kind": 6,
        "importPath": "tests.test_agent_runner_streamed",
        "description": "tests.test_agent_runner_streamed",
        "peekOfCode": "class Foo(TypedDict):\n    bar: str\n@pytest.mark.asyncio\nasync def test_structured_output():\n    model = FakeModel()\n    agent_1 = Agent(\n        name=\"test\",\n        model=model,\n        tools=[get_function_tool(\"bar\", \"bar_result\")],\n        output_type=Foo,",
        "detail": "tests.test_agent_runner_streamed",
        "documentation": {}
    },
    {
        "label": "remove_new_items",
        "kind": 2,
        "importPath": "tests.test_agent_runner_streamed",
        "description": "tests.test_agent_runner_streamed",
        "peekOfCode": "def remove_new_items(handoff_input_data: HandoffInputData) -> HandoffInputData:\n    return HandoffInputData(\n        input_history=handoff_input_data.input_history,\n        pre_handoff_items=(),\n        new_items=(),\n    )\n@pytest.mark.asyncio\nasync def test_handoff_filters():\n    model = FakeModel()\n    agent_1 = Agent(",
        "detail": "tests.test_agent_runner_streamed",
        "documentation": {}
    },
    {
        "label": "LoggingComputer",
        "kind": 6,
        "importPath": "tests.test_computer_action",
        "description": "tests.test_computer_action",
        "peekOfCode": "class LoggingComputer(Computer):\n    \"\"\"A `Computer` implementation that logs calls to its methods for verification in tests.\"\"\"\n    def __init__(self, screenshot_return: str = \"screenshot\"):\n        self.calls: list[tuple[str, tuple[Any, ...]]] = []\n        self._screenshot_return = screenshot_return\n    @property\n    def environment(self):\n        return \"mac\"\n    @property\n    def dimensions(self) -> tuple[int, int]:",
        "detail": "tests.test_computer_action",
        "documentation": {}
    },
    {
        "label": "LoggingAsyncComputer",
        "kind": 6,
        "importPath": "tests.test_computer_action",
        "description": "tests.test_computer_action",
        "peekOfCode": "class LoggingAsyncComputer(AsyncComputer):\n    \"\"\"An `AsyncComputer` implementation that logs calls to its methods for verification.\"\"\"\n    def __init__(self, screenshot_return: str = \"async_screenshot\"):\n        self.calls: list[tuple[str, tuple[Any, ...]]] = []\n        self._screenshot_return = screenshot_return\n    @property\n    def environment(self):\n        return \"mac\"\n    @property\n    def dimensions(self) -> tuple[int, int]:",
        "detail": "tests.test_computer_action",
        "documentation": {}
    },
    {
        "label": "LoggingRunHooks",
        "kind": 6,
        "importPath": "tests.test_computer_action",
        "description": "tests.test_computer_action",
        "peekOfCode": "class LoggingRunHooks(RunHooks[Any]):\n    \"\"\"Capture on_tool_start and on_tool_end invocations.\"\"\"\n    def __init__(self) -> None:\n        super().__init__()\n        self.started: list[tuple[Agent[Any], Any]] = []\n        self.ended: list[tuple[Agent[Any], Any, str]] = []\n    async def on_tool_start(\n        self, context: RunContextWrapper[Any], agent: Agent[Any], tool: Any, tool_call: Any\n    ) -> None:\n        self.started.append((agent, tool))",
        "detail": "tests.test_computer_action",
        "documentation": {}
    },
    {
        "label": "LoggingAgentHooks",
        "kind": 6,
        "importPath": "tests.test_computer_action",
        "description": "tests.test_computer_action",
        "peekOfCode": "class LoggingAgentHooks(AgentHooks[Any]):\n    \"\"\"Minimal override to capture agent's tool hook invocations.\"\"\"\n    def __init__(self) -> None:\n        super().__init__()\n        self.started: list[tuple[Agent[Any], Any]] = []\n        self.ended: list[tuple[Agent[Any], Any, str]] = []\n    async def on_tool_start(\n        self, context: RunContextWrapper[Any], agent: Agent[Any], tool: Any, tool_call: Any,\n    ) -> None:\n        self.started.append((agent, tool))",
        "detail": "tests.test_computer_action",
        "documentation": {}
    },
    {
        "label": "test_cc_no_default_key_errors",
        "kind": 2,
        "importPath": "tests.test_config",
        "description": "tests.test_config",
        "peekOfCode": "def test_cc_no_default_key_errors(monkeypatch):\n    monkeypatch.delenv(\"OPENAI_API_KEY\", raising=False)\n    with pytest.raises(openai.OpenAIError):\n        OpenAIProvider(use_responses=False).get_model(\"gpt-4\")\ndef test_cc_set_default_openai_key():\n    set_default_openai_key(\"test_key\")\n    chat_model = OpenAIProvider(use_responses=False).get_model(\"gpt-4\")\n    assert chat_model._client.api_key == \"test_key\"  # type: ignore\ndef test_cc_set_default_openai_client():\n    client = openai.AsyncOpenAI(api_key=\"test_key\")",
        "detail": "tests.test_config",
        "documentation": {}
    },
    {
        "label": "test_cc_set_default_openai_key",
        "kind": 2,
        "importPath": "tests.test_config",
        "description": "tests.test_config",
        "peekOfCode": "def test_cc_set_default_openai_key():\n    set_default_openai_key(\"test_key\")\n    chat_model = OpenAIProvider(use_responses=False).get_model(\"gpt-4\")\n    assert chat_model._client.api_key == \"test_key\"  # type: ignore\ndef test_cc_set_default_openai_client():\n    client = openai.AsyncOpenAI(api_key=\"test_key\")\n    set_default_openai_client(client)\n    chat_model = OpenAIProvider(use_responses=False).get_model(\"gpt-4\")\n    assert chat_model._client.api_key == \"test_key\"  # type: ignore\ndef test_resp_no_default_key_errors(monkeypatch):",
        "detail": "tests.test_config",
        "documentation": {}
    },
    {
        "label": "test_cc_set_default_openai_client",
        "kind": 2,
        "importPath": "tests.test_config",
        "description": "tests.test_config",
        "peekOfCode": "def test_cc_set_default_openai_client():\n    client = openai.AsyncOpenAI(api_key=\"test_key\")\n    set_default_openai_client(client)\n    chat_model = OpenAIProvider(use_responses=False).get_model(\"gpt-4\")\n    assert chat_model._client.api_key == \"test_key\"  # type: ignore\ndef test_resp_no_default_key_errors(monkeypatch):\n    monkeypatch.delenv(\"OPENAI_API_KEY\", raising=False)\n    assert os.getenv(\"OPENAI_API_KEY\") is None\n    with pytest.raises(openai.OpenAIError):\n        OpenAIProvider(use_responses=True).get_model(\"gpt-4\")",
        "detail": "tests.test_config",
        "documentation": {}
    },
    {
        "label": "test_resp_no_default_key_errors",
        "kind": 2,
        "importPath": "tests.test_config",
        "description": "tests.test_config",
        "peekOfCode": "def test_resp_no_default_key_errors(monkeypatch):\n    monkeypatch.delenv(\"OPENAI_API_KEY\", raising=False)\n    assert os.getenv(\"OPENAI_API_KEY\") is None\n    with pytest.raises(openai.OpenAIError):\n        OpenAIProvider(use_responses=True).get_model(\"gpt-4\")\ndef test_resp_set_default_openai_key():\n    set_default_openai_key(\"test_key\")\n    resp_model = OpenAIProvider(use_responses=True).get_model(\"gpt-4\")\n    assert resp_model._client.api_key == \"test_key\"  # type: ignore\ndef test_resp_set_default_openai_client():",
        "detail": "tests.test_config",
        "documentation": {}
    },
    {
        "label": "test_resp_set_default_openai_key",
        "kind": 2,
        "importPath": "tests.test_config",
        "description": "tests.test_config",
        "peekOfCode": "def test_resp_set_default_openai_key():\n    set_default_openai_key(\"test_key\")\n    resp_model = OpenAIProvider(use_responses=True).get_model(\"gpt-4\")\n    assert resp_model._client.api_key == \"test_key\"  # type: ignore\ndef test_resp_set_default_openai_client():\n    client = openai.AsyncOpenAI(api_key=\"test_key\")\n    set_default_openai_client(client)\n    resp_model = OpenAIProvider(use_responses=True).get_model(\"gpt-4\")\n    assert resp_model._client.api_key == \"test_key\"  # type: ignore\ndef test_set_default_openai_api():",
        "detail": "tests.test_config",
        "documentation": {}
    },
    {
        "label": "test_resp_set_default_openai_client",
        "kind": 2,
        "importPath": "tests.test_config",
        "description": "tests.test_config",
        "peekOfCode": "def test_resp_set_default_openai_client():\n    client = openai.AsyncOpenAI(api_key=\"test_key\")\n    set_default_openai_client(client)\n    resp_model = OpenAIProvider(use_responses=True).get_model(\"gpt-4\")\n    assert resp_model._client.api_key == \"test_key\"  # type: ignore\ndef test_set_default_openai_api():\n    assert isinstance(OpenAIProvider().get_model(\"gpt-4\"), OpenAIResponsesModel), (\n        \"Default should be responses\"\n    )\n    set_default_openai_api(\"chat_completions\")",
        "detail": "tests.test_config",
        "documentation": {}
    },
    {
        "label": "test_set_default_openai_api",
        "kind": 2,
        "importPath": "tests.test_config",
        "description": "tests.test_config",
        "peekOfCode": "def test_set_default_openai_api():\n    assert isinstance(OpenAIProvider().get_model(\"gpt-4\"), OpenAIResponsesModel), (\n        \"Default should be responses\"\n    )\n    set_default_openai_api(\"chat_completions\")\n    assert isinstance(OpenAIProvider().get_model(\"gpt-4\"), OpenAIChatCompletionsModel), (\n        \"Should be chat completions model\"\n    )\n    set_default_openai_api(\"responses\")\n    assert isinstance(OpenAIProvider().get_model(\"gpt-4\"), OpenAIResponsesModel), (",
        "detail": "tests.test_config",
        "documentation": {}
    },
    {
        "label": "Bar",
        "kind": 6,
        "importPath": "tests.test_doc_parsing",
        "description": "tests.test_doc_parsing",
        "peekOfCode": "class Bar:\n    def func_bar(self, a: int, b: float) -> str:\n        \"\"\"\n        This is func_bar.\n        Args:\n            a: The first argument.\n            b: The second argument.\n        Returns:\n            A result\n        \"\"\"",
        "detail": "tests.test_doc_parsing",
        "documentation": {}
    },
    {
        "label": "func_foo_google",
        "kind": 2,
        "importPath": "tests.test_doc_parsing",
        "description": "tests.test_doc_parsing",
        "peekOfCode": "def func_foo_google(a: int, b: float) -> str:\n    \"\"\"\n    This is func_foo.\n    Args:\n        a: The first argument.\n        b: The second argument.\n    Returns:\n        A result\n    \"\"\"\n    return \"ok\"",
        "detail": "tests.test_doc_parsing",
        "documentation": {}
    },
    {
        "label": "func_foo_numpy",
        "kind": 2,
        "importPath": "tests.test_doc_parsing",
        "description": "tests.test_doc_parsing",
        "peekOfCode": "def func_foo_numpy(a: int, b: float) -> str:\n    \"\"\"\n    This is func_foo.\n    Parameters\n    ----------\n    a: int\n        The first argument.\n    b: float\n        The second argument.\n    Returns",
        "detail": "tests.test_doc_parsing",
        "documentation": {}
    },
    {
        "label": "func_foo_sphinx",
        "kind": 2,
        "importPath": "tests.test_doc_parsing",
        "description": "tests.test_doc_parsing",
        "peekOfCode": "def func_foo_sphinx(a: int, b: float) -> str:\n    \"\"\"\n    This is func_foo.\n    :param a: The first argument.\n    :param b: The second argument.\n    :return: A result\n    \"\"\"\n    return \"ok\"\nclass Bar:\n    def func_bar(self, a: int, b: float) -> str:",
        "detail": "tests.test_doc_parsing",
        "documentation": {}
    },
    {
        "label": "test_functions_are_ok",
        "kind": 2,
        "importPath": "tests.test_doc_parsing",
        "description": "tests.test_doc_parsing",
        "peekOfCode": "def test_functions_are_ok():\n    func_foo_google(1, 2.0)\n    func_foo_numpy(1, 2.0)\n    func_foo_sphinx(1, 2.0)\n    Bar().func_bar(1, 2.0)\n    Bar.func_baz(1, 2.0)\ndef test_auto_detection() -> None:\n    doc = generate_func_documentation(func_foo_google)\n    assert doc.name == \"func_foo_google\"\n    assert doc.description == \"This is func_foo.\"",
        "detail": "tests.test_doc_parsing",
        "documentation": {}
    },
    {
        "label": "test_auto_detection",
        "kind": 2,
        "importPath": "tests.test_doc_parsing",
        "description": "tests.test_doc_parsing",
        "peekOfCode": "def test_auto_detection() -> None:\n    doc = generate_func_documentation(func_foo_google)\n    assert doc.name == \"func_foo_google\"\n    assert doc.description == \"This is func_foo.\"\n    assert doc.param_descriptions == {\"a\": \"The first argument.\", \"b\": \"The second argument.\"}\n    doc = generate_func_documentation(func_foo_numpy)\n    assert doc.name == \"func_foo_numpy\"\n    assert doc.description == \"This is func_foo.\"\n    assert doc.param_descriptions == {\"a\": \"The first argument.\", \"b\": \"The second argument.\"}\n    doc = generate_func_documentation(func_foo_sphinx)",
        "detail": "tests.test_doc_parsing",
        "documentation": {}
    },
    {
        "label": "test_instance_method",
        "kind": 2,
        "importPath": "tests.test_doc_parsing",
        "description": "tests.test_doc_parsing",
        "peekOfCode": "def test_instance_method() -> None:\n    bar = Bar()\n    doc = generate_func_documentation(bar.func_bar)\n    assert doc.name == \"func_bar\"\n    assert doc.description == \"This is func_bar.\"\n    assert doc.param_descriptions == {\"a\": \"The first argument.\", \"b\": \"The second argument.\"}\ndef test_classmethod() -> None:\n    doc = generate_func_documentation(Bar.func_baz)\n    assert doc.name == \"func_baz\"\n    assert doc.description == \"This is func_baz.\"",
        "detail": "tests.test_doc_parsing",
        "documentation": {}
    },
    {
        "label": "test_classmethod",
        "kind": 2,
        "importPath": "tests.test_doc_parsing",
        "description": "tests.test_doc_parsing",
        "peekOfCode": "def test_classmethod() -> None:\n    doc = generate_func_documentation(Bar.func_baz)\n    assert doc.name == \"func_baz\"\n    assert doc.description == \"This is func_baz.\"\n    assert doc.param_descriptions == {\"a\": \"The first argument.\", \"b\": \"The second argument.\"}",
        "detail": "tests.test_doc_parsing",
        "documentation": {}
    },
    {
        "label": "fake_agent",
        "kind": 2,
        "importPath": "tests.test_extension_filters",
        "description": "tests.test_extension_filters",
        "peekOfCode": "def fake_agent():\n    return Agent(\n        name=\"fake_agent\",\n    )\ndef _get_message_input_item(content: str) -> TResponseInputItem:\n    return {\n        \"role\": \"assistant\",\n        \"content\": content,\n    }\ndef _get_function_result_input_item(content: str) -> TResponseInputItem:",
        "detail": "tests.test_extension_filters",
        "documentation": {}
    },
    {
        "label": "test_empty_data",
        "kind": 2,
        "importPath": "tests.test_extension_filters",
        "description": "tests.test_extension_filters",
        "peekOfCode": "def test_empty_data():\n    handoff_input_data = HandoffInputData(input_history=(), pre_handoff_items=(), new_items=())\n    filtered_data = remove_all_tools(handoff_input_data)\n    assert filtered_data == handoff_input_data\ndef test_str_historyonly():\n    handoff_input_data = HandoffInputData(input_history=\"Hello\", pre_handoff_items=(), new_items=())\n    filtered_data = remove_all_tools(handoff_input_data)\n    assert filtered_data == handoff_input_data\ndef test_str_history_and_list():\n    handoff_input_data = HandoffInputData(",
        "detail": "tests.test_extension_filters",
        "documentation": {}
    },
    {
        "label": "test_str_historyonly",
        "kind": 2,
        "importPath": "tests.test_extension_filters",
        "description": "tests.test_extension_filters",
        "peekOfCode": "def test_str_historyonly():\n    handoff_input_data = HandoffInputData(input_history=\"Hello\", pre_handoff_items=(), new_items=())\n    filtered_data = remove_all_tools(handoff_input_data)\n    assert filtered_data == handoff_input_data\ndef test_str_history_and_list():\n    handoff_input_data = HandoffInputData(\n        input_history=\"Hello\",\n        pre_handoff_items=(),\n        new_items=(_get_message_output_run_item(\"Hello\"),),\n    )",
        "detail": "tests.test_extension_filters",
        "documentation": {}
    },
    {
        "label": "test_str_history_and_list",
        "kind": 2,
        "importPath": "tests.test_extension_filters",
        "description": "tests.test_extension_filters",
        "peekOfCode": "def test_str_history_and_list():\n    handoff_input_data = HandoffInputData(\n        input_history=\"Hello\",\n        pre_handoff_items=(),\n        new_items=(_get_message_output_run_item(\"Hello\"),),\n    )\n    filtered_data = remove_all_tools(handoff_input_data)\n    assert filtered_data == handoff_input_data\ndef test_list_history_and_list():\n    handoff_input_data = HandoffInputData(",
        "detail": "tests.test_extension_filters",
        "documentation": {}
    },
    {
        "label": "test_list_history_and_list",
        "kind": 2,
        "importPath": "tests.test_extension_filters",
        "description": "tests.test_extension_filters",
        "peekOfCode": "def test_list_history_and_list():\n    handoff_input_data = HandoffInputData(\n        input_history=(_get_message_input_item(\"Hello\"),),\n        pre_handoff_items=(_get_message_output_run_item(\"123\"),),\n        new_items=(_get_message_output_run_item(\"World\"),),\n    )\n    filtered_data = remove_all_tools(handoff_input_data)\n    assert filtered_data == handoff_input_data\ndef test_removes_tools_from_history():\n    handoff_input_data = HandoffInputData(",
        "detail": "tests.test_extension_filters",
        "documentation": {}
    },
    {
        "label": "test_removes_tools_from_history",
        "kind": 2,
        "importPath": "tests.test_extension_filters",
        "description": "tests.test_extension_filters",
        "peekOfCode": "def test_removes_tools_from_history():\n    handoff_input_data = HandoffInputData(\n        input_history=(\n            _get_message_input_item(\"Hello1\"),\n            _get_function_result_input_item(\"World\"),\n            _get_message_input_item(\"Hello2\"),\n        ),\n        pre_handoff_items=(\n            _get_tool_output_run_item(\"abc\"),\n            _get_message_output_run_item(\"123\"),",
        "detail": "tests.test_extension_filters",
        "documentation": {}
    },
    {
        "label": "test_removes_tools_from_new_items",
        "kind": 2,
        "importPath": "tests.test_extension_filters",
        "description": "tests.test_extension_filters",
        "peekOfCode": "def test_removes_tools_from_new_items():\n    handoff_input_data = HandoffInputData(\n        input_history=(),\n        pre_handoff_items=(),\n        new_items=(\n            _get_message_output_run_item(\"Hello\"),\n            _get_tool_output_run_item(\"World\"),\n        ),\n    )\n    filtered_data = remove_all_tools(handoff_input_data)",
        "detail": "tests.test_extension_filters",
        "documentation": {}
    },
    {
        "label": "test_removes_tools_from_new_items_and_history",
        "kind": 2,
        "importPath": "tests.test_extension_filters",
        "description": "tests.test_extension_filters",
        "peekOfCode": "def test_removes_tools_from_new_items_and_history():\n    handoff_input_data = HandoffInputData(\n        input_history=(\n            _get_message_input_item(\"Hello1\"),\n            _get_function_result_input_item(\"World\"),\n            _get_message_input_item(\"Hello2\"),\n        ),\n        pre_handoff_items=(\n            _get_message_output_run_item(\"123\"),\n            _get_tool_output_run_item(\"456\"),",
        "detail": "tests.test_extension_filters",
        "documentation": {}
    },
    {
        "label": "test_removes_handoffs_from_history",
        "kind": 2,
        "importPath": "tests.test_extension_filters",
        "description": "tests.test_extension_filters",
        "peekOfCode": "def test_removes_handoffs_from_history():\n    handoff_input_data = HandoffInputData(\n        input_history=(\n            _get_message_input_item(\"Hello1\"),\n            _get_handoff_input_item(\"World\"),\n        ),\n        pre_handoff_items=(\n            _get_message_output_run_item(\"Hello\"),\n            _get_tool_output_run_item(\"World\"),\n            _get_handoff_output_run_item(\"World\"),",
        "detail": "tests.test_extension_filters",
        "documentation": {}
    },
    {
        "label": "Foo",
        "kind": 6,
        "importPath": "tests.test_function_schema",
        "description": "tests.test_function_schema",
        "peekOfCode": "class Foo(TypedDict):\n    a: int\n    b: str\nclass InnerModel(BaseModel):\n    a: int\n    b: str\nclass OuterModel(BaseModel):\n    inner: InnerModel\n    foo: Foo\ndef complex_args_function(model: OuterModel) -> str:",
        "detail": "tests.test_function_schema",
        "documentation": {}
    },
    {
        "label": "InnerModel",
        "kind": 6,
        "importPath": "tests.test_function_schema",
        "description": "tests.test_function_schema",
        "peekOfCode": "class InnerModel(BaseModel):\n    a: int\n    b: str\nclass OuterModel(BaseModel):\n    inner: InnerModel\n    foo: Foo\ndef complex_args_function(model: OuterModel) -> str:\n    return f\"{model.inner.a}, {model.inner.b}, {model.foo['a']}, {model.foo['b']}\"\ndef test_nested_data_function():\n    func_schema = function_schema(complex_args_function)",
        "detail": "tests.test_function_schema",
        "documentation": {}
    },
    {
        "label": "OuterModel",
        "kind": 6,
        "importPath": "tests.test_function_schema",
        "description": "tests.test_function_schema",
        "peekOfCode": "class OuterModel(BaseModel):\n    inner: InnerModel\n    foo: Foo\ndef complex_args_function(model: OuterModel) -> str:\n    return f\"{model.inner.a}, {model.inner.b}, {model.foo['a']}, {model.foo['b']}\"\ndef test_nested_data_function():\n    func_schema = function_schema(complex_args_function)\n    assert isinstance(func_schema.params_json_schema, dict)\n    assert func_schema.params_json_schema.get(\"title\") == \"complex_args_function_args\"\n    # Valid input",
        "detail": "tests.test_function_schema",
        "documentation": {}
    },
    {
        "label": "MyClass",
        "kind": 6,
        "importPath": "tests.test_function_schema",
        "description": "tests.test_function_schema",
        "peekOfCode": "class MyClass:\n    def foo(self, a: int, b: int = 5):\n        return a + b\n    def foo_ctx(self, ctx: RunContextWrapper[str], a: int, b: int = 5):\n        return a + b\n    @classmethod\n    def bar(cls, a: int, b: int = 5):\n        return a + b\n    @classmethod\n    def bar_ctx(cls, ctx: RunContextWrapper[str], a: int, b: int = 5):",
        "detail": "tests.test_function_schema",
        "documentation": {}
    },
    {
        "label": "MyEnum",
        "kind": 6,
        "importPath": "tests.test_function_schema",
        "description": "tests.test_function_schema",
        "peekOfCode": "class MyEnum(str, Enum):\n    FOO = \"foo\"\n    BAR = \"bar\"\n    BAZ = \"baz\"\ndef enum_and_literal_function(a: MyEnum, b: Literal[\"a\", \"b\", \"c\"]) -> str:\n    return f\"{a.value} {b}\"\ndef test_enum_and_literal_function():\n    func_schema = function_schema(enum_and_literal_function)\n    assert isinstance(func_schema.params_json_schema, dict)\n    assert func_schema.params_json_schema.get(\"title\") == \"enum_and_literal_function_args\"",
        "detail": "tests.test_function_schema",
        "documentation": {}
    },
    {
        "label": "no_args_function",
        "kind": 2,
        "importPath": "tests.test_function_schema",
        "description": "tests.test_function_schema",
        "peekOfCode": "def no_args_function():\n    \"\"\"This function has no args.\"\"\"\n    return \"ok\"\ndef test_no_args_function():\n    func_schema = function_schema(no_args_function)\n    assert func_schema.params_json_schema.get(\"title\") == \"no_args_function_args\"\n    assert func_schema.description == \"This function has no args.\"\n    assert not func_schema.takes_context\n    parsed = func_schema.params_pydantic_model()\n    args, kwargs_dict = func_schema.to_call_args(parsed)",
        "detail": "tests.test_function_schema",
        "documentation": {}
    },
    {
        "label": "test_no_args_function",
        "kind": 2,
        "importPath": "tests.test_function_schema",
        "description": "tests.test_function_schema",
        "peekOfCode": "def test_no_args_function():\n    func_schema = function_schema(no_args_function)\n    assert func_schema.params_json_schema.get(\"title\") == \"no_args_function_args\"\n    assert func_schema.description == \"This function has no args.\"\n    assert not func_schema.takes_context\n    parsed = func_schema.params_pydantic_model()\n    args, kwargs_dict = func_schema.to_call_args(parsed)\n    result = no_args_function(*args, **kwargs_dict)\n    assert result == \"ok\"\ndef no_args_function_with_context(ctx: RunContextWrapper[str]):",
        "detail": "tests.test_function_schema",
        "documentation": {}
    },
    {
        "label": "no_args_function_with_context",
        "kind": 2,
        "importPath": "tests.test_function_schema",
        "description": "tests.test_function_schema",
        "peekOfCode": "def no_args_function_with_context(ctx: RunContextWrapper[str]):\n    return \"ok\"\ndef test_no_args_function_with_context() -> None:\n    func_schema = function_schema(no_args_function_with_context)\n    assert func_schema.takes_context\n    context = RunContextWrapper(context=\"test\")\n    parsed = func_schema.params_pydantic_model()\n    args, kwargs_dict = func_schema.to_call_args(parsed)\n    result = no_args_function_with_context(context, *args, **kwargs_dict)\n    assert result == \"ok\"",
        "detail": "tests.test_function_schema",
        "documentation": {}
    },
    {
        "label": "test_no_args_function_with_context",
        "kind": 2,
        "importPath": "tests.test_function_schema",
        "description": "tests.test_function_schema",
        "peekOfCode": "def test_no_args_function_with_context() -> None:\n    func_schema = function_schema(no_args_function_with_context)\n    assert func_schema.takes_context\n    context = RunContextWrapper(context=\"test\")\n    parsed = func_schema.params_pydantic_model()\n    args, kwargs_dict = func_schema.to_call_args(parsed)\n    result = no_args_function_with_context(context, *args, **kwargs_dict)\n    assert result == \"ok\"\ndef simple_function(a: int, b: int = 5):\n    \"\"\"",
        "detail": "tests.test_function_schema",
        "documentation": {}
    },
    {
        "label": "simple_function",
        "kind": 2,
        "importPath": "tests.test_function_schema",
        "description": "tests.test_function_schema",
        "peekOfCode": "def simple_function(a: int, b: int = 5):\n    \"\"\"\n    Args:\n        a: The first argument\n        b: The second argument\n    Returns:\n        The sum of a and b\n    \"\"\"\n    return a + b\ndef test_simple_function():",
        "detail": "tests.test_function_schema",
        "documentation": {}
    },
    {
        "label": "test_simple_function",
        "kind": 2,
        "importPath": "tests.test_function_schema",
        "description": "tests.test_function_schema",
        "peekOfCode": "def test_simple_function():\n    \"\"\"Test a function that has simple typed parameters and defaults.\"\"\"\n    func_schema = function_schema(simple_function)\n    # Check that the JSON schema is a dictionary with title, type, etc.\n    assert isinstance(func_schema.params_json_schema, dict)\n    assert func_schema.params_json_schema.get(\"title\") == \"simple_function_args\"\n    assert (\n        func_schema.params_json_schema.get(\"properties\", {}).get(\"a\").get(\"description\")\n        == \"The first argument\"\n    )",
        "detail": "tests.test_function_schema",
        "documentation": {}
    },
    {
        "label": "varargs_function",
        "kind": 2,
        "importPath": "tests.test_function_schema",
        "description": "tests.test_function_schema",
        "peekOfCode": "def varargs_function(x: int, *numbers: float, flag: bool = False, **kwargs: Any):\n    return x, numbers, flag, kwargs\ndef test_varargs_function():\n    \"\"\"Test a function that uses *args and **kwargs.\"\"\"\n    func_schema = function_schema(varargs_function)\n    # Check JSON schema structure\n    assert isinstance(func_schema.params_json_schema, dict)\n    assert func_schema.params_json_schema.get(\"title\") == \"varargs_function_args\"\n    # Valid input including *args in 'numbers' and **kwargs in 'kwargs'\n    valid_input = {",
        "detail": "tests.test_function_schema",
        "documentation": {}
    },
    {
        "label": "test_varargs_function",
        "kind": 2,
        "importPath": "tests.test_function_schema",
        "description": "tests.test_function_schema",
        "peekOfCode": "def test_varargs_function():\n    \"\"\"Test a function that uses *args and **kwargs.\"\"\"\n    func_schema = function_schema(varargs_function)\n    # Check JSON schema structure\n    assert isinstance(func_schema.params_json_schema, dict)\n    assert func_schema.params_json_schema.get(\"title\") == \"varargs_function_args\"\n    # Valid input including *args in 'numbers' and **kwargs in 'kwargs'\n    valid_input = {\n        \"x\": 10,\n        \"numbers\": [1.1, 2.2, 3.3],",
        "detail": "tests.test_function_schema",
        "documentation": {}
    },
    {
        "label": "complex_args_function",
        "kind": 2,
        "importPath": "tests.test_function_schema",
        "description": "tests.test_function_schema",
        "peekOfCode": "def complex_args_function(model: OuterModel) -> str:\n    return f\"{model.inner.a}, {model.inner.b}, {model.foo['a']}, {model.foo['b']}\"\ndef test_nested_data_function():\n    func_schema = function_schema(complex_args_function)\n    assert isinstance(func_schema.params_json_schema, dict)\n    assert func_schema.params_json_schema.get(\"title\") == \"complex_args_function_args\"\n    # Valid input\n    model = OuterModel(inner=InnerModel(a=1, b=\"hello\"), foo=Foo(a=2, b=\"world\"))\n    valid_input = {\n        \"model\": model.model_dump(),",
        "detail": "tests.test_function_schema",
        "documentation": {}
    },
    {
        "label": "test_nested_data_function",
        "kind": 2,
        "importPath": "tests.test_function_schema",
        "description": "tests.test_function_schema",
        "peekOfCode": "def test_nested_data_function():\n    func_schema = function_schema(complex_args_function)\n    assert isinstance(func_schema.params_json_schema, dict)\n    assert func_schema.params_json_schema.get(\"title\") == \"complex_args_function_args\"\n    # Valid input\n    model = OuterModel(inner=InnerModel(a=1, b=\"hello\"), foo=Foo(a=2, b=\"world\"))\n    valid_input = {\n        \"model\": model.model_dump(),\n    }\n    parsed = func_schema.params_pydantic_model(**valid_input)",
        "detail": "tests.test_function_schema",
        "documentation": {}
    },
    {
        "label": "complex_args_and_docs_function",
        "kind": 2,
        "importPath": "tests.test_function_schema",
        "description": "tests.test_function_schema",
        "peekOfCode": "def complex_args_and_docs_function(model: OuterModel, some_flag: int = 0) -> str:\n    \"\"\"\n    This function takes a model and a flag, and returns a string.\n    Args:\n        model: A model with an inner and foo field\n        some_flag: An optional flag with a default of 0\n    Returns:\n        A string with the values of the model and flag\n    \"\"\"\n    return f\"{model.inner.a}, {model.inner.b}, {model.foo['a']}, {model.foo['b']}, {some_flag or 0}\"",
        "detail": "tests.test_function_schema",
        "documentation": {}
    },
    {
        "label": "test_complex_args_and_docs_function",
        "kind": 2,
        "importPath": "tests.test_function_schema",
        "description": "tests.test_function_schema",
        "peekOfCode": "def test_complex_args_and_docs_function():\n    func_schema = function_schema(complex_args_and_docs_function)\n    assert isinstance(func_schema.params_json_schema, dict)\n    assert func_schema.params_json_schema.get(\"title\") == \"complex_args_and_docs_function_args\"\n    # Check docstring is parsed correctly\n    properties = func_schema.params_json_schema.get(\"properties\", {})\n    assert properties.get(\"model\").get(\"description\") == \"A model with an inner and foo field\"\n    assert properties.get(\"some_flag\").get(\"description\") == \"An optional flag with a default of 0\"\n    # Valid input\n    model = OuterModel(inner=InnerModel(a=1, b=\"hello\"), foo=Foo(a=2, b=\"world\"))",
        "detail": "tests.test_function_schema",
        "documentation": {}
    },
    {
        "label": "function_with_context",
        "kind": 2,
        "importPath": "tests.test_function_schema",
        "description": "tests.test_function_schema",
        "peekOfCode": "def function_with_context(ctx: RunContextWrapper[str], a: int, b: int = 5):\n    return a + b\ndef test_function_with_context():\n    func_schema = function_schema(function_with_context)\n    assert func_schema.takes_context\n    context = RunContextWrapper(context=\"test\")\n    input = {\"a\": 1, \"b\": 2}\n    parsed = func_schema.params_pydantic_model(**input)\n    args, kwargs_dict = func_schema.to_call_args(parsed)\n    result = function_with_context(context, *args, **kwargs_dict)",
        "detail": "tests.test_function_schema",
        "documentation": {}
    },
    {
        "label": "test_function_with_context",
        "kind": 2,
        "importPath": "tests.test_function_schema",
        "description": "tests.test_function_schema",
        "peekOfCode": "def test_function_with_context():\n    func_schema = function_schema(function_with_context)\n    assert func_schema.takes_context\n    context = RunContextWrapper(context=\"test\")\n    input = {\"a\": 1, \"b\": 2}\n    parsed = func_schema.params_pydantic_model(**input)\n    args, kwargs_dict = func_schema.to_call_args(parsed)\n    result = function_with_context(context, *args, **kwargs_dict)\n    assert result == 3\nclass MyClass:",
        "detail": "tests.test_function_schema",
        "documentation": {}
    },
    {
        "label": "test_class_based_functions",
        "kind": 2,
        "importPath": "tests.test_function_schema",
        "description": "tests.test_function_schema",
        "peekOfCode": "def test_class_based_functions():\n    context = RunContextWrapper(context=\"test\")\n    # Instance method\n    instance = MyClass()\n    func_schema = function_schema(instance.foo)\n    assert isinstance(func_schema.params_json_schema, dict)\n    assert func_schema.params_json_schema.get(\"title\") == \"foo_args\"\n    input = {\"a\": 1, \"b\": 2}\n    parsed = func_schema.params_pydantic_model(**input)\n    args, kwargs_dict = func_schema.to_call_args(parsed)",
        "detail": "tests.test_function_schema",
        "documentation": {}
    },
    {
        "label": "enum_and_literal_function",
        "kind": 2,
        "importPath": "tests.test_function_schema",
        "description": "tests.test_function_schema",
        "peekOfCode": "def enum_and_literal_function(a: MyEnum, b: Literal[\"a\", \"b\", \"c\"]) -> str:\n    return f\"{a.value} {b}\"\ndef test_enum_and_literal_function():\n    func_schema = function_schema(enum_and_literal_function)\n    assert isinstance(func_schema.params_json_schema, dict)\n    assert func_schema.params_json_schema.get(\"title\") == \"enum_and_literal_function_args\"\n    # Check that the enum values are included in the JSON schema\n    assert func_schema.params_json_schema.get(\"$defs\", {}).get(\"MyEnum\", {}).get(\"enum\") == [\n        \"foo\",\n        \"bar\",",
        "detail": "tests.test_function_schema",
        "documentation": {}
    },
    {
        "label": "test_enum_and_literal_function",
        "kind": 2,
        "importPath": "tests.test_function_schema",
        "description": "tests.test_function_schema",
        "peekOfCode": "def test_enum_and_literal_function():\n    func_schema = function_schema(enum_and_literal_function)\n    assert isinstance(func_schema.params_json_schema, dict)\n    assert func_schema.params_json_schema.get(\"title\") == \"enum_and_literal_function_args\"\n    # Check that the enum values are included in the JSON schema\n    assert func_schema.params_json_schema.get(\"$defs\", {}).get(\"MyEnum\", {}).get(\"enum\") == [\n        \"foo\",\n        \"bar\",\n        \"baz\",\n    ]",
        "detail": "tests.test_function_schema",
        "documentation": {}
    },
    {
        "label": "test_run_context_in_non_first_position_raises_value_error",
        "kind": 2,
        "importPath": "tests.test_function_schema",
        "description": "tests.test_function_schema",
        "peekOfCode": "def test_run_context_in_non_first_position_raises_value_error():\n    # When a parameter (after the first) is annotated as RunContextWrapper,\n    # function_schema() should raise a UserError.\n    def func(a: int, context: RunContextWrapper) -> None:\n        pass\n    with pytest.raises(UserError):\n        function_schema(func, use_docstring_info=False)\ndef test_var_positional_tuple_annotation():\n    # When a function has a var-positional parameter annotated with a tuple type,\n    # function_schema() should convert it into a field with type List[<tuple-element>].",
        "detail": "tests.test_function_schema",
        "documentation": {}
    },
    {
        "label": "test_var_positional_tuple_annotation",
        "kind": 2,
        "importPath": "tests.test_function_schema",
        "description": "tests.test_function_schema",
        "peekOfCode": "def test_var_positional_tuple_annotation():\n    # When a function has a var-positional parameter annotated with a tuple type,\n    # function_schema() should convert it into a field with type List[<tuple-element>].\n    def func(*args: tuple[int, ...]) -> int:\n        total = 0\n        for arg in args:\n            total += sum(arg)\n        return total\n    fs = function_schema(func, use_docstring_info=False)\n    properties = fs.params_json_schema.get(\"properties\", {})",
        "detail": "tests.test_function_schema",
        "documentation": {}
    },
    {
        "label": "test_var_keyword_dict_annotation",
        "kind": 2,
        "importPath": "tests.test_function_schema",
        "description": "tests.test_function_schema",
        "peekOfCode": "def test_var_keyword_dict_annotation():\n    # Case 3:\n    # When a function has a var-keyword parameter annotated with a dict type,\n    # function_schema() should convert it into a field with type Dict[<key>, <value>].\n    def func(**kwargs: dict[str, int]):\n        return kwargs\n    fs = function_schema(func, use_docstring_info=False)\n    properties = fs.params_json_schema.get(\"properties\", {})\n    # The name of the field is \"kwargs\", and it's a JSON object i.e. a dict.\n    assert properties.get(\"kwargs\").get(\"type\") == \"object\"",
        "detail": "tests.test_function_schema",
        "documentation": {}
    },
    {
        "label": "Foo",
        "kind": 6,
        "importPath": "tests.test_function_tool",
        "description": "tests.test_function_tool",
        "peekOfCode": "class Foo(BaseModel):\n    a: int\n    b: int = 5\nclass Bar(TypedDict):\n    x: str\n    y: int\ndef complex_args_function(foo: Foo, bar: Bar, baz: str = \"hello\"):\n    return f\"{foo.a + foo.b} {bar['x']}{bar['y']} {baz}\"\n@pytest.mark.asyncio\nasync def test_complex_args_function():",
        "detail": "tests.test_function_tool",
        "documentation": {}
    },
    {
        "label": "Bar",
        "kind": 6,
        "importPath": "tests.test_function_tool",
        "description": "tests.test_function_tool",
        "peekOfCode": "class Bar(TypedDict):\n    x: str\n    y: int\ndef complex_args_function(foo: Foo, bar: Bar, baz: str = \"hello\"):\n    return f\"{foo.a + foo.b} {bar['x']}{bar['y']} {baz}\"\n@pytest.mark.asyncio\nasync def test_complex_args_function():\n    tool = function_tool(complex_args_function, failure_error_function=None)\n    assert tool.name == \"complex_args_function\"\n    valid_json = json.dumps(",
        "detail": "tests.test_function_tool",
        "documentation": {}
    },
    {
        "label": "argless_function",
        "kind": 2,
        "importPath": "tests.test_function_tool",
        "description": "tests.test_function_tool",
        "peekOfCode": "def argless_function() -> str:\n    return \"ok\"\n@pytest.mark.asyncio\nasync def test_argless_function():\n    tool = function_tool(argless_function)\n    assert tool.name == \"argless_function\"\n    result = await tool.on_invoke_tool(RunContextWrapper(None), \"\")\n    assert result == \"ok\"\ndef argless_with_context(ctx: RunContextWrapper[str]) -> str:\n    return \"ok\"",
        "detail": "tests.test_function_tool",
        "documentation": {}
    },
    {
        "label": "argless_with_context",
        "kind": 2,
        "importPath": "tests.test_function_tool",
        "description": "tests.test_function_tool",
        "peekOfCode": "def argless_with_context(ctx: RunContextWrapper[str]) -> str:\n    return \"ok\"\n@pytest.mark.asyncio\nasync def test_argless_with_context():\n    tool = function_tool(argless_with_context)\n    assert tool.name == \"argless_with_context\"\n    result = await tool.on_invoke_tool(RunContextWrapper(None), \"\")\n    assert result == \"ok\"\n    # Extra JSON should not raise an error\n    result = await tool.on_invoke_tool(RunContextWrapper(None), '{\"a\": 1}')",
        "detail": "tests.test_function_tool",
        "documentation": {}
    },
    {
        "label": "simple_function",
        "kind": 2,
        "importPath": "tests.test_function_tool",
        "description": "tests.test_function_tool",
        "peekOfCode": "def simple_function(a: int, b: int = 5):\n    return a + b\n@pytest.mark.asyncio\nasync def test_simple_function():\n    tool = function_tool(simple_function, failure_error_function=None)\n    assert tool.name == \"simple_function\"\n    result = await tool.on_invoke_tool(RunContextWrapper(None), '{\"a\": 1}')\n    assert result == 6\n    result = await tool.on_invoke_tool(RunContextWrapper(None), '{\"a\": 1, \"b\": 2}')\n    assert result == 3",
        "detail": "tests.test_function_tool",
        "documentation": {}
    },
    {
        "label": "complex_args_function",
        "kind": 2,
        "importPath": "tests.test_function_tool",
        "description": "tests.test_function_tool",
        "peekOfCode": "def complex_args_function(foo: Foo, bar: Bar, baz: str = \"hello\"):\n    return f\"{foo.a + foo.b} {bar['x']}{bar['y']} {baz}\"\n@pytest.mark.asyncio\nasync def test_complex_args_function():\n    tool = function_tool(complex_args_function, failure_error_function=None)\n    assert tool.name == \"complex_args_function\"\n    valid_json = json.dumps(\n        {\n            \"foo\": Foo(a=1).model_dump(),\n            \"bar\": Bar(x=\"hello\", y=10),",
        "detail": "tests.test_function_tool",
        "documentation": {}
    },
    {
        "label": "test_function_config_overrides",
        "kind": 2,
        "importPath": "tests.test_function_tool",
        "description": "tests.test_function_tool",
        "peekOfCode": "def test_function_config_overrides():\n    tool = function_tool(simple_function, name_override=\"custom_name\")\n    assert tool.name == \"custom_name\"\n    tool = function_tool(simple_function, description_override=\"custom description\")\n    assert tool.description == \"custom description\"\n    tool = function_tool(\n        simple_function,\n        name_override=\"custom_name\",\n        description_override=\"custom description\",\n    )",
        "detail": "tests.test_function_tool",
        "documentation": {}
    },
    {
        "label": "test_func_schema_is_strict",
        "kind": 2,
        "importPath": "tests.test_function_tool",
        "description": "tests.test_function_tool",
        "peekOfCode": "def test_func_schema_is_strict():\n    tool = function_tool(simple_function)\n    assert tool.strict_json_schema, \"Should be strict by default\"\n    assert (\n        \"additionalProperties\" in tool.params_json_schema\n        and not tool.params_json_schema[\"additionalProperties\"]\n    )\n    tool = function_tool(complex_args_function)\n    assert tool.strict_json_schema, \"Should be strict by default\"\n    assert (",
        "detail": "tests.test_function_tool",
        "documentation": {}
    },
    {
        "label": "DummyContext",
        "kind": 6,
        "importPath": "tests.test_function_tool_decorator",
        "description": "tests.test_function_tool_decorator",
        "peekOfCode": "class DummyContext:\n    def __init__(self):\n        self.data = \"something\"\ndef ctx_wrapper() -> RunContextWrapper[DummyContext]:\n    return RunContextWrapper(DummyContext())\n@function_tool\ndef sync_no_context_no_args() -> str:\n    return \"test_1\"\n@pytest.mark.asyncio\nasync def test_sync_no_context_no_args_invocation():",
        "detail": "tests.test_function_tool_decorator",
        "documentation": {}
    },
    {
        "label": "ctx_wrapper",
        "kind": 2,
        "importPath": "tests.test_function_tool_decorator",
        "description": "tests.test_function_tool_decorator",
        "peekOfCode": "def ctx_wrapper() -> RunContextWrapper[DummyContext]:\n    return RunContextWrapper(DummyContext())\n@function_tool\ndef sync_no_context_no_args() -> str:\n    return \"test_1\"\n@pytest.mark.asyncio\nasync def test_sync_no_context_no_args_invocation():\n    tool = sync_no_context_no_args\n    output = await tool.on_invoke_tool(ctx_wrapper(), \"\")\n    assert output == \"test_1\"",
        "detail": "tests.test_function_tool_decorator",
        "documentation": {}
    },
    {
        "label": "sync_no_context_no_args",
        "kind": 2,
        "importPath": "tests.test_function_tool_decorator",
        "description": "tests.test_function_tool_decorator",
        "peekOfCode": "def sync_no_context_no_args() -> str:\n    return \"test_1\"\n@pytest.mark.asyncio\nasync def test_sync_no_context_no_args_invocation():\n    tool = sync_no_context_no_args\n    output = await tool.on_invoke_tool(ctx_wrapper(), \"\")\n    assert output == \"test_1\"\n@function_tool\ndef sync_no_context_with_args(a: int, b: int) -> int:\n    return a + b",
        "detail": "tests.test_function_tool_decorator",
        "documentation": {}
    },
    {
        "label": "sync_no_context_with_args",
        "kind": 2,
        "importPath": "tests.test_function_tool_decorator",
        "description": "tests.test_function_tool_decorator",
        "peekOfCode": "def sync_no_context_with_args(a: int, b: int) -> int:\n    return a + b\n@pytest.mark.asyncio\nasync def test_sync_no_context_with_args_invocation():\n    tool = sync_no_context_with_args\n    input_data = {\"a\": 5, \"b\": 7}\n    output = await tool.on_invoke_tool(ctx_wrapper(), json.dumps(input_data))\n    assert int(output) == 12\n@function_tool\ndef sync_with_context(ctx: RunContextWrapper[DummyContext], name: str) -> str:",
        "detail": "tests.test_function_tool_decorator",
        "documentation": {}
    },
    {
        "label": "sync_with_context",
        "kind": 2,
        "importPath": "tests.test_function_tool_decorator",
        "description": "tests.test_function_tool_decorator",
        "peekOfCode": "def sync_with_context(ctx: RunContextWrapper[DummyContext], name: str) -> str:\n    return f\"{name}_{ctx.context.data}\"\n@pytest.mark.asyncio\nasync def test_sync_with_context_invocation():\n    tool = sync_with_context\n    input_data = {\"name\": \"Alice\"}\n    output = await tool.on_invoke_tool(ctx_wrapper(), json.dumps(input_data))\n    assert output == \"Alice_something\"\n@function_tool\nasync def async_no_context(a: int, b: int) -> int:",
        "detail": "tests.test_function_tool_decorator",
        "documentation": {}
    },
    {
        "label": "sync_no_context_override",
        "kind": 2,
        "importPath": "tests.test_function_tool_decorator",
        "description": "tests.test_function_tool_decorator",
        "peekOfCode": "def sync_no_context_override() -> str:\n    return \"override_result\"\n@pytest.mark.asyncio\nasync def test_sync_no_context_override_invocation():\n    tool = sync_no_context_override\n    assert tool.name == \"my_custom_tool\"\n    assert tool.description == \"custom desc\"\n    output = await tool.on_invoke_tool(ctx_wrapper(), \"\")\n    assert output == \"override_result\"\n@function_tool(failure_error_function=None)",
        "detail": "tests.test_function_tool_decorator",
        "documentation": {}
    },
    {
        "label": "will_fail_on_bad_json",
        "kind": 2,
        "importPath": "tests.test_function_tool_decorator",
        "description": "tests.test_function_tool_decorator",
        "peekOfCode": "def will_fail_on_bad_json(x: int) -> int:\n    return x * 2  # pragma: no cover\n@pytest.mark.asyncio\nasync def test_error_on_invalid_json():\n    tool = will_fail_on_bad_json\n    # Passing an invalid JSON string\n    with pytest.raises(Exception) as exc_info:\n        await tool.on_invoke_tool(ctx_wrapper(), \"{not valid json}\")\n    assert \"Invalid JSON input for tool\" in str(exc_info.value)\ndef sync_error_handler(ctx: RunContextWrapper[Any], error: Exception) -> str:",
        "detail": "tests.test_function_tool_decorator",
        "documentation": {}
    },
    {
        "label": "sync_error_handler",
        "kind": 2,
        "importPath": "tests.test_function_tool_decorator",
        "description": "tests.test_function_tool_decorator",
        "peekOfCode": "def sync_error_handler(ctx: RunContextWrapper[Any], error: Exception) -> str:\n    return f\"error_{error.__class__.__name__}\"\n@function_tool(failure_error_function=sync_error_handler)\ndef will_not_fail_on_bad_json(x: int) -> int:\n    return x * 2  # pragma: no cover\n@pytest.mark.asyncio\nasync def test_no_error_on_invalid_json():\n    tool = will_not_fail_on_bad_json\n    # Passing an invalid JSON string\n    result = await tool.on_invoke_tool(ctx_wrapper(), \"{not valid json}\")",
        "detail": "tests.test_function_tool_decorator",
        "documentation": {}
    },
    {
        "label": "will_not_fail_on_bad_json",
        "kind": 2,
        "importPath": "tests.test_function_tool_decorator",
        "description": "tests.test_function_tool_decorator",
        "peekOfCode": "def will_not_fail_on_bad_json(x: int) -> int:\n    return x * 2  # pragma: no cover\n@pytest.mark.asyncio\nasync def test_no_error_on_invalid_json():\n    tool = will_not_fail_on_bad_json\n    # Passing an invalid JSON string\n    result = await tool.on_invoke_tool(ctx_wrapper(), \"{not valid json}\")\n    assert result == \"error_ModelBehaviorError\"\ndef async_error_handler(ctx: RunContextWrapper[Any], error: Exception) -> str:\n    return f\"error_{error.__class__.__name__}\"",
        "detail": "tests.test_function_tool_decorator",
        "documentation": {}
    },
    {
        "label": "async_error_handler",
        "kind": 2,
        "importPath": "tests.test_function_tool_decorator",
        "description": "tests.test_function_tool_decorator",
        "peekOfCode": "def async_error_handler(ctx: RunContextWrapper[Any], error: Exception) -> str:\n    return f\"error_{error.__class__.__name__}\"\n@function_tool(failure_error_function=sync_error_handler)\ndef will_not_fail_on_bad_json_async(x: int) -> int:\n    return x * 2  # pragma: no cover\n@pytest.mark.asyncio\nasync def test_no_error_on_invalid_json_async():\n    tool = will_not_fail_on_bad_json_async\n    result = await tool.on_invoke_tool(ctx_wrapper(), \"{not valid json}\")\n    assert result == \"error_ModelBehaviorError\"",
        "detail": "tests.test_function_tool_decorator",
        "documentation": {}
    },
    {
        "label": "will_not_fail_on_bad_json_async",
        "kind": 2,
        "importPath": "tests.test_function_tool_decorator",
        "description": "tests.test_function_tool_decorator",
        "peekOfCode": "def will_not_fail_on_bad_json_async(x: int) -> int:\n    return x * 2  # pragma: no cover\n@pytest.mark.asyncio\nasync def test_no_error_on_invalid_json_async():\n    tool = will_not_fail_on_bad_json_async\n    result = await tool.on_invoke_tool(ctx_wrapper(), \"{not valid json}\")\n    assert result == \"error_ModelBehaviorError\"\n@function_tool(strict_mode=False)\ndef optional_param_function(a: int, b: Optional[int] = None) -> str:\n    if b is None:",
        "detail": "tests.test_function_tool_decorator",
        "documentation": {}
    },
    {
        "label": "optional_param_function",
        "kind": 2,
        "importPath": "tests.test_function_tool_decorator",
        "description": "tests.test_function_tool_decorator",
        "peekOfCode": "def optional_param_function(a: int, b: Optional[int] = None) -> str:\n    if b is None:\n        return f\"{a}_no_b\"\n    return f\"{a}_{b}\"\n@pytest.mark.asyncio\nasync def test_non_strict_mode_function():\n    tool = optional_param_function\n    assert tool.strict_json_schema is False, \"strict_json_schema should be False\"\n    assert tool.params_json_schema.get(\"required\") == [\"a\"], \"required should only be a\"\n    input_data = {\"a\": 5}",
        "detail": "tests.test_function_tool_decorator",
        "documentation": {}
    },
    {
        "label": "all_optional_params_function",
        "kind": 2,
        "importPath": "tests.test_function_tool_decorator",
        "description": "tests.test_function_tool_decorator",
        "peekOfCode": "def all_optional_params_function(\n    x: int = 42,\n    y: str = \"hello\",\n    z: Optional[int] = None,\n) -> str:\n    if z is None:\n        return f\"{x}_{y}_no_z\"\n    return f\"{x}_{y}_{z}\"\n@pytest.mark.asyncio\nasync def test_all_optional_params_function():",
        "detail": "tests.test_function_tool_decorator",
        "documentation": {}
    },
    {
        "label": "RunHooksForTests",
        "kind": 6,
        "importPath": "tests.test_global_hooks",
        "description": "tests.test_global_hooks",
        "peekOfCode": "class RunHooksForTests(RunHooks):\n    def __init__(self):\n        self.events: dict[str, int] = defaultdict(int)\n    def reset(self):\n        self.events.clear()\n    async def on_agent_start(\n        self, context: RunContextWrapper[TContext], agent: Agent[TContext]\n    ) -> None:\n        self.events[\"on_agent_start\"] += 1\n    async def on_agent_end(",
        "detail": "tests.test_global_hooks",
        "documentation": {}
    },
    {
        "label": "Foo",
        "kind": 6,
        "importPath": "tests.test_global_hooks",
        "description": "tests.test_global_hooks",
        "peekOfCode": "class Foo(TypedDict):\n    a: str\n@pytest.mark.asyncio\nasync def test_structed_output_non_streamed_agent_hooks():\n    hooks = RunHooksForTests()\n    model = FakeModel()\n    agent_1 = Agent(name=\"test_1\", model=model)\n    agent_2 = Agent(name=\"test_2\", model=model)\n    agent_3 = Agent(\n        name=\"test_3\",",
        "detail": "tests.test_global_hooks",
        "documentation": {}
    },
    {
        "label": "get_sync_guardrail",
        "kind": 2,
        "importPath": "tests.test_guardrails",
        "description": "tests.test_guardrails",
        "peekOfCode": "def get_sync_guardrail(triggers: bool, output_info: Any | None = None):\n    def sync_guardrail(\n        context: RunContextWrapper[Any], agent: Agent[Any], input: str | list[TResponseInputItem]\n    ):\n        return GuardrailFunctionOutput(\n            output_info=output_info,\n            tripwire_triggered=triggers,\n        )\n    return sync_guardrail\n@pytest.mark.asyncio",
        "detail": "tests.test_guardrails",
        "documentation": {}
    },
    {
        "label": "get_async_input_guardrail",
        "kind": 2,
        "importPath": "tests.test_guardrails",
        "description": "tests.test_guardrails",
        "peekOfCode": "def get_async_input_guardrail(triggers: bool, output_info: Any | None = None):\n    async def async_guardrail(\n        context: RunContextWrapper[Any], agent: Agent[Any], input: str | list[TResponseInputItem]\n    ):\n        return GuardrailFunctionOutput(\n            output_info=output_info,\n            tripwire_triggered=triggers,\n        )\n    return async_guardrail\n@pytest.mark.asyncio",
        "detail": "tests.test_guardrails",
        "documentation": {}
    },
    {
        "label": "get_sync_output_guardrail",
        "kind": 2,
        "importPath": "tests.test_guardrails",
        "description": "tests.test_guardrails",
        "peekOfCode": "def get_sync_output_guardrail(triggers: bool, output_info: Any | None = None):\n    def sync_guardrail(context: RunContextWrapper[Any], agent: Agent[Any], agent_output: Any):\n        return GuardrailFunctionOutput(\n            output_info=output_info,\n            tripwire_triggered=triggers,\n        )\n    return sync_guardrail\n@pytest.mark.asyncio\nasync def test_sync_output_guardrail():\n    guardrail = OutputGuardrail(guardrail_function=get_sync_output_guardrail(triggers=False))",
        "detail": "tests.test_guardrails",
        "documentation": {}
    },
    {
        "label": "get_async_output_guardrail",
        "kind": 2,
        "importPath": "tests.test_guardrails",
        "description": "tests.test_guardrails",
        "peekOfCode": "def get_async_output_guardrail(triggers: bool, output_info: Any | None = None):\n    async def async_guardrail(\n        context: RunContextWrapper[Any], agent: Agent[Any], agent_output: Any\n    ):\n        return GuardrailFunctionOutput(\n            output_info=output_info,\n            tripwire_triggered=triggers,\n        )\n    return async_guardrail\n@pytest.mark.asyncio",
        "detail": "tests.test_guardrails",
        "documentation": {}
    },
    {
        "label": "decorated_input_guardrail",
        "kind": 2,
        "importPath": "tests.test_guardrails",
        "description": "tests.test_guardrails",
        "peekOfCode": "def decorated_input_guardrail(\n    context: RunContextWrapper[Any], agent: Agent[Any], input: str | list[TResponseInputItem]\n) -> GuardrailFunctionOutput:\n    return GuardrailFunctionOutput(\n        output_info=\"test_1\",\n        tripwire_triggered=False,\n    )\n@input_guardrail(name=\"Custom name\")\ndef decorated_named_input_guardrail(\n    context: RunContextWrapper[Any], agent: Agent[Any], input: str | list[TResponseInputItem]",
        "detail": "tests.test_guardrails",
        "documentation": {}
    },
    {
        "label": "decorated_named_input_guardrail",
        "kind": 2,
        "importPath": "tests.test_guardrails",
        "description": "tests.test_guardrails",
        "peekOfCode": "def decorated_named_input_guardrail(\n    context: RunContextWrapper[Any], agent: Agent[Any], input: str | list[TResponseInputItem]\n) -> GuardrailFunctionOutput:\n    return GuardrailFunctionOutput(\n        output_info=\"test_2\",\n        tripwire_triggered=False,\n    )\n@pytest.mark.asyncio\nasync def test_input_guardrail_decorators():\n    guardrail = decorated_input_guardrail",
        "detail": "tests.test_guardrails",
        "documentation": {}
    },
    {
        "label": "decorated_output_guardrail",
        "kind": 2,
        "importPath": "tests.test_guardrails",
        "description": "tests.test_guardrails",
        "peekOfCode": "def decorated_output_guardrail(\n    context: RunContextWrapper[Any], agent: Agent[Any], agent_output: Any\n) -> GuardrailFunctionOutput:\n    return GuardrailFunctionOutput(\n        output_info=\"test_3\",\n        tripwire_triggered=False,\n    )\n@output_guardrail(name=\"Custom name\")\ndef decorated_named_output_guardrail(\n    context: RunContextWrapper[Any], agent: Agent[Any], agent_output: Any",
        "detail": "tests.test_guardrails",
        "documentation": {}
    },
    {
        "label": "decorated_named_output_guardrail",
        "kind": 2,
        "importPath": "tests.test_guardrails",
        "description": "tests.test_guardrails",
        "peekOfCode": "def decorated_named_output_guardrail(\n    context: RunContextWrapper[Any], agent: Agent[Any], agent_output: Any\n) -> GuardrailFunctionOutput:\n    return GuardrailFunctionOutput(\n        output_info=\"test_4\",\n        tripwire_triggered=False,\n    )\n@pytest.mark.asyncio\nasync def test_output_guardrail_decorators():\n    guardrail = decorated_output_guardrail",
        "detail": "tests.test_guardrails",
        "documentation": {}
    },
    {
        "label": "Foo",
        "kind": 6,
        "importPath": "tests.test_handoff_tool",
        "description": "tests.test_handoff_tool",
        "peekOfCode": "class Foo(BaseModel):\n    bar: str\n@pytest.mark.asyncio\nasync def test_handoff_input_type():\n    async def _on_handoff(ctx: RunContextWrapper[Any], input: Foo):\n        pass\n    agent = Agent(name=\"test\")\n    obj = handoff(agent, input_type=Foo, on_handoff=_on_handoff)\n    for key, value in Foo.model_json_schema().items():\n        assert obj.input_json_schema[key] == value",
        "detail": "tests.test_handoff_tool",
        "documentation": {}
    },
    {
        "label": "message_item",
        "kind": 2,
        "importPath": "tests.test_handoff_tool",
        "description": "tests.test_handoff_tool",
        "peekOfCode": "def message_item(content: str, agent: Agent[Any]) -> MessageOutputItem:\n    return MessageOutputItem(\n        agent=agent,\n        raw_item=ResponseOutputMessage(\n            id=\"123\",\n            status=\"completed\",\n            role=\"assistant\",\n            type=\"message\",\n            content=[ResponseOutputText(text=content, type=\"output_text\", annotations=[])],\n        ),",
        "detail": "tests.test_handoff_tool",
        "documentation": {}
    },
    {
        "label": "get_len",
        "kind": 2,
        "importPath": "tests.test_handoff_tool",
        "description": "tests.test_handoff_tool",
        "peekOfCode": "def get_len(data: HandoffInputData) -> int:\n    input_len = len(data.input_history) if isinstance(data.input_history, tuple) else 1\n    pre_handoff_len = len(data.pre_handoff_items)\n    new_items_len = len(data.new_items)\n    return input_len + pre_handoff_len + new_items_len\ndef test_single_handoff_setup():\n    agent_1 = Agent(name=\"test_1\")\n    agent_2 = Agent(name=\"test_2\", handoffs=[agent_1])\n    assert not agent_1.handoffs\n    assert agent_2.handoffs == [agent_1]",
        "detail": "tests.test_handoff_tool",
        "documentation": {}
    },
    {
        "label": "test_single_handoff_setup",
        "kind": 2,
        "importPath": "tests.test_handoff_tool",
        "description": "tests.test_handoff_tool",
        "peekOfCode": "def test_single_handoff_setup():\n    agent_1 = Agent(name=\"test_1\")\n    agent_2 = Agent(name=\"test_2\", handoffs=[agent_1])\n    assert not agent_1.handoffs\n    assert agent_2.handoffs == [agent_1]\n    assert not Runner._get_handoffs(agent_1)\n    handoff_objects = Runner._get_handoffs(agent_2)\n    assert len(handoff_objects) == 1\n    obj = handoff_objects[0]\n    assert obj.tool_name == Handoff.default_tool_name(agent_1)",
        "detail": "tests.test_handoff_tool",
        "documentation": {}
    },
    {
        "label": "test_multiple_handoffs_setup",
        "kind": 2,
        "importPath": "tests.test_handoff_tool",
        "description": "tests.test_handoff_tool",
        "peekOfCode": "def test_multiple_handoffs_setup():\n    agent_1 = Agent(name=\"test_1\")\n    agent_2 = Agent(name=\"test_2\")\n    agent_3 = Agent(name=\"test_3\", handoffs=[agent_1, agent_2])\n    assert agent_3.handoffs == [agent_1, agent_2]\n    assert not agent_1.handoffs\n    assert not agent_2.handoffs\n    handoff_objects = Runner._get_handoffs(agent_3)\n    assert len(handoff_objects) == 2\n    assert handoff_objects[0].tool_name == Handoff.default_tool_name(agent_1)",
        "detail": "tests.test_handoff_tool",
        "documentation": {}
    },
    {
        "label": "test_custom_handoff_setup",
        "kind": 2,
        "importPath": "tests.test_handoff_tool",
        "description": "tests.test_handoff_tool",
        "peekOfCode": "def test_custom_handoff_setup():\n    agent_1 = Agent(name=\"test_1\")\n    agent_2 = Agent(name=\"test_2\")\n    agent_3 = Agent(\n        name=\"test_3\",\n        handoffs=[\n            agent_1,\n            handoff(\n                agent_2,\n                tool_name_override=\"custom_tool_name\",",
        "detail": "tests.test_handoff_tool",
        "documentation": {}
    },
    {
        "label": "test_handoff_input_data",
        "kind": 2,
        "importPath": "tests.test_handoff_tool",
        "description": "tests.test_handoff_tool",
        "peekOfCode": "def test_handoff_input_data():\n    agent = Agent(name=\"test\")\n    data = HandoffInputData(\n        input_history=\"\",\n        pre_handoff_items=(),\n        new_items=(),\n    )\n    assert get_len(data) == 1\n    data = HandoffInputData(\n        input_history=({\"role\": \"user\", \"content\": \"foo\"},),",
        "detail": "tests.test_handoff_tool",
        "documentation": {}
    },
    {
        "label": "test_handoff_input_schema_is_strict",
        "kind": 2,
        "importPath": "tests.test_handoff_tool",
        "description": "tests.test_handoff_tool",
        "peekOfCode": "def test_handoff_input_schema_is_strict():\n    agent = Agent(name=\"test\")\n    obj = handoff(agent, input_type=Foo, on_handoff=lambda ctx, input: None)\n    for key, value in Foo.model_json_schema().items():\n        assert obj.input_json_schema[key] == value\n    assert obj.strict_json_schema, \"Input schema should be strict\"\n    assert (\n        \"additionalProperties\" in obj.input_json_schema\n        and not obj.input_json_schema[\"additionalProperties\"]\n    ), \"Input schema should be strict and have additionalProperties=False\"",
        "detail": "tests.test_handoff_tool",
        "documentation": {}
    },
    {
        "label": "make_message",
        "kind": 2,
        "importPath": "tests.test_items_helpers",
        "description": "tests.test_items_helpers",
        "peekOfCode": "def make_message(\n    content_items: list[ResponseOutputText | ResponseOutputRefusal],\n) -> ResponseOutputMessage:\n    \"\"\"\n    Helper to construct a ResponseOutputMessage with a single batch of content\n    items, using a fixed id/status.\n    \"\"\"\n    return ResponseOutputMessage(\n        id=\"msg123\",\n        content=content_items,",
        "detail": "tests.test_items_helpers",
        "documentation": {}
    },
    {
        "label": "test_extract_last_content_of_text_message",
        "kind": 2,
        "importPath": "tests.test_items_helpers",
        "description": "tests.test_items_helpers",
        "peekOfCode": "def test_extract_last_content_of_text_message() -> None:\n    # Build a message containing two text segments.\n    content1 = ResponseOutputText(annotations=[], text=\"Hello \", type=\"output_text\")\n    content2 = ResponseOutputText(annotations=[], text=\"world!\", type=\"output_text\")\n    message = make_message([content1, content2])\n    # Helpers should yield the last segment's text.\n    assert ItemHelpers.extract_last_content(message) == \"world!\"\ndef test_extract_last_content_of_refusal_message() -> None:\n    # Build a message whose last content entry is a refusal.\n    content1 = ResponseOutputText(annotations=[], text=\"Before refusal\", type=\"output_text\")",
        "detail": "tests.test_items_helpers",
        "documentation": {}
    },
    {
        "label": "test_extract_last_content_of_refusal_message",
        "kind": 2,
        "importPath": "tests.test_items_helpers",
        "description": "tests.test_items_helpers",
        "peekOfCode": "def test_extract_last_content_of_refusal_message() -> None:\n    # Build a message whose last content entry is a refusal.\n    content1 = ResponseOutputText(annotations=[], text=\"Before refusal\", type=\"output_text\")\n    refusal = ResponseOutputRefusal(refusal=\"I cannot do that\", type=\"refusal\")\n    message = make_message([content1, refusal])\n    # Helpers should extract the refusal string when last content is a refusal.\n    assert ItemHelpers.extract_last_content(message) == \"I cannot do that\"\ndef test_extract_last_content_non_message_returns_empty() -> None:\n    # Construct some other type of output item, e.g. a tool call, to verify non-message returns \"\".\n    tool_call = ResponseFunctionToolCall(",
        "detail": "tests.test_items_helpers",
        "documentation": {}
    },
    {
        "label": "test_extract_last_content_non_message_returns_empty",
        "kind": 2,
        "importPath": "tests.test_items_helpers",
        "description": "tests.test_items_helpers",
        "peekOfCode": "def test_extract_last_content_non_message_returns_empty() -> None:\n    # Construct some other type of output item, e.g. a tool call, to verify non-message returns \"\".\n    tool_call = ResponseFunctionToolCall(\n        id=\"tool123\",\n        arguments=\"{}\",\n        call_id=\"call123\",\n        name=\"func\",\n        type=\"function_call\",\n    )\n    assert ItemHelpers.extract_last_content(tool_call) == \"\"",
        "detail": "tests.test_items_helpers",
        "documentation": {}
    },
    {
        "label": "test_extract_last_text_returns_text_only",
        "kind": 2,
        "importPath": "tests.test_items_helpers",
        "description": "tests.test_items_helpers",
        "peekOfCode": "def test_extract_last_text_returns_text_only() -> None:\n    # A message whose last segment is text yields the text.\n    first_text = ResponseOutputText(annotations=[], text=\"part1\", type=\"output_text\")\n    second_text = ResponseOutputText(annotations=[], text=\"part2\", type=\"output_text\")\n    message = make_message([first_text, second_text])\n    assert ItemHelpers.extract_last_text(message) == \"part2\"\n    # Whereas when last content is a refusal, extract_last_text returns None.\n    message2 = make_message([first_text, ResponseOutputRefusal(refusal=\"no\", type=\"refusal\")])\n    assert ItemHelpers.extract_last_text(message2) is None\ndef test_input_to_new_input_list_from_string() -> None:",
        "detail": "tests.test_items_helpers",
        "documentation": {}
    },
    {
        "label": "test_input_to_new_input_list_from_string",
        "kind": 2,
        "importPath": "tests.test_items_helpers",
        "description": "tests.test_items_helpers",
        "peekOfCode": "def test_input_to_new_input_list_from_string() -> None:\n    result = ItemHelpers.input_to_new_input_list(\"hi\")\n    # Should wrap the string into a list with a single dict containing content and user role.\n    assert isinstance(result, list)\n    assert result == [{\"content\": \"hi\", \"role\": \"user\"}]\ndef test_input_to_new_input_list_deep_copies_lists() -> None:\n    # Given a list of message dictionaries, ensure the returned list is a deep copy.\n    original: list[TResponseInputItem] = [{\"content\": \"abc\", \"role\": \"developer\"}]\n    new_list = ItemHelpers.input_to_new_input_list(original)\n    assert new_list == original",
        "detail": "tests.test_items_helpers",
        "documentation": {}
    },
    {
        "label": "test_input_to_new_input_list_deep_copies_lists",
        "kind": 2,
        "importPath": "tests.test_items_helpers",
        "description": "tests.test_items_helpers",
        "peekOfCode": "def test_input_to_new_input_list_deep_copies_lists() -> None:\n    # Given a list of message dictionaries, ensure the returned list is a deep copy.\n    original: list[TResponseInputItem] = [{\"content\": \"abc\", \"role\": \"developer\"}]\n    new_list = ItemHelpers.input_to_new_input_list(original)\n    assert new_list == original\n    # Mutating the returned list should not mutate the original.\n    new_list.pop()\n    assert \"content\" in original[0] and original[0].get(\"content\") == \"abc\"\ndef test_text_message_output_concatenates_text_segments() -> None:\n    # Build a message with both text and refusal segments, only text segments are concatenated.",
        "detail": "tests.test_items_helpers",
        "documentation": {}
    },
    {
        "label": "test_text_message_output_concatenates_text_segments",
        "kind": 2,
        "importPath": "tests.test_items_helpers",
        "description": "tests.test_items_helpers",
        "peekOfCode": "def test_text_message_output_concatenates_text_segments() -> None:\n    # Build a message with both text and refusal segments, only text segments are concatenated.\n    pieces: list[ResponseOutputText | ResponseOutputRefusal] = []\n    pieces.append(ResponseOutputText(annotations=[], text=\"a\", type=\"output_text\"))\n    pieces.append(ResponseOutputRefusal(refusal=\"denied\", type=\"refusal\"))\n    pieces.append(ResponseOutputText(annotations=[], text=\"b\", type=\"output_text\"))\n    message = make_message(pieces)\n    # Wrap into MessageOutputItem to feed into text_message_output.\n    item = MessageOutputItem(agent=Agent(name=\"test\"), raw_item=message)\n    assert ItemHelpers.text_message_output(item) == \"ab\"",
        "detail": "tests.test_items_helpers",
        "documentation": {}
    },
    {
        "label": "test_text_message_outputs_across_list_of_runitems",
        "kind": 2,
        "importPath": "tests.test_items_helpers",
        "description": "tests.test_items_helpers",
        "peekOfCode": "def test_text_message_outputs_across_list_of_runitems() -> None:\n    \"\"\"\n    Compose several RunItem instances, including a non-message run item, and ensure\n    that only MessageOutputItem instances contribute any text. The non-message\n    (ReasoningItem) should be ignored by Helpers.text_message_outputs.\n    \"\"\"\n    message1 = make_message([ResponseOutputText(annotations=[], text=\"foo\", type=\"output_text\")])\n    message2 = make_message([ResponseOutputText(annotations=[], text=\"bar\", type=\"output_text\")])\n    item1: RunItem = MessageOutputItem(agent=Agent(name=\"test\"), raw_item=message1)\n    item2: RunItem = MessageOutputItem(agent=Agent(name=\"test\"), raw_item=message2)",
        "detail": "tests.test_items_helpers",
        "documentation": {}
    },
    {
        "label": "test_tool_call_output_item_constructs_function_call_output_dict",
        "kind": 2,
        "importPath": "tests.test_items_helpers",
        "description": "tests.test_items_helpers",
        "peekOfCode": "def test_tool_call_output_item_constructs_function_call_output_dict():\n    # Build a simple ResponseFunctionToolCall.\n    call = ResponseFunctionToolCall(\n        id=\"call-abc\",\n        arguments='{\"x\": 1}',\n        call_id=\"call-abc\",\n        name=\"do_something\",\n        type=\"function_call\",\n    )\n    payload = ItemHelpers.tool_call_output_item(call, \"result-string\")",
        "detail": "tests.test_items_helpers",
        "documentation": {}
    },
    {
        "label": "test_to_input_items_for_message",
        "kind": 2,
        "importPath": "tests.test_items_helpers",
        "description": "tests.test_items_helpers",
        "peekOfCode": "def test_to_input_items_for_message() -> None:\n    \"\"\"An output message should convert into an input dict matching the message's own structure.\"\"\"\n    content = ResponseOutputText(annotations=[], text=\"hello world\", type=\"output_text\")\n    message = ResponseOutputMessage(\n        id=\"m1\", content=[content], role=\"assistant\", status=\"completed\", type=\"message\"\n    )\n    resp = ModelResponse(output=[message], usage=Usage(), referenceable_id=None)\n    input_items = resp.to_input_items()\n    assert isinstance(input_items, list) and len(input_items) == 1\n    # The dict should contain exactly the primitive values of the message",
        "detail": "tests.test_items_helpers",
        "documentation": {}
    },
    {
        "label": "test_to_input_items_for_function_call",
        "kind": 2,
        "importPath": "tests.test_items_helpers",
        "description": "tests.test_items_helpers",
        "peekOfCode": "def test_to_input_items_for_function_call() -> None:\n    \"\"\"A function tool call output should produce the same dict as a function tool call input.\"\"\"\n    tool_call = ResponseFunctionToolCall(\n        id=\"f1\", arguments=\"{}\", call_id=\"c1\", name=\"func\", type=\"function_call\"\n    )\n    resp = ModelResponse(output=[tool_call], usage=Usage(), referenceable_id=None)\n    input_items = resp.to_input_items()\n    assert isinstance(input_items, list) and len(input_items) == 1\n    expected: ResponseFunctionToolCallParam = {\n        \"id\": \"f1\",",
        "detail": "tests.test_items_helpers",
        "documentation": {}
    },
    {
        "label": "test_to_input_items_for_file_search_call",
        "kind": 2,
        "importPath": "tests.test_items_helpers",
        "description": "tests.test_items_helpers",
        "peekOfCode": "def test_to_input_items_for_file_search_call() -> None:\n    \"\"\"A file search tool call output should produce the same dict as a file search input.\"\"\"\n    fs_call = ResponseFileSearchToolCall(\n        id=\"fs1\", queries=[\"query\"], status=\"completed\", type=\"file_search_call\"\n    )\n    resp = ModelResponse(output=[fs_call], usage=Usage(), referenceable_id=None)\n    input_items = resp.to_input_items()\n    assert isinstance(input_items, list) and len(input_items) == 1\n    expected: ResponseFileSearchToolCallParam = {\n        \"id\": \"fs1\",",
        "detail": "tests.test_items_helpers",
        "documentation": {}
    },
    {
        "label": "test_to_input_items_for_web_search_call",
        "kind": 2,
        "importPath": "tests.test_items_helpers",
        "description": "tests.test_items_helpers",
        "peekOfCode": "def test_to_input_items_for_web_search_call() -> None:\n    \"\"\"A web search tool call output should produce the same dict as a web search input.\"\"\"\n    ws_call = ResponseFunctionWebSearch(id=\"w1\", status=\"completed\", type=\"web_search_call\")\n    resp = ModelResponse(output=[ws_call], usage=Usage(), referenceable_id=None)\n    input_items = resp.to_input_items()\n    assert isinstance(input_items, list) and len(input_items) == 1\n    expected: ResponseFunctionWebSearchParam = {\n        \"id\": \"w1\",\n        \"status\": \"completed\",\n        \"type\": \"web_search_call\",",
        "detail": "tests.test_items_helpers",
        "documentation": {}
    },
    {
        "label": "test_to_input_items_for_computer_call_click",
        "kind": 2,
        "importPath": "tests.test_items_helpers",
        "description": "tests.test_items_helpers",
        "peekOfCode": "def test_to_input_items_for_computer_call_click() -> None:\n    \"\"\"A computer call output should yield a dict whose shape matches the computer call input.\"\"\"\n    action = ActionScreenshot(type=\"screenshot\")\n    comp_call = ResponseComputerToolCall(\n        id=\"comp1\",\n        action=action,\n        type=\"computer_call\",\n        call_id=\"comp1\",\n        pending_safety_checks=[],\n        status=\"completed\",",
        "detail": "tests.test_items_helpers",
        "documentation": {}
    },
    {
        "label": "test_to_input_items_for_reasoning",
        "kind": 2,
        "importPath": "tests.test_items_helpers",
        "description": "tests.test_items_helpers",
        "peekOfCode": "def test_to_input_items_for_reasoning() -> None:\n    \"\"\"A reasoning output should produce the same dict as a reasoning input item.\"\"\"\n    rc = Summary(text=\"why\", type=\"summary_text\")\n    reasoning = ResponseReasoningItem(id=\"rid1\", summary=[rc], type=\"reasoning\")\n    resp = ModelResponse(output=[reasoning], usage=Usage(), referenceable_id=None)\n    input_items = resp.to_input_items()\n    assert isinstance(input_items, list) and len(input_items) == 1\n    converted_dict = input_items[0]\n    expected: ResponseReasoningItemParam = {\n        \"id\": \"rid1\",",
        "detail": "tests.test_items_helpers",
        "documentation": {}
    },
    {
        "label": "Foo",
        "kind": 6,
        "importPath": "tests.test_max_turns",
        "description": "tests.test_max_turns",
        "peekOfCode": "class Foo(TypedDict):\n    a: str\n@pytest.mark.asyncio\nasync def test_structured_output_non_streamed_max_turns():\n    model = FakeModel()\n    agent = Agent(\n        name=\"test_1\",\n        model=model,\n        output_type=Foo,\n        tools=[get_function_tool(\"tool_1\", \"result\")],",
        "detail": "tests.test_max_turns",
        "documentation": {}
    },
    {
        "label": "TestObject",
        "kind": 6,
        "importPath": "tests.test_openai_chatcompletions_converter",
        "description": "tests.test_openai_chatcompletions_converter",
        "peekOfCode": "class TestObject:\n    pass\ndef test_unknown_object_errors():\n    \"\"\"\n    Test that unknown objects are converted correctly.\n    \"\"\"\n    with pytest.raises(UserError, match=\"Unhandled item type or structure\"):\n        # Purposely ignore the type error\n        _Converter.items_to_messages([TestObject()])  # type: ignore\ndef test_assistant_messages_in_history():",
        "detail": "tests.test_openai_chatcompletions_converter",
        "documentation": {}
    },
    {
        "label": "test_message_to_output_items_with_text_only",
        "kind": 2,
        "importPath": "tests.test_openai_chatcompletions_converter",
        "description": "tests.test_openai_chatcompletions_converter",
        "peekOfCode": "def test_message_to_output_items_with_text_only():\n    \"\"\"\n    Make sure a simple ChatCompletionMessage with string content is converted\n    into a single ResponseOutputMessage containing one ResponseOutputText.\n    \"\"\"\n    msg = ChatCompletionMessage(role=\"assistant\", content=\"Hello\")\n    items = _Converter.message_to_output_items(msg)\n    # Expect exactly one output item (the message)\n    assert len(items) == 1\n    message_item = cast(ResponseOutputMessage, items[0])",
        "detail": "tests.test_openai_chatcompletions_converter",
        "documentation": {}
    },
    {
        "label": "test_message_to_output_items_with_refusal",
        "kind": 2,
        "importPath": "tests.test_openai_chatcompletions_converter",
        "description": "tests.test_openai_chatcompletions_converter",
        "peekOfCode": "def test_message_to_output_items_with_refusal():\n    \"\"\"\n    Make sure a message with a refusal string produces a ResponseOutputMessage\n    with a ResponseOutputRefusal content part.\n    \"\"\"\n    msg = ChatCompletionMessage(role=\"assistant\", refusal=\"I'm sorry\")\n    items = _Converter.message_to_output_items(msg)\n    assert len(items) == 1\n    message_item = cast(ResponseOutputMessage, items[0])\n    assert len(message_item.content) == 1",
        "detail": "tests.test_openai_chatcompletions_converter",
        "documentation": {}
    },
    {
        "label": "test_message_to_output_items_with_tool_call",
        "kind": 2,
        "importPath": "tests.test_openai_chatcompletions_converter",
        "description": "tests.test_openai_chatcompletions_converter",
        "peekOfCode": "def test_message_to_output_items_with_tool_call():\n    \"\"\"\n    If the ChatCompletionMessage contains one or more tool_calls, they should\n    be reflected as separate `ResponseFunctionToolCall` items appended after\n    the message item.\n    \"\"\"\n    tool_call = ChatCompletionMessageToolCall(\n        id=\"tool1\",\n        type=\"function\",\n        function=Function(name=\"myfn\", arguments='{\"x\":1}'),",
        "detail": "tests.test_openai_chatcompletions_converter",
        "documentation": {}
    },
    {
        "label": "test_items_to_messages_with_string_user_content",
        "kind": 2,
        "importPath": "tests.test_openai_chatcompletions_converter",
        "description": "tests.test_openai_chatcompletions_converter",
        "peekOfCode": "def test_items_to_messages_with_string_user_content():\n    \"\"\"\n    A simple string as the items argument should be converted into a user\n    message param dict with the same content.\n    \"\"\"\n    result = _Converter.items_to_messages(\"Ask me anything\")\n    assert isinstance(result, list)\n    assert len(result) == 1\n    msg = result[0]\n    assert msg[\"role\"] == \"user\"",
        "detail": "tests.test_openai_chatcompletions_converter",
        "documentation": {}
    },
    {
        "label": "test_items_to_messages_with_easy_input_message",
        "kind": 2,
        "importPath": "tests.test_openai_chatcompletions_converter",
        "description": "tests.test_openai_chatcompletions_converter",
        "peekOfCode": "def test_items_to_messages_with_easy_input_message():\n    \"\"\"\n    Given an easy input message dict (just role/content), the converter should\n    produce the appropriate ChatCompletionMessageParam with the same content.\n    \"\"\"\n    items: list[TResponseInputItem] = [\n        {\n            \"role\": \"user\",\n            \"content\": \"How are you?\",\n        }",
        "detail": "tests.test_openai_chatcompletions_converter",
        "documentation": {}
    },
    {
        "label": "test_items_to_messages_with_output_message_and_function_call",
        "kind": 2,
        "importPath": "tests.test_openai_chatcompletions_converter",
        "description": "tests.test_openai_chatcompletions_converter",
        "peekOfCode": "def test_items_to_messages_with_output_message_and_function_call():\n    \"\"\"\n    Given a sequence of one ResponseOutputMessageParam followed by a\n    ResponseFunctionToolCallParam, the converter should produce a single\n    ChatCompletionAssistantMessageParam that includes both the assistant's\n    textual content and a populated `tool_calls` reflecting the function call.\n    \"\"\"\n    # Construct output message param dict with two content parts.\n    output_text: ResponseOutputText = ResponseOutputText(\n        text=\"Part 1\",",
        "detail": "tests.test_openai_chatcompletions_converter",
        "documentation": {}
    },
    {
        "label": "test_convert_tool_choice_handles_standard_and_named_options",
        "kind": 2,
        "importPath": "tests.test_openai_chatcompletions_converter",
        "description": "tests.test_openai_chatcompletions_converter",
        "peekOfCode": "def test_convert_tool_choice_handles_standard_and_named_options() -> None:\n    \"\"\"\n    The `_Converter.convert_tool_choice` method should return NOT_GIVEN\n    if no choice is provided, pass through values like \"auto\", \"required\",\n    or \"none\" unchanged, and translate any other string into a function\n    selection dict.\n    \"\"\"\n    assert _Converter.convert_tool_choice(None).__class__.__name__ == \"NotGiven\"\n    assert _Converter.convert_tool_choice(\"auto\") == \"auto\"\n    assert _Converter.convert_tool_choice(\"required\") == \"required\"",
        "detail": "tests.test_openai_chatcompletions_converter",
        "documentation": {}
    },
    {
        "label": "test_convert_response_format_returns_not_given_for_plain_text_and_dict_for_schemas",
        "kind": 2,
        "importPath": "tests.test_openai_chatcompletions_converter",
        "description": "tests.test_openai_chatcompletions_converter",
        "peekOfCode": "def test_convert_response_format_returns_not_given_for_plain_text_and_dict_for_schemas() -> None:\n    \"\"\"\n    The `_Converter.convert_response_format` method should return NOT_GIVEN\n    when no output schema is provided or if the output schema indicates\n    plain text. For structured output schemas, it should return a dict\n    with type `json_schema` and include the generated JSON schema and\n    strict flag from the provided `AgentOutputSchema`.\n    \"\"\"\n    # when output is plain text (schema None or output_type str), do not include response_format\n    assert _Converter.convert_response_format(None).__class__.__name__ == \"NotGiven\"",
        "detail": "tests.test_openai_chatcompletions_converter",
        "documentation": {}
    },
    {
        "label": "test_items_to_messages_with_function_output_item",
        "kind": 2,
        "importPath": "tests.test_openai_chatcompletions_converter",
        "description": "tests.test_openai_chatcompletions_converter",
        "peekOfCode": "def test_items_to_messages_with_function_output_item():\n    \"\"\"\n    A function call output item should be converted into a tool role message\n    dict with the appropriate tool_call_id and content.\n    \"\"\"\n    func_output_item: FunctionCallOutput = {\n        \"type\": \"function_call_output\",\n        \"call_id\": \"somecall\",\n        \"output\": '{\"foo\": \"bar\"}',\n    }",
        "detail": "tests.test_openai_chatcompletions_converter",
        "documentation": {}
    },
    {
        "label": "test_extract_all_and_text_content_for_strings_and_lists",
        "kind": 2,
        "importPath": "tests.test_openai_chatcompletions_converter",
        "description": "tests.test_openai_chatcompletions_converter",
        "peekOfCode": "def test_extract_all_and_text_content_for_strings_and_lists():\n    \"\"\"\n    The converter provides helpers for extracting user-supplied message content\n    either as a simple string or as a list of `input_text` dictionaries.\n    When passed a bare string, both `extract_all_content` and\n    `extract_text_content` should return the string unchanged.\n    When passed a list of input dictionaries, `extract_all_content` should\n    produce a list of `ChatCompletionContentPart` dicts, and `extract_text_content`\n    should filter to only the textual parts.\n    \"\"\"",
        "detail": "tests.test_openai_chatcompletions_converter",
        "documentation": {}
    },
    {
        "label": "test_items_to_messages_handles_system_and_developer_roles",
        "kind": 2,
        "importPath": "tests.test_openai_chatcompletions_converter",
        "description": "tests.test_openai_chatcompletions_converter",
        "peekOfCode": "def test_items_to_messages_handles_system_and_developer_roles():\n    \"\"\"\n    Roles other than `user` (e.g. `system` and `developer`) need to be\n    converted appropriately whether provided as simple dicts or as full\n    `message` typed dicts.\n    \"\"\"\n    sys_items: list[TResponseInputItem] = [{\"role\": \"system\", \"content\": \"setup\"}]\n    sys_msgs = _Converter.items_to_messages(sys_items)\n    assert len(sys_msgs) == 1\n    assert sys_msgs[0][\"role\"] == \"system\"",
        "detail": "tests.test_openai_chatcompletions_converter",
        "documentation": {}
    },
    {
        "label": "test_maybe_input_message_allows_message_typed_dict",
        "kind": 2,
        "importPath": "tests.test_openai_chatcompletions_converter",
        "description": "tests.test_openai_chatcompletions_converter",
        "peekOfCode": "def test_maybe_input_message_allows_message_typed_dict():\n    \"\"\"\n    The `_Converter.maybe_input_message` should recognize a dict with\n    \"type\": \"message\" and a supported role as an input message. Ensure\n    that such dicts are passed through by `items_to_messages`.\n    \"\"\"\n    # Construct a dict with the proper required keys for a ResponseInputParam.Message\n    message_dict: TResponseInputItem = {\n        \"type\": \"message\",\n        \"role\": \"user\",",
        "detail": "tests.test_openai_chatcompletions_converter",
        "documentation": {}
    },
    {
        "label": "test_tool_call_conversion",
        "kind": 2,
        "importPath": "tests.test_openai_chatcompletions_converter",
        "description": "tests.test_openai_chatcompletions_converter",
        "peekOfCode": "def test_tool_call_conversion():\n    \"\"\"\n    Test that tool calls are converted correctly.\n    \"\"\"\n    function_call = ResponseFunctionToolCallParam(\n        id=\"tool1\",\n        call_id=\"abc\",\n        name=\"math\",\n        arguments=\"{}\",\n        type=\"function_call\",",
        "detail": "tests.test_openai_chatcompletions_converter",
        "documentation": {}
    },
    {
        "label": "test_input_message_with_all_roles",
        "kind": 2,
        "importPath": "tests.test_openai_chatcompletions_converter",
        "description": "tests.test_openai_chatcompletions_converter",
        "peekOfCode": "def test_input_message_with_all_roles(role: str):\n    \"\"\"\n    The `_Converter.maybe_input_message` should recognize a dict with\n    \"type\": \"message\" and a supported role as an input message. Ensure\n    that such dicts are passed through by `items_to_messages`.\n    \"\"\"\n    # Construct a dict with the proper required keys for a ResponseInputParam.Message\n    casted_role = cast(Literal[\"user\", \"system\", \"developer\"], role)\n    message_dict: TResponseInputItem = {\n        \"type\": \"message\",",
        "detail": "tests.test_openai_chatcompletions_converter",
        "documentation": {}
    },
    {
        "label": "test_item_reference_errors",
        "kind": 2,
        "importPath": "tests.test_openai_chatcompletions_converter",
        "description": "tests.test_openai_chatcompletions_converter",
        "peekOfCode": "def test_item_reference_errors():\n    \"\"\"\n    Test that item references are converted correctly.\n    \"\"\"\n    with pytest.raises(UserError):\n        _Converter.items_to_messages(\n            [\n                {\n                    \"type\": \"item_reference\",\n                    \"id\": \"item1\",",
        "detail": "tests.test_openai_chatcompletions_converter",
        "documentation": {}
    },
    {
        "label": "test_unknown_object_errors",
        "kind": 2,
        "importPath": "tests.test_openai_chatcompletions_converter",
        "description": "tests.test_openai_chatcompletions_converter",
        "peekOfCode": "def test_unknown_object_errors():\n    \"\"\"\n    Test that unknown objects are converted correctly.\n    \"\"\"\n    with pytest.raises(UserError, match=\"Unhandled item type or structure\"):\n        # Purposely ignore the type error\n        _Converter.items_to_messages([TestObject()])  # type: ignore\ndef test_assistant_messages_in_history():\n    \"\"\"\n    Test that assistant messages are added to the history.",
        "detail": "tests.test_openai_chatcompletions_converter",
        "documentation": {}
    },
    {
        "label": "test_assistant_messages_in_history",
        "kind": 2,
        "importPath": "tests.test_openai_chatcompletions_converter",
        "description": "tests.test_openai_chatcompletions_converter",
        "peekOfCode": "def test_assistant_messages_in_history():\n    \"\"\"\n    Test that assistant messages are added to the history.\n    \"\"\"\n    messages = _Converter.items_to_messages(\n        [\n            {\n                \"role\": \"user\",\n                \"content\": \"Hello\",\n            },",
        "detail": "tests.test_openai_chatcompletions_converter",
        "documentation": {}
    },
    {
        "label": "test_convert_tool_choice_standard_values",
        "kind": 2,
        "importPath": "tests.test_openai_responses_converter",
        "description": "tests.test_openai_responses_converter",
        "peekOfCode": "def test_convert_tool_choice_standard_values():\n    \"\"\"\n    Make sure that the standard tool_choice values map to themselves or\n    to \"auto\"/\"required\"/\"none\" as appropriate, and that special string\n    values map to the appropriate dicts.\n    \"\"\"\n    assert Converter.convert_tool_choice(None) is NOT_GIVEN\n    assert Converter.convert_tool_choice(\"auto\") == \"auto\"\n    assert Converter.convert_tool_choice(\"required\") == \"required\"\n    assert Converter.convert_tool_choice(\"none\") == \"none\"",
        "detail": "tests.test_openai_responses_converter",
        "documentation": {}
    },
    {
        "label": "test_get_response_format_plain_text_and_json_schema",
        "kind": 2,
        "importPath": "tests.test_openai_responses_converter",
        "description": "tests.test_openai_responses_converter",
        "peekOfCode": "def test_get_response_format_plain_text_and_json_schema():\n    \"\"\"\n    For plain text output (default, or output type of `str`), the converter\n    should return NOT_GIVEN, indicating no special response format constraint.\n    If an output schema is provided for a structured type, the converter\n    should return a `format` dict with the schema and strictness. The exact\n    JSON schema depends on the output type; we just assert that required\n    keys are present and that we get back the original schema.\n    \"\"\"\n    # Default output (None) should be considered plain text.",
        "detail": "tests.test_openai_responses_converter",
        "documentation": {}
    },
    {
        "label": "test_convert_tools_basic_types_and_includes",
        "kind": 2,
        "importPath": "tests.test_openai_responses_converter",
        "description": "tests.test_openai_responses_converter",
        "peekOfCode": "def test_convert_tools_basic_types_and_includes():\n    \"\"\"\n    Construct a variety of tool types and make sure `convert_tools` returns\n    a matching list of tool param dicts and the expected includes. Also\n    check that only a single computer tool is allowed.\n    \"\"\"\n    # Simple function tool\n    tool_fn = function_tool(lambda a: \"x\", name_override=\"fn\")\n    # File search tool with include_search_results set\n    file_tool = FileSearchTool(",
        "detail": "tests.test_openai_responses_converter",
        "documentation": {}
    },
    {
        "label": "test_convert_tools_includes_handoffs",
        "kind": 2,
        "importPath": "tests.test_openai_responses_converter",
        "description": "tests.test_openai_responses_converter",
        "peekOfCode": "def test_convert_tools_includes_handoffs():\n    \"\"\"\n    When handoff objects are included, `convert_tools` should append their\n    tool param dicts after tools and include appropriate descriptions.\n    \"\"\"\n    agent = Agent(name=\"support\", handoff_description=\"Handles support\")\n    handoff_obj = handoff(agent)\n    converted = Converter.convert_tools(tools=[], handoffs=[handoff_obj])\n    assert isinstance(converted.tools, list)\n    assert len(converted.tools) == 1",
        "detail": "tests.test_openai_responses_converter",
        "documentation": {}
    },
    {
        "label": "Foo",
        "kind": 6,
        "importPath": "tests.test_output_tool",
        "description": "tests.test_output_tool",
        "peekOfCode": "class Foo(BaseModel):\n    bar: str\ndef test_structured_output_pydantic():\n    agent = Agent(name=\"test\", output_type=Foo)\n    output_schema = Runner._get_output_schema(agent)\n    assert output_schema, \"Should have an output tool config with a structured output type\"\n    assert output_schema.output_type == Foo, \"Should have the correct output type\"\n    assert not output_schema._is_wrapped, \"Pydantic objects should not be wrapped\"\n    for key, value in Foo.model_json_schema().items():\n        assert output_schema.json_schema()[key] == value",
        "detail": "tests.test_output_tool",
        "documentation": {}
    },
    {
        "label": "Bar",
        "kind": 6,
        "importPath": "tests.test_output_tool",
        "description": "tests.test_output_tool",
        "peekOfCode": "class Bar(TypedDict):\n    bar: str\ndef test_structured_output_typed_dict():\n    agent = Agent(name=\"test\", output_type=Bar)\n    output_schema = Runner._get_output_schema(agent)\n    assert output_schema, \"Should have an output tool config with a structured output type\"\n    assert output_schema.output_type == Bar, \"Should have the correct output type\"\n    assert not output_schema._is_wrapped, \"TypedDicts should not be wrapped\"\n    json_str = json.dumps(Bar(bar=\"baz\"))\n    validated = output_schema.validate_json(json_str)",
        "detail": "tests.test_output_tool",
        "documentation": {}
    },
    {
        "label": "test_plain_text_output",
        "kind": 2,
        "importPath": "tests.test_output_tool",
        "description": "tests.test_output_tool",
        "peekOfCode": "def test_plain_text_output():\n    agent = Agent(name=\"test\")\n    output_schema = Runner._get_output_schema(agent)\n    assert not output_schema, \"Shouldn't have an output tool config without an output type\"\n    agent = Agent(name=\"test\", output_type=str)\n    assert not output_schema, \"Shouldn't have an output tool config with str output type\"\nclass Foo(BaseModel):\n    bar: str\ndef test_structured_output_pydantic():\n    agent = Agent(name=\"test\", output_type=Foo)",
        "detail": "tests.test_output_tool",
        "documentation": {}
    },
    {
        "label": "test_structured_output_pydantic",
        "kind": 2,
        "importPath": "tests.test_output_tool",
        "description": "tests.test_output_tool",
        "peekOfCode": "def test_structured_output_pydantic():\n    agent = Agent(name=\"test\", output_type=Foo)\n    output_schema = Runner._get_output_schema(agent)\n    assert output_schema, \"Should have an output tool config with a structured output type\"\n    assert output_schema.output_type == Foo, \"Should have the correct output type\"\n    assert not output_schema._is_wrapped, \"Pydantic objects should not be wrapped\"\n    for key, value in Foo.model_json_schema().items():\n        assert output_schema.json_schema()[key] == value\n    json_str = Foo(bar=\"baz\").model_dump_json()\n    validated = output_schema.validate_json(json_str)",
        "detail": "tests.test_output_tool",
        "documentation": {}
    },
    {
        "label": "test_structured_output_typed_dict",
        "kind": 2,
        "importPath": "tests.test_output_tool",
        "description": "tests.test_output_tool",
        "peekOfCode": "def test_structured_output_typed_dict():\n    agent = Agent(name=\"test\", output_type=Bar)\n    output_schema = Runner._get_output_schema(agent)\n    assert output_schema, \"Should have an output tool config with a structured output type\"\n    assert output_schema.output_type == Bar, \"Should have the correct output type\"\n    assert not output_schema._is_wrapped, \"TypedDicts should not be wrapped\"\n    json_str = json.dumps(Bar(bar=\"baz\"))\n    validated = output_schema.validate_json(json_str)\n    assert validated == Bar(bar=\"baz\")\ndef test_structured_output_list():",
        "detail": "tests.test_output_tool",
        "documentation": {}
    },
    {
        "label": "test_structured_output_list",
        "kind": 2,
        "importPath": "tests.test_output_tool",
        "description": "tests.test_output_tool",
        "peekOfCode": "def test_structured_output_list():\n    agent = Agent(name=\"test\", output_type=list[str])\n    output_schema = Runner._get_output_schema(agent)\n    assert output_schema, \"Should have an output tool config with a structured output type\"\n    assert output_schema.output_type == list[str], \"Should have the correct output type\"\n    assert output_schema._is_wrapped, \"Lists should be wrapped\"\n    # This is testing implementation details, but it's useful  to make sure this doesn't break\n    json_str = json.dumps({_WRAPPER_DICT_KEY: [\"foo\", \"bar\"]})\n    validated = output_schema.validate_json(json_str)\n    assert validated == [\"foo\", \"bar\"]",
        "detail": "tests.test_output_tool",
        "documentation": {}
    },
    {
        "label": "test_bad_json_raises_error",
        "kind": 2,
        "importPath": "tests.test_output_tool",
        "description": "tests.test_output_tool",
        "peekOfCode": "def test_bad_json_raises_error(mocker):\n    agent = Agent(name=\"test\", output_type=Foo)\n    output_schema = Runner._get_output_schema(agent)\n    assert output_schema, \"Should have an output tool config with a structured output type\"\n    with pytest.raises(ModelBehaviorError):\n        output_schema.validate_json(\"not valid json\")\n    agent = Agent(name=\"test\", output_type=list[str])\n    output_schema = Runner._get_output_schema(agent)\n    assert output_schema, \"Should have an output tool config with a structured output type\"\n    mock_validate_json = mocker.patch.object(_json, \"validate_json\")",
        "detail": "tests.test_output_tool",
        "documentation": {}
    },
    {
        "label": "test_plain_text_obj_doesnt_produce_schema",
        "kind": 2,
        "importPath": "tests.test_output_tool",
        "description": "tests.test_output_tool",
        "peekOfCode": "def test_plain_text_obj_doesnt_produce_schema():\n    output_wrapper = AgentOutputSchema(output_type=str)\n    with pytest.raises(UserError):\n        output_wrapper.json_schema()\ndef test_structured_output_is_strict():\n    output_wrapper = AgentOutputSchema(output_type=Foo)\n    assert output_wrapper.strict_json_schema\n    for key, value in Foo.model_json_schema().items():\n        assert output_wrapper.json_schema()[key] == value\n    assert (",
        "detail": "tests.test_output_tool",
        "documentation": {}
    },
    {
        "label": "test_structured_output_is_strict",
        "kind": 2,
        "importPath": "tests.test_output_tool",
        "description": "tests.test_output_tool",
        "peekOfCode": "def test_structured_output_is_strict():\n    output_wrapper = AgentOutputSchema(output_type=Foo)\n    assert output_wrapper.strict_json_schema\n    for key, value in Foo.model_json_schema().items():\n        assert output_wrapper.json_schema()[key] == value\n    assert (\n        \"additionalProperties\" in output_wrapper.json_schema()\n        and not output_wrapper.json_schema()[\"additionalProperties\"]\n    )\ndef test_setting_strict_false_works():",
        "detail": "tests.test_output_tool",
        "documentation": {}
    },
    {
        "label": "test_setting_strict_false_works",
        "kind": 2,
        "importPath": "tests.test_output_tool",
        "description": "tests.test_output_tool",
        "peekOfCode": "def test_setting_strict_false_works():\n    output_wrapper = AgentOutputSchema(output_type=Foo, strict_json_schema=False)\n    assert not output_wrapper.strict_json_schema\n    assert output_wrapper.json_schema() == Foo.model_json_schema()\n    assert output_wrapper.json_schema() == Foo.model_json_schema()",
        "detail": "tests.test_output_tool",
        "documentation": {}
    },
    {
        "label": "Foo",
        "kind": 6,
        "importPath": "tests.test_pretty_print",
        "description": "tests.test_pretty_print",
        "peekOfCode": "class Foo(BaseModel):\n    bar: str\n@pytest.mark.asyncio\nasync def test_pretty_run_result_structured_output():\n    model = FakeModel()\n    model.set_next_output(\n        [\n            get_text_message(\"Test\"),\n            get_final_output_message(Foo(bar=\"Hi there\").model_dump_json()),\n        ]",
        "detail": "tests.test_pretty_print",
        "documentation": {}
    },
    {
        "label": "get_text_input_item",
        "kind": 2,
        "importPath": "tests.test_responses",
        "description": "tests.test_responses",
        "peekOfCode": "def get_text_input_item(content: str) -> TResponseInputItem:\n    return {\n        \"content\": content,\n        \"role\": \"user\",\n    }\ndef get_text_message(content: str) -> ResponseOutputItem:\n    return ResponseOutputMessage(\n        id=\"1\",\n        type=\"message\",\n        role=\"assistant\",",
        "detail": "tests.test_responses",
        "documentation": {}
    },
    {
        "label": "get_text_message",
        "kind": 2,
        "importPath": "tests.test_responses",
        "description": "tests.test_responses",
        "peekOfCode": "def get_text_message(content: str) -> ResponseOutputItem:\n    return ResponseOutputMessage(\n        id=\"1\",\n        type=\"message\",\n        role=\"assistant\",\n        content=[ResponseOutputText(text=content, type=\"output_text\", annotations=[])],\n        status=\"completed\",\n    )\ndef get_function_tool(\n    name: str | None = None, return_value: str | None = None, hide_errors: bool = False",
        "detail": "tests.test_responses",
        "documentation": {}
    },
    {
        "label": "get_function_tool",
        "kind": 2,
        "importPath": "tests.test_responses",
        "description": "tests.test_responses",
        "peekOfCode": "def get_function_tool(\n    name: str | None = None, return_value: str | None = None, hide_errors: bool = False\n) -> FunctionTool:\n    def _foo() -> str:\n        return return_value or \"result_ok\"\n    return function_tool(\n        _foo,\n        name_override=name,\n        failure_error_function=None if hide_errors else default_tool_error_function,\n    )",
        "detail": "tests.test_responses",
        "documentation": {}
    },
    {
        "label": "get_function_tool_call",
        "kind": 2,
        "importPath": "tests.test_responses",
        "description": "tests.test_responses",
        "peekOfCode": "def get_function_tool_call(name: str, arguments: str | None = None) -> ResponseOutputItem:\n    return ResponseFunctionToolCall(\n        id=\"1\",\n        call_id=\"2\",\n        type=\"function_call\",\n        name=name,\n        arguments=arguments or \"\",\n    )\ndef get_handoff_tool_call(\n    to_agent: Agent[Any], override_name: str | None = None, args: str | None = None",
        "detail": "tests.test_responses",
        "documentation": {}
    },
    {
        "label": "get_handoff_tool_call",
        "kind": 2,
        "importPath": "tests.test_responses",
        "description": "tests.test_responses",
        "peekOfCode": "def get_handoff_tool_call(\n    to_agent: Agent[Any], override_name: str | None = None, args: str | None = None\n) -> ResponseOutputItem:\n    name = override_name or Handoff.default_tool_name(to_agent)\n    return get_function_tool_call(name, args)\ndef get_final_output_message(args: str) -> ResponseOutputItem:\n    return ResponseOutputMessage(\n        id=\"1\",\n        type=\"message\",\n        role=\"assistant\",",
        "detail": "tests.test_responses",
        "documentation": {}
    },
    {
        "label": "get_final_output_message",
        "kind": 2,
        "importPath": "tests.test_responses",
        "description": "tests.test_responses",
        "peekOfCode": "def get_final_output_message(args: str) -> ResponseOutputItem:\n    return ResponseOutputMessage(\n        id=\"1\",\n        type=\"message\",\n        role=\"assistant\",\n        content=[ResponseOutputText(text=args, type=\"output_text\", annotations=[])],\n        status=\"completed\",\n    )",
        "detail": "tests.test_responses",
        "documentation": {}
    },
    {
        "label": "DummyTracing",
        "kind": 6,
        "importPath": "tests.test_responses_tracing",
        "description": "tests.test_responses_tracing",
        "peekOfCode": "class DummyTracing:\n    def is_disabled(self):\n        return False\nclass DummyUsage:\n    def __init__(self, input_tokens=1, output_tokens=1, total_tokens=2):\n        self.input_tokens = input_tokens\n        self.output_tokens = output_tokens\n        self.total_tokens = total_tokens\nclass DummyResponse:\n    def __init__(self):",
        "detail": "tests.test_responses_tracing",
        "documentation": {}
    },
    {
        "label": "DummyUsage",
        "kind": 6,
        "importPath": "tests.test_responses_tracing",
        "description": "tests.test_responses_tracing",
        "peekOfCode": "class DummyUsage:\n    def __init__(self, input_tokens=1, output_tokens=1, total_tokens=2):\n        self.input_tokens = input_tokens\n        self.output_tokens = output_tokens\n        self.total_tokens = total_tokens\nclass DummyResponse:\n    def __init__(self):\n        self.id = \"dummy-id\"\n        self.output = []\n        self.usage = DummyUsage()",
        "detail": "tests.test_responses_tracing",
        "documentation": {}
    },
    {
        "label": "DummyResponse",
        "kind": 6,
        "importPath": "tests.test_responses_tracing",
        "description": "tests.test_responses_tracing",
        "peekOfCode": "class DummyResponse:\n    def __init__(self):\n        self.id = \"dummy-id\"\n        self.output = []\n        self.usage = DummyUsage()\n    def __aiter__(self):\n        yield ResponseCompletedEvent(\n            type=\"response.completed\",\n            response=fake_model.get_response_obj(self.output),\n        )",
        "detail": "tests.test_responses_tracing",
        "documentation": {}
    },
    {
        "label": "Foo",
        "kind": 6,
        "importPath": "tests.test_result_cast",
        "description": "tests.test_result_cast",
        "peekOfCode": "class Foo(BaseModel):\n    bar: int\ndef test_result_cast_typechecks():\n    \"\"\"Correct casts should work fine.\"\"\"\n    result = create_run_result(1)\n    assert result.final_output_as(int) == 1\n    result = create_run_result(\"test\")\n    assert result.final_output_as(str) == \"test\"\n    result = create_run_result(Foo(bar=1))\n    assert result.final_output_as(Foo) == Foo(bar=1)",
        "detail": "tests.test_result_cast",
        "documentation": {}
    },
    {
        "label": "create_run_result",
        "kind": 2,
        "importPath": "tests.test_result_cast",
        "description": "tests.test_result_cast",
        "peekOfCode": "def create_run_result(final_output: Any) -> RunResult:\n    return RunResult(\n        input=\"test\",\n        new_items=[],\n        raw_responses=[],\n        final_output=final_output,\n        input_guardrail_results=[],\n        output_guardrail_results=[],\n        _last_agent=Agent(name=\"test\"),\n    )",
        "detail": "tests.test_result_cast",
        "documentation": {}
    },
    {
        "label": "test_result_cast_typechecks",
        "kind": 2,
        "importPath": "tests.test_result_cast",
        "description": "tests.test_result_cast",
        "peekOfCode": "def test_result_cast_typechecks():\n    \"\"\"Correct casts should work fine.\"\"\"\n    result = create_run_result(1)\n    assert result.final_output_as(int) == 1\n    result = create_run_result(\"test\")\n    assert result.final_output_as(str) == \"test\"\n    result = create_run_result(Foo(bar=1))\n    assert result.final_output_as(Foo) == Foo(bar=1)\ndef test_bad_cast_doesnt_raise():\n    \"\"\"Bad casts shouldn't error unless we ask for it.\"\"\"",
        "detail": "tests.test_result_cast",
        "documentation": {}
    },
    {
        "label": "test_bad_cast_doesnt_raise",
        "kind": 2,
        "importPath": "tests.test_result_cast",
        "description": "tests.test_result_cast",
        "peekOfCode": "def test_bad_cast_doesnt_raise():\n    \"\"\"Bad casts shouldn't error unless we ask for it.\"\"\"\n    result = create_run_result(1)\n    result.final_output_as(str)\n    result = create_run_result(\"test\")\n    result.final_output_as(Foo)\ndef test_bad_cast_with_param_raises():\n    \"\"\"Bad casts should raise a TypeError when we ask for it.\"\"\"\n    result = create_run_result(1)\n    with pytest.raises(TypeError):",
        "detail": "tests.test_result_cast",
        "documentation": {}
    },
    {
        "label": "test_bad_cast_with_param_raises",
        "kind": 2,
        "importPath": "tests.test_result_cast",
        "description": "tests.test_result_cast",
        "peekOfCode": "def test_bad_cast_with_param_raises():\n    \"\"\"Bad casts should raise a TypeError when we ask for it.\"\"\"\n    result = create_run_result(1)\n    with pytest.raises(TypeError):\n        result.final_output_as(str, raise_if_incorrect_type=True)\n    result = create_run_result(\"test\")\n    with pytest.raises(TypeError):\n        result.final_output_as(Foo, raise_if_incorrect_type=True)\n    result = create_run_result(Foo(bar=1))\n    with pytest.raises(TypeError):",
        "detail": "tests.test_result_cast",
        "documentation": {}
    },
    {
        "label": "DummyProvider",
        "kind": 6,
        "importPath": "tests.test_run_config",
        "description": "tests.test_run_config",
        "peekOfCode": "class DummyProvider(ModelProvider):\n    \"\"\"A simple model provider that always returns the same model, and\n    records the model name it was asked to provide.\"\"\"\n    def __init__(self, model_to_return: Model | None = None) -> None:\n        self.last_requested: str | None = None\n        self.model_to_return: Model = model_to_return or FakeModel()\n    def get_model(self, model_name: str | None) -> Model:\n        # record the requested model name and return our test model\n        self.last_requested = model_name\n        return self.model_to_return",
        "detail": "tests.test_run_config",
        "documentation": {}
    },
    {
        "label": "Foo",
        "kind": 6,
        "importPath": "tests.test_run_step_execution",
        "description": "tests.test_run_step_execution",
        "peekOfCode": "class Foo(BaseModel):\n    bar: str\n@pytest.mark.asyncio\nasync def test_final_output_without_tool_runs_again():\n    agent = Agent(name=\"test\", output_type=Foo, tools=[get_function_tool(\"tool_1\", \"result\")])\n    response = ModelResponse(\n        output=[get_function_tool_call(\"tool_1\")],\n        usage=Usage(),\n        referenceable_id=None,\n    )",
        "detail": "tests.test_run_step_execution",
        "documentation": {}
    },
    {
        "label": "assert_item_is_message",
        "kind": 2,
        "importPath": "tests.test_run_step_execution",
        "description": "tests.test_run_step_execution",
        "peekOfCode": "def assert_item_is_message(item: RunItem, text: str) -> None:\n    assert isinstance(item, MessageOutputItem)\n    assert item.raw_item.type == \"message\"\n    assert item.raw_item.role == \"assistant\"\n    assert item.raw_item.content[0].type == \"output_text\"\n    assert item.raw_item.content[0].text == text\ndef assert_item_is_function_tool_call(\n    item: RunItem, name: str, arguments: str | None = None\n) -> None:\n    assert isinstance(item, ToolCallItem)",
        "detail": "tests.test_run_step_execution",
        "documentation": {}
    },
    {
        "label": "assert_item_is_function_tool_call",
        "kind": 2,
        "importPath": "tests.test_run_step_execution",
        "description": "tests.test_run_step_execution",
        "peekOfCode": "def assert_item_is_function_tool_call(\n    item: RunItem, name: str, arguments: str | None = None\n) -> None:\n    assert isinstance(item, ToolCallItem)\n    assert item.raw_item.type == \"function_call\"\n    assert item.raw_item.name == name\n    assert not arguments or item.raw_item.arguments == arguments\ndef assert_item_is_function_tool_call_output(item: RunItem, output: str) -> None:\n    assert isinstance(item, ToolCallOutputItem)\n    assert item.raw_item[\"type\"] == \"function_call_output\"",
        "detail": "tests.test_run_step_execution",
        "documentation": {}
    },
    {
        "label": "assert_item_is_function_tool_call_output",
        "kind": 2,
        "importPath": "tests.test_run_step_execution",
        "description": "tests.test_run_step_execution",
        "peekOfCode": "def assert_item_is_function_tool_call_output(item: RunItem, output: str) -> None:\n    assert isinstance(item, ToolCallOutputItem)\n    assert item.raw_item[\"type\"] == \"function_call_output\"\n    assert item.raw_item[\"output\"] == output\nasync def get_execute_result(\n    agent: Agent[Any],\n    response: ModelResponse,\n    *,\n    original_input: str | list[TResponseInputItem] | None = None,\n    generated_items: list[RunItem] | None = None,",
        "detail": "tests.test_run_step_execution",
        "documentation": {}
    },
    {
        "label": "Foo",
        "kind": 6,
        "importPath": "tests.test_run_step_processing",
        "description": "tests.test_run_step_processing",
        "peekOfCode": "class Foo(BaseModel):\n    bar: str\ndef test_final_output_parsed_correctly():\n    agent = Agent(name=\"test\", output_type=Foo)\n    response = ModelResponse(\n        output=[\n            get_text_message(\"Hello, world!\"),\n            get_final_output_message(Foo(bar=\"123\").model_dump_json()),\n        ],\n        usage=Usage(),",
        "detail": "tests.test_run_step_processing",
        "documentation": {}
    },
    {
        "label": "DummyComputer",
        "kind": 6,
        "importPath": "tests.test_run_step_processing",
        "description": "tests.test_run_step_processing",
        "peekOfCode": "class DummyComputer(Computer):\n    \"\"\"Minimal computer implementation for testing.\"\"\"\n    @property\n    def environment(self):\n        return \"mac\"  # pragma: no cover\n    @property\n    def dimensions(self):\n        return (0, 0)  # pragma: no cover\n    def screenshot(self) -> str:\n        return \"\"  # pragma: no cover",
        "detail": "tests.test_run_step_processing",
        "documentation": {}
    },
    {
        "label": "test_empty_response",
        "kind": 2,
        "importPath": "tests.test_run_step_processing",
        "description": "tests.test_run_step_processing",
        "peekOfCode": "def test_empty_response():\n    agent = Agent(name=\"test\")\n    response = ModelResponse(\n        output=[],\n        usage=Usage(),\n        referenceable_id=None,\n    )\n    result = RunImpl.process_model_response(\n        agent=agent, response=response, output_schema=None, handoffs=[]\n    )",
        "detail": "tests.test_run_step_processing",
        "documentation": {}
    },
    {
        "label": "test_no_tool_calls",
        "kind": 2,
        "importPath": "tests.test_run_step_processing",
        "description": "tests.test_run_step_processing",
        "peekOfCode": "def test_no_tool_calls():\n    agent = Agent(name=\"test\")\n    response = ModelResponse(\n        output=[get_text_message(\"Hello, world!\")],\n        usage=Usage(),\n        referenceable_id=None,\n    )\n    result = RunImpl.process_model_response(\n        agent=agent, response=response, output_schema=None, handoffs=[]\n    )",
        "detail": "tests.test_run_step_processing",
        "documentation": {}
    },
    {
        "label": "test_single_tool_call",
        "kind": 2,
        "importPath": "tests.test_run_step_processing",
        "description": "tests.test_run_step_processing",
        "peekOfCode": "def test_single_tool_call():\n    agent = Agent(name=\"test\", tools=[get_function_tool(name=\"test\")])\n    response = ModelResponse(\n        output=[\n            get_text_message(\"Hello, world!\"),\n            get_function_tool_call(\"test\", \"\"),\n        ],\n        usage=Usage(),\n        referenceable_id=None,\n    )",
        "detail": "tests.test_run_step_processing",
        "documentation": {}
    },
    {
        "label": "test_missing_tool_call_raises_error",
        "kind": 2,
        "importPath": "tests.test_run_step_processing",
        "description": "tests.test_run_step_processing",
        "peekOfCode": "def test_missing_tool_call_raises_error():\n    agent = Agent(name=\"test\", tools=[get_function_tool(name=\"test\")])\n    response = ModelResponse(\n        output=[\n            get_text_message(\"Hello, world!\"),\n            get_function_tool_call(\"missing\", \"\"),\n        ],\n        usage=Usage(),\n        referenceable_id=None,\n    )",
        "detail": "tests.test_run_step_processing",
        "documentation": {}
    },
    {
        "label": "test_multiple_tool_calls",
        "kind": 2,
        "importPath": "tests.test_run_step_processing",
        "description": "tests.test_run_step_processing",
        "peekOfCode": "def test_multiple_tool_calls():\n    agent = Agent(\n        name=\"test\",\n        tools=[\n            get_function_tool(name=\"test_1\"),\n            get_function_tool(name=\"test_2\"),\n            get_function_tool(name=\"test_3\"),\n        ],\n    )\n    response = ModelResponse(",
        "detail": "tests.test_run_step_processing",
        "documentation": {}
    },
    {
        "label": "test_multiple_handoffs_doesnt_error",
        "kind": 2,
        "importPath": "tests.test_run_step_processing",
        "description": "tests.test_run_step_processing",
        "peekOfCode": "def test_multiple_handoffs_doesnt_error():\n    agent_1 = Agent(name=\"test_1\")\n    agent_2 = Agent(name=\"test_2\")\n    agent_3 = Agent(name=\"test_3\", handoffs=[agent_1, agent_2])\n    response = ModelResponse(\n        output=[\n            get_text_message(\"Hello, world!\"),\n            get_handoff_tool_call(agent_1),\n            get_handoff_tool_call(agent_2),\n        ],",
        "detail": "tests.test_run_step_processing",
        "documentation": {}
    },
    {
        "label": "test_final_output_parsed_correctly",
        "kind": 2,
        "importPath": "tests.test_run_step_processing",
        "description": "tests.test_run_step_processing",
        "peekOfCode": "def test_final_output_parsed_correctly():\n    agent = Agent(name=\"test\", output_type=Foo)\n    response = ModelResponse(\n        output=[\n            get_text_message(\"Hello, world!\"),\n            get_final_output_message(Foo(bar=\"123\").model_dump_json()),\n        ],\n        usage=Usage(),\n        referenceable_id=None,\n    )",
        "detail": "tests.test_run_step_processing",
        "documentation": {}
    },
    {
        "label": "test_file_search_tool_call_parsed_correctly",
        "kind": 2,
        "importPath": "tests.test_run_step_processing",
        "description": "tests.test_run_step_processing",
        "peekOfCode": "def test_file_search_tool_call_parsed_correctly():\n    # Ensure that a ResponseFileSearchToolCall output is parsed into a ToolCallItem and that no tool\n    # runs are scheduled.\n    agent = Agent(name=\"test\")\n    file_search_call = ResponseFileSearchToolCall(\n        id=\"fs1\",\n        queries=[\"query\"],\n        status=\"completed\",\n        type=\"file_search_call\",\n    )",
        "detail": "tests.test_run_step_processing",
        "documentation": {}
    },
    {
        "label": "test_function_web_search_tool_call_parsed_correctly",
        "kind": 2,
        "importPath": "tests.test_run_step_processing",
        "description": "tests.test_run_step_processing",
        "peekOfCode": "def test_function_web_search_tool_call_parsed_correctly():\n    agent = Agent(name=\"test\")\n    web_search_call = ResponseFunctionWebSearch(id=\"w1\", status=\"completed\", type=\"web_search_call\")\n    response = ModelResponse(\n        output=[get_text_message(\"hello\"), web_search_call],\n        usage=Usage(),\n        referenceable_id=None,\n    )\n    result = RunImpl.process_model_response(\n        agent=agent, response=response, output_schema=None, handoffs=[]",
        "detail": "tests.test_run_step_processing",
        "documentation": {}
    },
    {
        "label": "test_reasoning_item_parsed_correctly",
        "kind": 2,
        "importPath": "tests.test_run_step_processing",
        "description": "tests.test_run_step_processing",
        "peekOfCode": "def test_reasoning_item_parsed_correctly():\n    # Verify that a Reasoning output item is converted into a ReasoningItem.\n    reasoning = ResponseReasoningItem(\n        id=\"r1\", type=\"reasoning\", summary=[Summary(text=\"why\", type=\"summary_text\")]\n    )\n    response = ModelResponse(\n        output=[reasoning],\n        usage=Usage(),\n        referenceable_id=None,\n    )",
        "detail": "tests.test_run_step_processing",
        "documentation": {}
    },
    {
        "label": "test_computer_tool_call_without_computer_tool_raises_error",
        "kind": 2,
        "importPath": "tests.test_run_step_processing",
        "description": "tests.test_run_step_processing",
        "peekOfCode": "def test_computer_tool_call_without_computer_tool_raises_error():\n    # If the agent has no ComputerTool in its tools, process_model_response should raise a\n    # ModelBehaviorError when encountering a ResponseComputerToolCall.\n    computer_call = ResponseComputerToolCall(\n        id=\"c1\",\n        type=\"computer_call\",\n        action=ActionClick(type=\"click\", x=1, y=2, button=\"left\"),\n        call_id=\"c1\",\n        pending_safety_checks=[],\n        status=\"completed\",",
        "detail": "tests.test_run_step_processing",
        "documentation": {}
    },
    {
        "label": "test_computer_tool_call_with_computer_tool_parsed_correctly",
        "kind": 2,
        "importPath": "tests.test_run_step_processing",
        "description": "tests.test_run_step_processing",
        "peekOfCode": "def test_computer_tool_call_with_computer_tool_parsed_correctly():\n    # If the agent contains a ComputerTool, ensure that a ResponseComputerToolCall is parsed into a\n    # ToolCallItem and scheduled to run in computer_actions.\n    dummy_computer = DummyComputer()\n    agent = Agent(name=\"test\", tools=[ComputerTool(computer=dummy_computer)])\n    computer_call = ResponseComputerToolCall(\n        id=\"c1\",\n        type=\"computer_call\",\n        action=ActionClick(type=\"click\", x=1, y=2, button=\"left\"),\n        call_id=\"c1\",",
        "detail": "tests.test_run_step_processing",
        "documentation": {}
    },
    {
        "label": "test_tool_and_handoff_parsed_correctly",
        "kind": 2,
        "importPath": "tests.test_run_step_processing",
        "description": "tests.test_run_step_processing",
        "peekOfCode": "def test_tool_and_handoff_parsed_correctly():\n    agent_1 = Agent(name=\"test_1\")\n    agent_2 = Agent(name=\"test_2\")\n    agent_3 = Agent(\n        name=\"test_3\", tools=[get_function_tool(name=\"test\")], handoffs=[agent_1, agent_2]\n    )\n    response = ModelResponse(\n        output=[\n            get_text_message(\"Hello, world!\"),\n            get_function_tool_call(\"test\", \"abc\"),",
        "detail": "tests.test_run_step_processing",
        "documentation": {}
    },
    {
        "label": "test_empty_schema_has_additional_properties_false",
        "kind": 2,
        "importPath": "tests.test_strict_schema",
        "description": "tests.test_strict_schema",
        "peekOfCode": "def test_empty_schema_has_additional_properties_false():\n    strict_schema = ensure_strict_json_schema({})\n    assert strict_schema[\"additionalProperties\"] is False\ndef test_non_dict_schema_errors():\n    with pytest.raises(TypeError):\n        ensure_strict_json_schema([])  # type: ignore\ndef test_object_without_additional_properties():\n    # When an object type schema has properties but no additionalProperties,\n    # it should be added and the \"required\" list set from the property keys.\n    schema = {\"type\": \"object\", \"properties\": {\"a\": {\"type\": \"string\"}}}",
        "detail": "tests.test_strict_schema",
        "documentation": {}
    },
    {
        "label": "test_non_dict_schema_errors",
        "kind": 2,
        "importPath": "tests.test_strict_schema",
        "description": "tests.test_strict_schema",
        "peekOfCode": "def test_non_dict_schema_errors():\n    with pytest.raises(TypeError):\n        ensure_strict_json_schema([])  # type: ignore\ndef test_object_without_additional_properties():\n    # When an object type schema has properties but no additionalProperties,\n    # it should be added and the \"required\" list set from the property keys.\n    schema = {\"type\": \"object\", \"properties\": {\"a\": {\"type\": \"string\"}}}\n    result = ensure_strict_json_schema(schema)\n    assert result[\"type\"] == \"object\"\n    assert result[\"additionalProperties\"] is False",
        "detail": "tests.test_strict_schema",
        "documentation": {}
    },
    {
        "label": "test_object_without_additional_properties",
        "kind": 2,
        "importPath": "tests.test_strict_schema",
        "description": "tests.test_strict_schema",
        "peekOfCode": "def test_object_without_additional_properties():\n    # When an object type schema has properties but no additionalProperties,\n    # it should be added and the \"required\" list set from the property keys.\n    schema = {\"type\": \"object\", \"properties\": {\"a\": {\"type\": \"string\"}}}\n    result = ensure_strict_json_schema(schema)\n    assert result[\"type\"] == \"object\"\n    assert result[\"additionalProperties\"] is False\n    assert result[\"required\"] == [\"a\"]\n    # The inner property remains unchanged (no additionalProperties is added for non-object types)\n    assert result[\"properties\"][\"a\"] == {\"type\": \"string\"}",
        "detail": "tests.test_strict_schema",
        "documentation": {}
    },
    {
        "label": "test_object_with_true_additional_properties",
        "kind": 2,
        "importPath": "tests.test_strict_schema",
        "description": "tests.test_strict_schema",
        "peekOfCode": "def test_object_with_true_additional_properties():\n    # If additionalProperties is explicitly set to True for an object, a UserError should be raised.\n    schema = {\n        \"type\": \"object\",\n        \"properties\": {\"a\": {\"type\": \"number\"}},\n        \"additionalProperties\": True,\n    }\n    with pytest.raises(UserError):\n        ensure_strict_json_schema(schema)\ndef test_array_items_processing_and_default_removal():",
        "detail": "tests.test_strict_schema",
        "documentation": {}
    },
    {
        "label": "test_array_items_processing_and_default_removal",
        "kind": 2,
        "importPath": "tests.test_strict_schema",
        "description": "tests.test_strict_schema",
        "peekOfCode": "def test_array_items_processing_and_default_removal():\n    # When processing an array, the items schema is processed recursively.\n    # Also, any \"default\": None should be removed.\n    schema = {\n        \"type\": \"array\",\n        \"items\": {\"type\": \"number\", \"default\": None},\n    }\n    result = ensure_strict_json_schema(schema)\n    # \"default\" should be stripped from the items schema.\n    assert \"default\" not in result[\"items\"]",
        "detail": "tests.test_strict_schema",
        "documentation": {}
    },
    {
        "label": "test_anyOf_processing",
        "kind": 2,
        "importPath": "tests.test_strict_schema",
        "description": "tests.test_strict_schema",
        "peekOfCode": "def test_anyOf_processing():\n    # Test that anyOf schemas are processed.\n    schema = {\n        \"anyOf\": [\n            {\"type\": \"object\", \"properties\": {\"a\": {\"type\": \"string\"}}},\n            {\"type\": \"number\", \"default\": None},\n        ]\n    }\n    result = ensure_strict_json_schema(schema)\n    # For the first variant: object type should get additionalProperties and required keys set.",
        "detail": "tests.test_strict_schema",
        "documentation": {}
    },
    {
        "label": "test_allOf_single_entry_merging",
        "kind": 2,
        "importPath": "tests.test_strict_schema",
        "description": "tests.test_strict_schema",
        "peekOfCode": "def test_allOf_single_entry_merging():\n    # When an allOf list has a single entry, its content should be merged into the parent.\n    schema = {\n        \"type\": \"object\",\n        \"allOf\": [{\"properties\": {\"a\": {\"type\": \"boolean\"}}}],\n    }\n    result = ensure_strict_json_schema(schema)\n    # allOf should be removed and merged.\n    assert \"allOf\" not in result\n    # The object should now have additionalProperties set and required set.",
        "detail": "tests.test_strict_schema",
        "documentation": {}
    },
    {
        "label": "test_default_removal_on_non_object",
        "kind": 2,
        "importPath": "tests.test_strict_schema",
        "description": "tests.test_strict_schema",
        "peekOfCode": "def test_default_removal_on_non_object():\n    # Test that \"default\": None is stripped from schemas that are not objects.\n    schema = {\"type\": \"string\", \"default\": None}\n    result = ensure_strict_json_schema(schema)\n    assert result[\"type\"] == \"string\"\n    assert \"default\" not in result\ndef test_ref_expansion():\n    # Construct a schema with a definitions section and a property with a $ref.\n    schema = {\n        \"definitions\": {\"refObj\": {\"type\": \"string\", \"default\": None}},",
        "detail": "tests.test_strict_schema",
        "documentation": {}
    },
    {
        "label": "test_ref_expansion",
        "kind": 2,
        "importPath": "tests.test_strict_schema",
        "description": "tests.test_strict_schema",
        "peekOfCode": "def test_ref_expansion():\n    # Construct a schema with a definitions section and a property with a $ref.\n    schema = {\n        \"definitions\": {\"refObj\": {\"type\": \"string\", \"default\": None}},\n        \"type\": \"object\",\n        \"properties\": {\"a\": {\"$ref\": \"#/definitions/refObj\", \"description\": \"desc\"}},\n    }\n    result = ensure_strict_json_schema(schema)\n    a_schema = result[\"properties\"][\"a\"]\n    # The $ref should be expanded so that the type is from the referenced definition,",
        "detail": "tests.test_strict_schema",
        "documentation": {}
    },
    {
        "label": "test_ref_no_expansion_when_alone",
        "kind": 2,
        "importPath": "tests.test_strict_schema",
        "description": "tests.test_strict_schema",
        "peekOfCode": "def test_ref_no_expansion_when_alone():\n    # If the schema only contains a $ref key, it should not be expanded.\n    schema = {\"$ref\": \"#/definitions/refObj\"}\n    result = ensure_strict_json_schema(schema)\n    # Because there is only one key, the $ref remains unchanged.\n    assert result == {\"$ref\": \"#/definitions/refObj\"}\ndef test_invalid_ref_format():\n    # A $ref that does not start with \"#/\" should trigger a ValueError when resolved.\n    schema = {\"type\": \"object\", \"properties\": {\"a\": {\"$ref\": \"invalid\", \"description\": \"desc\"}}}\n    with pytest.raises(ValueError):",
        "detail": "tests.test_strict_schema",
        "documentation": {}
    },
    {
        "label": "test_invalid_ref_format",
        "kind": 2,
        "importPath": "tests.test_strict_schema",
        "description": "tests.test_strict_schema",
        "peekOfCode": "def test_invalid_ref_format():\n    # A $ref that does not start with \"#/\" should trigger a ValueError when resolved.\n    schema = {\"type\": \"object\", \"properties\": {\"a\": {\"$ref\": \"invalid\", \"description\": \"desc\"}}}\n    with pytest.raises(ValueError):\n        ensure_strict_json_schema(schema)",
        "detail": "tests.test_strict_schema",
        "documentation": {}
    },
    {
        "label": "Foo",
        "kind": 6,
        "importPath": "tests.test_tool_converter",
        "description": "tests.test_tool_converter",
        "peekOfCode": "class Foo(BaseModel):\n    a: str\n    b: list[int]\ndef test_convert_handoff_tool():\n    agent = Agent(name=\"test_1\", handoff_description=\"test_2\")\n    handoff_obj = handoff(agent=agent)\n    result = ToolConverter.convert_handoff_tool(handoff_obj)\n    assert result[\"type\"] == \"function\"\n    assert result[\"function\"][\"name\"] == Handoff.default_tool_name(agent)\n    assert result[\"function\"].get(\"description\") == Handoff.default_tool_description(agent)",
        "detail": "tests.test_tool_converter",
        "documentation": {}
    },
    {
        "label": "some_function",
        "kind": 2,
        "importPath": "tests.test_tool_converter",
        "description": "tests.test_tool_converter",
        "peekOfCode": "def some_function(a: str, b: list[int]) -> str:\n    return \"hello\"\ndef test_to_openai_with_function_tool():\n    some_function(a=\"foo\", b=[1, 2, 3])\n    tool = function_tool(some_function)\n    result = ToolConverter.to_openai(tool)\n    assert result[\"type\"] == \"function\"\n    assert result[\"function\"][\"name\"] == \"some_function\"\n    params = result.get(\"function\", {}).get(\"parameters\")\n    assert params is not None",
        "detail": "tests.test_tool_converter",
        "documentation": {}
    },
    {
        "label": "test_to_openai_with_function_tool",
        "kind": 2,
        "importPath": "tests.test_tool_converter",
        "description": "tests.test_tool_converter",
        "peekOfCode": "def test_to_openai_with_function_tool():\n    some_function(a=\"foo\", b=[1, 2, 3])\n    tool = function_tool(some_function)\n    result = ToolConverter.to_openai(tool)\n    assert result[\"type\"] == \"function\"\n    assert result[\"function\"][\"name\"] == \"some_function\"\n    params = result.get(\"function\", {}).get(\"parameters\")\n    assert params is not None\n    properties = params.get(\"properties\", {})\n    assert isinstance(properties, dict)",
        "detail": "tests.test_tool_converter",
        "documentation": {}
    },
    {
        "label": "test_convert_handoff_tool",
        "kind": 2,
        "importPath": "tests.test_tool_converter",
        "description": "tests.test_tool_converter",
        "peekOfCode": "def test_convert_handoff_tool():\n    agent = Agent(name=\"test_1\", handoff_description=\"test_2\")\n    handoff_obj = handoff(agent=agent)\n    result = ToolConverter.convert_handoff_tool(handoff_obj)\n    assert result[\"type\"] == \"function\"\n    assert result[\"function\"][\"name\"] == Handoff.default_tool_name(agent)\n    assert result[\"function\"].get(\"description\") == Handoff.default_tool_description(agent)\n    params = result.get(\"function\", {}).get(\"parameters\")\n    assert params is not None\n    for key, value in handoff_obj.input_json_schema.items():",
        "detail": "tests.test_tool_converter",
        "documentation": {}
    },
    {
        "label": "test_tool_converter_hosted_tools_errors",
        "kind": 2,
        "importPath": "tests.test_tool_converter",
        "description": "tests.test_tool_converter",
        "peekOfCode": "def test_tool_converter_hosted_tools_errors():\n    with pytest.raises(UserError):\n        ToolConverter.to_openai(WebSearchTool())\n    with pytest.raises(UserError):\n        ToolConverter.to_openai(FileSearchTool(vector_store_ids=[\"abc\"], max_num_results=1))",
        "detail": "tests.test_tool_converter",
        "documentation": {}
    },
    {
        "label": "get_span",
        "kind": 2,
        "importPath": "tests.test_trace_processor",
        "description": "tests.test_trace_processor",
        "peekOfCode": "def get_span(processor: TracingProcessor) -> SpanImpl[AgentSpanData]:\n    \"\"\"Create a minimal agent span for testing processors.\"\"\"\n    return SpanImpl(\n        trace_id=\"test_trace_id\",\n        span_id=\"test_span_id\",\n        parent_id=None,\n        processor=processor,\n        span_data=AgentSpanData(name=\"test_agent\"),\n    )\ndef get_trace(processor: TracingProcessor) -> TraceImpl:",
        "detail": "tests.test_trace_processor",
        "documentation": {}
    },
    {
        "label": "get_trace",
        "kind": 2,
        "importPath": "tests.test_trace_processor",
        "description": "tests.test_trace_processor",
        "peekOfCode": "def get_trace(processor: TracingProcessor) -> TraceImpl:\n    \"\"\"Create a minimal trace.\"\"\"\n    return TraceImpl(\n        name=\"test_trace\",\n        trace_id=\"test_trace_id\",\n        group_id=\"test_session_id\",\n        metadata={},\n        processor=processor,\n    )\n@pytest.fixture",
        "detail": "tests.test_trace_processor",
        "documentation": {}
    },
    {
        "label": "mocked_exporter",
        "kind": 2,
        "importPath": "tests.test_trace_processor",
        "description": "tests.test_trace_processor",
        "peekOfCode": "def mocked_exporter():\n    exporter = MagicMock()\n    exporter.export = MagicMock()\n    return exporter\ndef test_batch_trace_processor_on_trace_start(mocked_exporter):\n    processor = BatchTraceProcessor(exporter=mocked_exporter, schedule_delay=0.1)\n    test_trace = get_trace(processor)\n    processor.on_trace_start(test_trace)\n    assert processor._queue.qsize() == 1, \"Trace should be added to the queue\"\n    # Shutdown to clean up the worker thread",
        "detail": "tests.test_trace_processor",
        "documentation": {}
    },
    {
        "label": "test_batch_trace_processor_on_trace_start",
        "kind": 2,
        "importPath": "tests.test_trace_processor",
        "description": "tests.test_trace_processor",
        "peekOfCode": "def test_batch_trace_processor_on_trace_start(mocked_exporter):\n    processor = BatchTraceProcessor(exporter=mocked_exporter, schedule_delay=0.1)\n    test_trace = get_trace(processor)\n    processor.on_trace_start(test_trace)\n    assert processor._queue.qsize() == 1, \"Trace should be added to the queue\"\n    # Shutdown to clean up the worker thread\n    processor.shutdown()\ndef test_batch_trace_processor_on_span_end(mocked_exporter):\n    processor = BatchTraceProcessor(exporter=mocked_exporter, schedule_delay=0.1)\n    test_span = get_span(processor)",
        "detail": "tests.test_trace_processor",
        "documentation": {}
    },
    {
        "label": "test_batch_trace_processor_on_span_end",
        "kind": 2,
        "importPath": "tests.test_trace_processor",
        "description": "tests.test_trace_processor",
        "peekOfCode": "def test_batch_trace_processor_on_span_end(mocked_exporter):\n    processor = BatchTraceProcessor(exporter=mocked_exporter, schedule_delay=0.1)\n    test_span = get_span(processor)\n    processor.on_span_end(test_span)\n    assert processor._queue.qsize() == 1, \"Span should be added to the queue\"\n    # Shutdown to clean up the worker thread\n    processor.shutdown()\ndef test_batch_trace_processor_queue_full(mocked_exporter):\n    processor = BatchTraceProcessor(exporter=mocked_exporter, max_queue_size=2, schedule_delay=0.1)\n    # Fill the queue",
        "detail": "tests.test_trace_processor",
        "documentation": {}
    },
    {
        "label": "test_batch_trace_processor_queue_full",
        "kind": 2,
        "importPath": "tests.test_trace_processor",
        "description": "tests.test_trace_processor",
        "peekOfCode": "def test_batch_trace_processor_queue_full(mocked_exporter):\n    processor = BatchTraceProcessor(exporter=mocked_exporter, max_queue_size=2, schedule_delay=0.1)\n    # Fill the queue\n    processor.on_trace_start(get_trace(processor))\n    processor.on_trace_start(get_trace(processor))\n    assert processor._queue.full() is True\n    # Next item should not be queued\n    processor.on_trace_start(get_trace(processor))\n    assert processor._queue.qsize() == 2, \"Queue should not exceed max_queue_size\"\n    processor.on_span_end(get_span(processor))",
        "detail": "tests.test_trace_processor",
        "documentation": {}
    },
    {
        "label": "test_batch_processor_doesnt_enqueue_on_trace_end_or_span_start",
        "kind": 2,
        "importPath": "tests.test_trace_processor",
        "description": "tests.test_trace_processor",
        "peekOfCode": "def test_batch_processor_doesnt_enqueue_on_trace_end_or_span_start(mocked_exporter):\n    processor = BatchTraceProcessor(exporter=mocked_exporter)\n    processor.on_trace_start(get_trace(processor))\n    assert processor._queue.qsize() == 1, \"Trace should be queued\"\n    processor.on_span_start(get_span(processor))\n    assert processor._queue.qsize() == 1, \"Span should not be queued\"\n    processor.on_span_end(get_span(processor))\n    assert processor._queue.qsize() == 2, \"Span should be queued\"\n    processor.on_trace_end(get_trace(processor))\n    assert processor._queue.qsize() == 2, \"Nothing new should be queued\"",
        "detail": "tests.test_trace_processor",
        "documentation": {}
    },
    {
        "label": "test_batch_trace_processor_force_flush",
        "kind": 2,
        "importPath": "tests.test_trace_processor",
        "description": "tests.test_trace_processor",
        "peekOfCode": "def test_batch_trace_processor_force_flush(mocked_exporter):\n    processor = BatchTraceProcessor(exporter=mocked_exporter, max_batch_size=2, schedule_delay=5.0)\n    processor.on_trace_start(get_trace(processor))\n    processor.on_span_end(get_span(processor))\n    processor.on_span_end(get_span(processor))\n    processor.force_flush()\n    # Ensure exporter.export was called with all items\n    # Because max_batch_size=2, it may have been called multiple times\n    total_exported = 0\n    for call_args in mocked_exporter.export.call_args_list:",
        "detail": "tests.test_trace_processor",
        "documentation": {}
    },
    {
        "label": "test_batch_trace_processor_shutdown_flushes",
        "kind": 2,
        "importPath": "tests.test_trace_processor",
        "description": "tests.test_trace_processor",
        "peekOfCode": "def test_batch_trace_processor_shutdown_flushes(mocked_exporter):\n    processor = BatchTraceProcessor(exporter=mocked_exporter, schedule_delay=5.0)\n    processor.on_trace_start(get_trace(processor))\n    processor.on_span_end(get_span(processor))\n    qsize_before = processor._queue.qsize()\n    assert qsize_before == 2\n    processor.shutdown()\n    # Ensure everything was exported after shutdown\n    total_exported = 0\n    for call_args in mocked_exporter.export.call_args_list:",
        "detail": "tests.test_trace_processor",
        "documentation": {}
    },
    {
        "label": "test_batch_trace_processor_scheduled_export",
        "kind": 2,
        "importPath": "tests.test_trace_processor",
        "description": "tests.test_trace_processor",
        "peekOfCode": "def test_batch_trace_processor_scheduled_export(mocked_exporter):\n    \"\"\"\n    Tests that items are automatically exported when the schedule_delay expires.\n    We mock time.time() so we can trigger the condition without waiting in real time.\n    \"\"\"\n    with patch(\"time.time\") as mock_time:\n        base_time = 1000.0\n        mock_time.return_value = base_time\n        processor = BatchTraceProcessor(exporter=mocked_exporter, schedule_delay=1.0)\n        processor.on_span_end(get_span(processor))  # queue size = 1",
        "detail": "tests.test_trace_processor",
        "documentation": {}
    },
    {
        "label": "patched_time_sleep",
        "kind": 2,
        "importPath": "tests.test_trace_processor",
        "description": "tests.test_trace_processor",
        "peekOfCode": "def patched_time_sleep():\n    \"\"\"\n    Fixture to replace time.sleep with a no-op to speed up tests\n    that rely on retry/backoff logic.\n    \"\"\"\n    with patch(\"time.sleep\") as mock_sleep:\n        yield mock_sleep\ndef mock_processor():\n    processor = MagicMock()\n    processor.on_trace_start = MagicMock()",
        "detail": "tests.test_trace_processor",
        "documentation": {}
    },
    {
        "label": "mock_processor",
        "kind": 2,
        "importPath": "tests.test_trace_processor",
        "description": "tests.test_trace_processor",
        "peekOfCode": "def mock_processor():\n    processor = MagicMock()\n    processor.on_trace_start = MagicMock()\n    processor.on_span_end = MagicMock()\n    return processor\n@patch(\"httpx.Client\")\ndef test_backend_span_exporter_no_items(mock_client):\n    exporter = BackendSpanExporter(api_key=\"test_key\")\n    exporter.export([])\n    # No calls should be made if there are no items",
        "detail": "tests.test_trace_processor",
        "documentation": {}
    },
    {
        "label": "test_backend_span_exporter_no_items",
        "kind": 2,
        "importPath": "tests.test_trace_processor",
        "description": "tests.test_trace_processor",
        "peekOfCode": "def test_backend_span_exporter_no_items(mock_client):\n    exporter = BackendSpanExporter(api_key=\"test_key\")\n    exporter.export([])\n    # No calls should be made if there are no items\n    mock_client.return_value.post.assert_not_called()\n    exporter.close()\n@patch(\"httpx.Client\")\ndef test_backend_span_exporter_no_api_key(mock_client):\n    # Ensure that os.environ is empty (sometimes devs have the openai api key set in their env)\n    with patch.dict(os.environ, {}, clear=True):",
        "detail": "tests.test_trace_processor",
        "documentation": {}
    },
    {
        "label": "test_backend_span_exporter_no_api_key",
        "kind": 2,
        "importPath": "tests.test_trace_processor",
        "description": "tests.test_trace_processor",
        "peekOfCode": "def test_backend_span_exporter_no_api_key(mock_client):\n    # Ensure that os.environ is empty (sometimes devs have the openai api key set in their env)\n    with patch.dict(os.environ, {}, clear=True):\n        exporter = BackendSpanExporter(api_key=None)\n        exporter.export([get_span(mock_processor())])\n        # Should log an error and return without calling post\n        mock_client.return_value.post.assert_not_called()\n        exporter.close()\n@patch(\"httpx.Client\")\ndef test_backend_span_exporter_2xx_success(mock_client):",
        "detail": "tests.test_trace_processor",
        "documentation": {}
    },
    {
        "label": "test_backend_span_exporter_2xx_success",
        "kind": 2,
        "importPath": "tests.test_trace_processor",
        "description": "tests.test_trace_processor",
        "peekOfCode": "def test_backend_span_exporter_2xx_success(mock_client):\n    mock_response = MagicMock()\n    mock_response.status_code = 200\n    mock_client.return_value.post.return_value = mock_response\n    exporter = BackendSpanExporter(api_key=\"test_key\")\n    exporter.export([get_span(mock_processor()), get_trace(mock_processor())])\n    # Should have called post exactly once\n    mock_client.return_value.post.assert_called_once()\n    exporter.close()\n@patch(\"httpx.Client\")",
        "detail": "tests.test_trace_processor",
        "documentation": {}
    },
    {
        "label": "test_backend_span_exporter_4xx_client_error",
        "kind": 2,
        "importPath": "tests.test_trace_processor",
        "description": "tests.test_trace_processor",
        "peekOfCode": "def test_backend_span_exporter_4xx_client_error(mock_client):\n    mock_response = MagicMock()\n    mock_response.status_code = 400\n    mock_response.text = \"Bad Request\"\n    mock_client.return_value.post.return_value = mock_response\n    exporter = BackendSpanExporter(api_key=\"test_key\")\n    exporter.export([get_span(mock_processor())])\n    # 4xx should not be retried\n    mock_client.return_value.post.assert_called_once()\n    exporter.close()",
        "detail": "tests.test_trace_processor",
        "documentation": {}
    },
    {
        "label": "test_backend_span_exporter_5xx_retry",
        "kind": 2,
        "importPath": "tests.test_trace_processor",
        "description": "tests.test_trace_processor",
        "peekOfCode": "def test_backend_span_exporter_5xx_retry(mock_client, patched_time_sleep):\n    mock_response = MagicMock()\n    mock_response.status_code = 500\n    # Make post() return 500 every time\n    mock_client.return_value.post.return_value = mock_response\n    exporter = BackendSpanExporter(api_key=\"test_key\", max_retries=3, base_delay=0.1, max_delay=0.2)\n    exporter.export([get_span(mock_processor())])\n    # Should retry up to max_retries times\n    assert mock_client.return_value.post.call_count == 3\n    exporter.close()",
        "detail": "tests.test_trace_processor",
        "documentation": {}
    },
    {
        "label": "test_backend_span_exporter_request_error",
        "kind": 2,
        "importPath": "tests.test_trace_processor",
        "description": "tests.test_trace_processor",
        "peekOfCode": "def test_backend_span_exporter_request_error(mock_client, patched_time_sleep):\n    # Make post() raise a RequestError each time\n    mock_client.return_value.post.side_effect = httpx.RequestError(\"Network error\")\n    exporter = BackendSpanExporter(api_key=\"test_key\", max_retries=2, base_delay=0.1, max_delay=0.2)\n    exporter.export([get_span(mock_processor())])\n    # Should retry up to max_retries times\n    assert mock_client.return_value.post.call_count == 2\n    exporter.close()\n@patch(\"httpx.Client\")\ndef test_backend_span_exporter_close(mock_client):",
        "detail": "tests.test_trace_processor",
        "documentation": {}
    },
    {
        "label": "test_backend_span_exporter_close",
        "kind": 2,
        "importPath": "tests.test_trace_processor",
        "description": "tests.test_trace_processor",
        "peekOfCode": "def test_backend_span_exporter_close(mock_client):\n    exporter = BackendSpanExporter(api_key=\"test_key\")\n    exporter.close()\n    # Ensure underlying http client is closed\n    mock_client.return_value.close.assert_called_once()",
        "detail": "tests.test_trace_processor",
        "documentation": {}
    },
    {
        "label": "standard_span_checks",
        "kind": 2,
        "importPath": "tests.test_tracing",
        "description": "tests.test_tracing",
        "peekOfCode": "def standard_span_checks(\n    span: Span[Any], trace_id: str, parent_id: str | None, span_type: str\n) -> None:\n    assert span.span_id is not None\n    assert span.trace_id == trace_id\n    assert span.parent_id == parent_id\n    assert span.started_at is not None\n    assert span.ended_at is not None\n    assert span.span_data.type == span_type\ndef standard_trace_checks(trace: Trace, name_check: str | None = None) -> None:",
        "detail": "tests.test_tracing",
        "documentation": {}
    },
    {
        "label": "standard_trace_checks",
        "kind": 2,
        "importPath": "tests.test_tracing",
        "description": "tests.test_tracing",
        "peekOfCode": "def standard_trace_checks(trace: Trace, name_check: str | None = None) -> None:\n    assert trace.trace_id is not None\n    if name_check:\n        assert trace.name == name_check\n### TESTS\ndef simple_tracing():\n    x = trace(\"test\")\n    x.start()\n    span_1 = agent_span(name=\"agent_1\", parent=x)\n    span_1.start()",
        "detail": "tests.test_tracing",
        "documentation": {}
    },
    {
        "label": "simple_tracing",
        "kind": 2,
        "importPath": "tests.test_tracing",
        "description": "tests.test_tracing",
        "peekOfCode": "def simple_tracing():\n    x = trace(\"test\")\n    x.start()\n    span_1 = agent_span(name=\"agent_1\", parent=x)\n    span_1.start()\n    span_1.finish()\n    span_2 = custom_span(name=\"custom_1\", span_id=\"span_2\", parent=x)\n    span_2.start()\n    span_3 = custom_span(name=\"custom_2\", span_id=\"span_3\", parent=span_2)\n    span_3.start()",
        "detail": "tests.test_tracing",
        "documentation": {}
    },
    {
        "label": "test_simple_tracing",
        "kind": 2,
        "importPath": "tests.test_tracing",
        "description": "tests.test_tracing",
        "peekOfCode": "def test_simple_tracing() -> None:\n    simple_tracing()\n    spans, traces = fetch_ordered_spans(), fetch_traces()\n    assert len(spans) == 3\n    assert len(traces) == 1\n    trace = traces[0]\n    standard_trace_checks(trace, name_check=\"test\")\n    trace_id = trace.trace_id\n    first_span = spans[0]\n    standard_span_checks(first_span, trace_id=trace_id, parent_id=None, span_type=\"agent\")",
        "detail": "tests.test_tracing",
        "documentation": {}
    },
    {
        "label": "ctxmanager_spans",
        "kind": 2,
        "importPath": "tests.test_tracing",
        "description": "tests.test_tracing",
        "peekOfCode": "def ctxmanager_spans():\n    with trace(workflow_name=\"test\", trace_id=\"123\", group_id=\"456\"):\n        with custom_span(name=\"custom_1\", span_id=\"span_1\"):\n            with custom_span(name=\"custom_2\", span_id=\"span_1_inner\"):\n                pass\n        with custom_span(name=\"custom_2\", span_id=\"span_2\"):\n            pass\ndef test_ctxmanager_spans() -> None:\n    ctxmanager_spans()\n    spans, traces = fetch_ordered_spans(), fetch_traces()",
        "detail": "tests.test_tracing",
        "documentation": {}
    },
    {
        "label": "test_ctxmanager_spans",
        "kind": 2,
        "importPath": "tests.test_tracing",
        "description": "tests.test_tracing",
        "peekOfCode": "def test_ctxmanager_spans() -> None:\n    ctxmanager_spans()\n    spans, traces = fetch_ordered_spans(), fetch_traces()\n    assert len(spans) == 3\n    assert len(traces) == 1\n    trace = traces[0]\n    standard_trace_checks(trace, name_check=\"test\")\n    trace_id = trace.trace_id\n    first_span = spans[0]\n    standard_span_checks(first_span, trace_id=trace_id, parent_id=None, span_type=\"custom\")",
        "detail": "tests.test_tracing",
        "documentation": {}
    },
    {
        "label": "spans_with_setters",
        "kind": 2,
        "importPath": "tests.test_tracing",
        "description": "tests.test_tracing",
        "peekOfCode": "def spans_with_setters():\n    with trace(workflow_name=\"test\", trace_id=\"123\", group_id=\"456\"):\n        with agent_span(name=\"agent_1\") as span_a:\n            span_a.span_data.name = \"agent_2\"\n            with function_span(name=\"function_1\") as span_b:\n                span_b.span_data.input = \"i\"\n                span_b.span_data.output = \"o\"\n            with generation_span() as span_c:\n                span_c.span_data.input = [{\"foo\": \"bar\"}]\n            with handoff_span(from_agent=\"agent_1\", to_agent=\"agent_2\"):",
        "detail": "tests.test_tracing",
        "documentation": {}
    },
    {
        "label": "test_spans_with_setters",
        "kind": 2,
        "importPath": "tests.test_tracing",
        "description": "tests.test_tracing",
        "peekOfCode": "def test_spans_with_setters() -> None:\n    spans_with_setters()\n    spans, traces = fetch_ordered_spans(), fetch_traces()\n    assert len(spans) == 4\n    assert len(traces) == 1\n    trace = traces[0]\n    standard_trace_checks(trace, name_check=\"test\")\n    trace_id = trace.trace_id\n    # Check the spans\n    first_span = spans[0]",
        "detail": "tests.test_tracing",
        "documentation": {}
    },
    {
        "label": "disabled_tracing",
        "kind": 2,
        "importPath": "tests.test_tracing",
        "description": "tests.test_tracing",
        "peekOfCode": "def disabled_tracing():\n    with trace(workflow_name=\"test\", trace_id=\"123\", group_id=\"456\", disabled=True):\n        with agent_span(name=\"agent_1\"):\n            with function_span(name=\"function_1\"):\n                pass\ndef test_disabled_tracing():\n    disabled_tracing()\n    spans, traces = fetch_ordered_spans(), fetch_traces()\n    assert len(spans) == 0\n    assert len(traces) == 0",
        "detail": "tests.test_tracing",
        "documentation": {}
    },
    {
        "label": "test_disabled_tracing",
        "kind": 2,
        "importPath": "tests.test_tracing",
        "description": "tests.test_tracing",
        "peekOfCode": "def test_disabled_tracing():\n    disabled_tracing()\n    spans, traces = fetch_ordered_spans(), fetch_traces()\n    assert len(spans) == 0\n    assert len(traces) == 0\ndef enabled_trace_disabled_span():\n    with trace(workflow_name=\"test\", trace_id=\"123\"):\n        with agent_span(name=\"agent_1\"):\n            with function_span(name=\"function_1\", disabled=True):\n                with generation_span():",
        "detail": "tests.test_tracing",
        "documentation": {}
    },
    {
        "label": "enabled_trace_disabled_span",
        "kind": 2,
        "importPath": "tests.test_tracing",
        "description": "tests.test_tracing",
        "peekOfCode": "def enabled_trace_disabled_span():\n    with trace(workflow_name=\"test\", trace_id=\"123\"):\n        with agent_span(name=\"agent_1\"):\n            with function_span(name=\"function_1\", disabled=True):\n                with generation_span():\n                    pass\ndef test_enabled_trace_disabled_span():\n    enabled_trace_disabled_span()\n    spans, traces = fetch_ordered_spans(), fetch_traces()\n    assert len(spans) == 1  # Only the agent span is recorded",
        "detail": "tests.test_tracing",
        "documentation": {}
    },
    {
        "label": "test_enabled_trace_disabled_span",
        "kind": 2,
        "importPath": "tests.test_tracing",
        "description": "tests.test_tracing",
        "peekOfCode": "def test_enabled_trace_disabled_span():\n    enabled_trace_disabled_span()\n    spans, traces = fetch_ordered_spans(), fetch_traces()\n    assert len(spans) == 1  # Only the agent span is recorded\n    assert len(traces) == 1  # The trace is recorded\n    trace = traces[0]\n    standard_trace_checks(trace, name_check=\"test\")\n    trace_id = trace.trace_id\n    first_span = spans[0]\n    standard_span_checks(first_span, trace_id=trace_id, parent_id=None, span_type=\"agent\")",
        "detail": "tests.test_tracing",
        "documentation": {}
    },
    {
        "label": "test_start_and_end_called_manual",
        "kind": 2,
        "importPath": "tests.test_tracing",
        "description": "tests.test_tracing",
        "peekOfCode": "def test_start_and_end_called_manual():\n    simple_tracing()\n    events = fetch_events()\n    assert events == [\n        \"trace_start\",\n        \"span_start\",  # span_1\n        \"span_end\",  # span_1\n        \"span_start\",  # span_2\n        \"span_start\",  # span_3\n        \"span_end\",  # span_3",
        "detail": "tests.test_tracing",
        "documentation": {}
    },
    {
        "label": "test_start_and_end_called_ctxmanager",
        "kind": 2,
        "importPath": "tests.test_tracing",
        "description": "tests.test_tracing",
        "peekOfCode": "def test_start_and_end_called_ctxmanager():\n    with trace(workflow_name=\"test\", trace_id=\"123\", group_id=\"456\"):\n        with custom_span(name=\"custom_1\", span_id=\"span_1\"):\n            with custom_span(name=\"custom_2\", span_id=\"span_1_inner\"):\n                pass\n        with custom_span(name=\"custom_2\", span_id=\"span_2\"):\n            pass\n    events = fetch_events()\n    assert events == [\n        \"trace_start\",",
        "detail": "tests.test_tracing",
        "documentation": {}
    },
    {
        "label": "Foo",
        "kind": 6,
        "importPath": "tests.test_tracing_errors",
        "description": "tests.test_tracing_errors",
        "peekOfCode": "class Foo(TypedDict):\n    bar: str\n@pytest.mark.asyncio\nasync def test_multiple_final_output_doesnt_error():\n    model = FakeModel(tracing_enabled=True)\n    agent_1 = Agent(\n        name=\"test\",\n        model=model,\n        output_type=Foo,\n    )",
        "detail": "tests.test_tracing_errors",
        "documentation": {}
    },
    {
        "label": "guardrail_function",
        "kind": 2,
        "importPath": "tests.test_tracing_errors",
        "description": "tests.test_tracing_errors",
        "peekOfCode": "def guardrail_function(\n    context: RunContextWrapper[Any], agent: Agent[Any], input: str | list[TResponseInputItem]\n) -> GuardrailFunctionOutput:\n    return GuardrailFunctionOutput(\n        output_info=None,\n        tripwire_triggered=True,\n    )\n@pytest.mark.asyncio\nasync def test_guardrail_error():\n    agent = Agent(",
        "detail": "tests.test_tracing_errors",
        "documentation": {}
    },
    {
        "label": "Foo",
        "kind": 6,
        "importPath": "tests.test_tracing_errors_streamed",
        "description": "tests.test_tracing_errors_streamed",
        "peekOfCode": "class Foo(TypedDict):\n    bar: str\n@pytest.mark.asyncio\nasync def test_multiple_final_output_no_error():\n    model = FakeModel(tracing_enabled=True)\n    agent_1 = Agent(\n        name=\"test\",\n        model=model,\n        output_type=Foo,\n    )",
        "detail": "tests.test_tracing_errors_streamed",
        "documentation": {}
    },
    {
        "label": "input_guardrail_function",
        "kind": 2,
        "importPath": "tests.test_tracing_errors_streamed",
        "description": "tests.test_tracing_errors_streamed",
        "peekOfCode": "def input_guardrail_function(\n    context: RunContextWrapper[Any], agent: Agent[Any], input: str | list[TResponseInputItem]\n) -> GuardrailFunctionOutput:\n    return GuardrailFunctionOutput(\n        output_info=None,\n        tripwire_triggered=True,\n    )\n@pytest.mark.asyncio\nasync def test_input_guardrail_error():\n    model = FakeModel()",
        "detail": "tests.test_tracing_errors_streamed",
        "documentation": {}
    },
    {
        "label": "output_guardrail_function",
        "kind": 2,
        "importPath": "tests.test_tracing_errors_streamed",
        "description": "tests.test_tracing_errors_streamed",
        "peekOfCode": "def output_guardrail_function(\n    context: RunContextWrapper[Any], agent: Agent[Any], agent_output: Any\n) -> GuardrailFunctionOutput:\n    return GuardrailFunctionOutput(\n        output_info=None,\n        tripwire_triggered=True,\n    )\n@pytest.mark.asyncio\nasync def test_output_guardrail_error():\n    model = FakeModel()",
        "detail": "tests.test_tracing_errors_streamed",
        "documentation": {}
    },
    {
        "label": "SpanProcessorForTests",
        "kind": 6,
        "importPath": "tests.testing_processor",
        "description": "tests.testing_processor",
        "peekOfCode": "class SpanProcessorForTests(TracingProcessor):\n    \"\"\"\n    A simple processor that stores finished spans in memory.\n    This is thread-safe and suitable for tests or basic usage.\n    \"\"\"\n    def __init__(self) -> None:\n        self._lock = threading.Lock()\n        # Dictionary of trace_id -> list of spans\n        self._spans: list[Span[Any]] = []\n        self._traces: list[Trace] = []",
        "detail": "tests.testing_processor",
        "documentation": {}
    },
    {
        "label": "fetch_ordered_spans",
        "kind": 2,
        "importPath": "tests.testing_processor",
        "description": "tests.testing_processor",
        "peekOfCode": "def fetch_ordered_spans() -> list[Span[Any]]:\n    return SPAN_PROCESSOR_TESTING.get_ordered_spans()\ndef fetch_traces() -> list[Trace]:\n    return SPAN_PROCESSOR_TESTING.get_traces()\ndef fetch_events() -> list[TestSpanProcessorEvent]:\n    return SPAN_PROCESSOR_TESTING._events\ndef fetch_normalized_spans():\n    nodes: dict[tuple[str, str | None], dict[str, Any]] = {}\n    traces = []\n    for trace_obj in fetch_traces():",
        "detail": "tests.testing_processor",
        "documentation": {}
    },
    {
        "label": "fetch_traces",
        "kind": 2,
        "importPath": "tests.testing_processor",
        "description": "tests.testing_processor",
        "peekOfCode": "def fetch_traces() -> list[Trace]:\n    return SPAN_PROCESSOR_TESTING.get_traces()\ndef fetch_events() -> list[TestSpanProcessorEvent]:\n    return SPAN_PROCESSOR_TESTING._events\ndef fetch_normalized_spans():\n    nodes: dict[tuple[str, str | None], dict[str, Any]] = {}\n    traces = []\n    for trace_obj in fetch_traces():\n        trace = trace_obj.export()\n        assert trace",
        "detail": "tests.testing_processor",
        "documentation": {}
    },
    {
        "label": "fetch_events",
        "kind": 2,
        "importPath": "tests.testing_processor",
        "description": "tests.testing_processor",
        "peekOfCode": "def fetch_events() -> list[TestSpanProcessorEvent]:\n    return SPAN_PROCESSOR_TESTING._events\ndef fetch_normalized_spans():\n    nodes: dict[tuple[str, str | None], dict[str, Any]] = {}\n    traces = []\n    for trace_obj in fetch_traces():\n        trace = trace_obj.export()\n        assert trace\n        assert trace.pop(\"object\") == \"trace\"\n        assert trace.pop(\"id\").startswith(\"trace_\")",
        "detail": "tests.testing_processor",
        "documentation": {}
    },
    {
        "label": "fetch_normalized_spans",
        "kind": 2,
        "importPath": "tests.testing_processor",
        "description": "tests.testing_processor",
        "peekOfCode": "def fetch_normalized_spans():\n    nodes: dict[tuple[str, str | None], dict[str, Any]] = {}\n    traces = []\n    for trace_obj in fetch_traces():\n        trace = trace_obj.export()\n        assert trace\n        assert trace.pop(\"object\") == \"trace\"\n        assert trace.pop(\"id\").startswith(\"trace_\")\n        trace = {k: v for k, v in trace.items() if v is not None}\n        nodes[(trace_obj.trace_id, None)] = trace",
        "detail": "tests.testing_processor",
        "documentation": {}
    },
    {
        "label": "TestSpanProcessorEvent",
        "kind": 5,
        "importPath": "tests.testing_processor",
        "description": "tests.testing_processor",
        "peekOfCode": "TestSpanProcessorEvent = Literal[\"trace_start\", \"trace_end\", \"span_start\", \"span_end\"]\nclass SpanProcessorForTests(TracingProcessor):\n    \"\"\"\n    A simple processor that stores finished spans in memory.\n    This is thread-safe and suitable for tests or basic usage.\n    \"\"\"\n    def __init__(self) -> None:\n        self._lock = threading.Lock()\n        # Dictionary of trace_id -> list of spans\n        self._spans: list[Span[Any]] = []",
        "detail": "tests.testing_processor",
        "documentation": {}
    },
    {
        "label": "SPAN_PROCESSOR_TESTING",
        "kind": 5,
        "importPath": "tests.testing_processor",
        "description": "tests.testing_processor",
        "peekOfCode": "SPAN_PROCESSOR_TESTING = SpanProcessorForTests()\ndef fetch_ordered_spans() -> list[Span[Any]]:\n    return SPAN_PROCESSOR_TESTING.get_ordered_spans()\ndef fetch_traces() -> list[Trace]:\n    return SPAN_PROCESSOR_TESTING.get_traces()\ndef fetch_events() -> list[TestSpanProcessorEvent]:\n    return SPAN_PROCESSOR_TESTING._events\ndef fetch_normalized_spans():\n    nodes: dict[tuple[str, str | None], dict[str, Any]] = {}\n    traces = []",
        "detail": "tests.testing_processor",
        "documentation": {}
    }
]