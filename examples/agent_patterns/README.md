# 常见智能体模式

本目录包含不同智能体常用模式的示例。

## 确定性流程

常见策略是将任务拆分为一系列较小步骤。每个步骤可由智能体执行，前一个智能体的输出作为后一个的输入。例如，若需生成故事，可拆分为以下步骤：

1. 生成大纲
2. 生成故事正文
3. 生成结局

每个步骤由独立智能体完成，前序输出作为后续输入。

具体示例参见 [`deterministic.py`](./deterministic.py) 文件。

## 任务交接与路由

常见场景是由专业子智能体处理特定任务，通过交接机制将任务路由至正确代理。

例如：前线智能体接收请求后，根据请求语言转交给专业语言处理智能体。
示例参见 [`routing.py`](./routing.py) 文件。

## 工具化智能体

传统交接模式是新智能体"接管"对话，查看历史记录并主导后续交互。但智能体亦可作为工具使用：工具智能体独立运行后，将结果返回原智能体。

以前述翻译任务为例，可采用工具调用模式：不转交语言专用智能体，而是将其作为工具调用，结果用于后续步骤。这种方式支持同时翻译多语言等场景。

示例参见 [`agents_as_tools.py`](./agents_as_tools.py) 文件。

## 大模型作为裁判

大模型在获得反馈后通常能提升输出质量。常见模式是先用模型生成响应，再用第二个模型提供反馈。为优化成本，甚至可用小模型生成初始结果，大模型提供反馈。

例如：用大模型生成故事大纲后，用第二个大模型评估大纲并提供改进建议，循环优化直至满意。

示例参见 [`llm_as_a_judge.py`](./llm_as_a_judge.py) 文件。

## 并行执行

并行运行多个智能体是常见模式，既有助于降低延迟（如多个无依赖步骤并行），也可用于生成多个响应择优选取。

[`parallelization.py`](./parallelization.py) 文件示例展示了并行运行翻译智能体并选择最佳结果。

## 防护机制

与并行化相关的是输入防护机制，用于确保智能体输入的有效性。例如客服场景中，需防止用户提交数学问题求助。

虽然通过并行化即可实现，但我们提供了专用防护原语。防护机制可设置"触发线"——若被触发，智能体会立即停止执行并抛出 `GuardrailTripwireTriggered` 异常。

这对延迟优化至关重要：例如用快速模型运行防护检查，慢速模型执行实际任务时，可快速拒绝无效输入避免等待。

输入/输出防护示例分别参见 [`input_guardrails.py`](./input_guardrails.py) 和 [`output_guardrails.py`](./output_guardrails.py) 文件。